#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2023.2.2),
    on Thu Nov 30 12:22:38 2023
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

import psychopy
psychopy.useVersion('2023.2.2')


# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import plugins
plugins.activatePlugins()
prefs.hardware['audioLib'] = 'ptb'
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout
from psychopy.tools import environmenttools
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER, priority)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard

# Run 'Before Experiment' code from cpdm_trial_code
#used in variable ITI
cpdm_delta_time = 0 
# Run 'Before Experiment' code from cpdm_trial_code
#used in variable ITI
cpdm_delta_time = 0 
# Run 'Before Experiment' code from cpdm_trial_code
#used in variable ITI
cpdm_delta_time = 0 
# --- Setup global variables (available in all functions) ---
# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
# Store info about the experiment session
psychopyVersion = '2023.2.2'
expName = 'idm_ado_v1'  # from the Builder filename that created this script
expInfo = {
    'participant': '',
    'date': data.getDateStr(),  # add a simple timestamp
    'expName': expName,
    'psychopyVersion': psychopyVersion,
}


def showExpInfoDlg(expInfo):
    """
    Show participant info dialog.
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    
    Returns
    ==========
    dict
        Information about this experiment.
    """
    # temporarily remove keys which the dialog doesn't need to show
    poppedKeys = {
        'date': expInfo.pop('date', data.getDateStr()),
        'expName': expInfo.pop('expName', expName),
        'psychopyVersion': expInfo.pop('psychopyVersion', psychopyVersion),
    }
    # show participant info dialog
    dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
    if dlg.OK == False:
        core.quit()  # user pressed cancel
    # restore hidden keys
    expInfo.update(poppedKeys)
    # return expInfo
    return expInfo


def setupData(expInfo, dataDir=None):
    """
    Make an ExperimentHandler to handle trials and saving.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    dataDir : Path, str or None
        Folder to save the data to, leave as None to create a folder in the current directory.    
    Returns
    ==========
    psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    
    # data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
    if dataDir is None:
        dataDir = _thisDir
    filename = u'data/%s_%s' % (expInfo['participant'], expInfo['date'])
    # make sure filename is relative to dataDir
    if os.path.isabs(filename):
        dataDir = os.path.commonprefix([dataDir, filename])
        filename = os.path.relpath(filename, dataDir)
    
    # an ExperimentHandler isn't essential but helps with data saving
    thisExp = data.ExperimentHandler(
        name=expName, version='',
        extraInfo=expInfo, runtimeInfo=None,
        originPath='/Users/renfroag/Desktop/IDM ADO/idm_ado_v1.py',
        savePickle=True, saveWideText=True,
        dataFileName=dataDir + os.sep + filename, sortColumns='time'
    )
    thisExp.setPriority('thisRow.t', priority.CRITICAL)
    thisExp.setPriority('expName', priority.LOW)
    # return experiment handler
    return thisExp


def setupLogging(filename):
    """
    Setup a log file and tell it what level to log at.
    
    Parameters
    ==========
    filename : str or pathlib.Path
        Filename to save log file and data files as, doesn't need an extension.
    
    Returns
    ==========
    psychopy.logging.LogFile
        Text stream to receive inputs from the logging system.
    """
    # this outputs to the screen, not a file
    logging.console.setLevel(logging.EXP)
    # save a log file for detail verbose info
    logFile = logging.LogFile(filename+'.log', level=logging.EXP)
    
    return logFile


def setupWindow(expInfo=None, win=None):
    """
    Setup the Window
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    win : psychopy.visual.Window
        Window to setup - leave as None to create a new window.
    
    Returns
    ==========
    psychopy.visual.Window
        Window in which to run this experiment.
    """
    if win is None:
        # if not given a window to setup, make one
        win = visual.Window(
            size=[1728, 1117], fullscr=True, screen=0,
            winType='pyglet', allowStencil=False,
            monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
            backgroundImage='', backgroundFit='none',
            blendMode='avg', useFBO=True,
            units='height'
        )
        if expInfo is not None:
            # store frame rate of monitor if we can measure it
            expInfo['frameRate'] = win.getActualFrameRate()
    else:
        # if we have a window, just set the attributes which are safe to set
        win.color = [0,0,0]
        win.colorSpace = 'rgb'
        win.backgroundImage = ''
        win.backgroundFit = 'none'
        win.units = 'height'
    win.mouseVisible = False
    win.hideMessage()
    return win


def setupInputs(expInfo, thisExp, win):
    """
    Setup whatever inputs are available (mouse, keyboard, eyetracker, etc.)
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window in which to run this experiment.
    Returns
    ==========
    dict
        Dictionary of input devices by name.
    """
    # --- Setup input devices ---
    inputs = {}
    ioConfig = {}
    ioSession = ioServer = eyetracker = None
    
    # create a default keyboard (e.g. to check for escape)
    defaultKeyboard = keyboard.Keyboard(backend='event')
    # return inputs dict
    return {
        'ioServer': ioServer,
        'defaultKeyboard': defaultKeyboard,
        'eyetracker': eyetracker,
    }

def pauseExperiment(thisExp, inputs=None, win=None, timers=[], playbackComponents=[]):
    """
    Pause this experiment, preventing the flow from advancing to the next routine until resumed.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    inputs : dict
        Dictionary of input devices by name.
    win : psychopy.visual.Window
        Window for this experiment.
    timers : list, tuple
        List of timers to reset once pausing is finished.
    playbackComponents : list, tuple
        List of any components with a `pause` method which need to be paused.
    """
    # if we are not paused, do nothing
    if thisExp.status != PAUSED:
        return
    
    # pause any playback components
    for comp in playbackComponents:
        comp.pause()
    # prevent components from auto-drawing
    win.stashAutoDraw()
    # run a while loop while we wait to unpause
    while thisExp.status == PAUSED:
        # make sure we have a keyboard
        if inputs is None:
            inputs = {
                'defaultKeyboard': keyboard.Keyboard(backend='Pyglet')
            }
        # check for quit (typically the Esc key)
        if inputs['defaultKeyboard'].getKeys(keyList=['escape']):
            endExperiment(thisExp, win=win, inputs=inputs)
        # flip the screen
        win.flip()
    # if stop was requested while paused, quit
    if thisExp.status == FINISHED:
        endExperiment(thisExp, inputs=inputs, win=win)
    # resume any playback components
    for comp in playbackComponents:
        comp.play()
    # restore auto-drawn components
    win.retrieveAutoDraw()
    # reset any timers
    for timer in timers:
        timer.reset()


def run(expInfo, thisExp, win, inputs, globalClock=None, thisSession=None):
    """
    Run the experiment flow.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    psychopy.visual.Window
        Window in which to run this experiment.
    inputs : dict
        Dictionary of input devices by name.
    globalClock : psychopy.core.clock.Clock or None
        Clock to get global time from - supply None to make a new one.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    # mark experiment as started
    thisExp.status = STARTED
    # make sure variables created by exec are available globally
    exec = environmenttools.setExecEnvironment(globals())
    # get device handles from dict of input devices
    ioServer = inputs['ioServer']
    defaultKeyboard = inputs['defaultKeyboard']
    eyetracker = inputs['eyetracker']
    # make sure we're running in the directory for this experiment
    os.chdir(_thisDir)
    # get filename from ExperimentHandler for convenience
    filename = thisExp.dataFileName
    frameTolerance = 0.001  # how close to onset before 'same' frame
    endExpNow = False  # flag for 'escape' or other condition => quit the exp
    # get frame duration from frame rate in expInfo
    if 'frameRate' in expInfo and expInfo['frameRate'] is not None:
        frameDur = 1.0 / round(expInfo['frameRate'])
    else:
        frameDur = 1.0 / 60.0  # could not measure, so guess
    
    # Start Code - component code to be run after the window creation
    
    # --- Initialize components for Routine "idm_consent1" ---
    idm_consent1_welcome_txt = visual.TextStim(win=win, name='idm_consent1_welcome_txt',
        text='Welcome to the Introspection and Decision Making Study ',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent1_info_txt = visual.TextStim(win=win, name='idm_consent1_info_txt',
        text='The Introspection and Decision Making research study is intended for the scientific purpose of furthering our understanding of how people make decisions and their confidence regarding those choices. \n\nThe following consent information describes the study and is intended to help inform your choice to participate. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent1_space_txt = visual.TextStim(win=win, name='idm_consent1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    idm_consent1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent2" ---
    idm_consent2_title_txt = visual.TextStim(win=win, name='idm_consent2_title_txt',
        text='Information on this Research',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent2_info_txt = visual.TextStim(win=win, name='idm_consent2_info_txt',
        text='The Introspection and Decision Making (IDM) study is conducted by the Computational Decision Neuroscience laboratory (CDN; Principal Investigator Dr. Silvia Lopez-Guzman) at the National Institute of Mental Health.  \n\nParticipation in the IDM study is entirely voluntary. You are not required to participate and refusal to do so will in no way affect access to any services or benefits. \n\nIf you choose to participate, you may quit at any time without penalty.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent2_space_txt = visual.TextStim(win=win, name='idm_consent2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent3" ---
    idm_consent3_title_txt = visual.TextStim(win=win, name='idm_consent3_title_txt',
        text='Why are we conducting this study?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent3_info_txt = visual.TextStim(win=win, name='idm_consent3_info_txt',
        text='Decision making is a complex process in which individuals evaluate and select between different options and/or courses of action. Understanding these principles and how our brain supports decision making is important not only for learning about healthy cognition and behavior, but also informs treatment to help those with certain mental health conditions. \n\nHere, we are investigating the relationship between decision making and value-based judgments. Additionally, we are interested in how people reflect upon, and the degree to which they are confident in, these choices.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent3_space_txt = visual.TextStim(win=win, name='idm_consent3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent4" ---
    idm_consent4_title_txt = visual.TextStim(win=win, name='idm_consent4_title_txt',
        text='What will I be asked to do and how long will it take?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent4_info_txt = visual.TextStim(win=win, name='idm_consent4_info_txt',
        text='In total, your participation is expected to take approximately 1 hours and 15 minutes: 2-3 minutes to complete 2 surveys, and 70 minutes to complete 3 computer-based tasks. \n\nThe first survey includes questions about demographic information, mental health history, and past/present substance use. The second survey assesses your ability to detect and recognize certain internal body states (e.g., hunger, thirst). ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent4_space_txt = visual.TextStim(win=win, name='idm_consent4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent5" ---
    idm_consent5_title_txt = visual.TextStim(win=win, name='idm_consent5_title_txt',
        text='What will I be asked to do and how long will it take?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent5_info_txt = visual.TextStim(win=win, name='idm_consent5_info_txt',
        text='The 3 computer-based tasks include:\n\n1. Visual Decision Making Task (~38 minutes). Make judgments about the tilt of an oriented pattern and your confidence about your decision.\n\n2. Risk & Ambiguity Task (~14 minutes). Choose between (1) receiving a certain smaller amount of money, or (2) playing a lottery for the chance to win a larger amount. Then rate how confidently you feel your choice truly reflects your preference.\n\n3. Delay Discounting Task (~18 minutes). Choose between (1) a smaller amount of money received today, or (2) a larger amount of money received in the future. Then rate how confidently you feel your choice truly reflects your preference.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent5_space_txt = visual.TextStim(win=win, name='idm_consent5_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent5_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent6" ---
    idm_consent6_title_txt = visual.TextStim(win=win, name='idm_consent6_title_txt',
        text='What are the benefits and risks of participating in the study?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent6_info_txt = visual.TextStim(win=win, name='idm_consent6_info_txt',
        text='There are no direct benefits from participating in this research study. In addition, this study involves minimal risk to participants. However, the potential loss or compromise of confidentiality is a risk for all research in which data is collected from human participants. Loss or compromise of confidentiality involves the unauthorized access and/or use of participant data.\n\nTo minimize risk of data loss or compromise of confidentiality, Amazon Mechanical Turk (MTurk) will not collect any experimental data and CDN researchers will not have access to any personal identifiable information MTurk collects for the creation of your account. All tasks and questionnaires will be conducted on Pavlovia, a secure website separate from MTurk. Data you provide on Pavlovia will only be linked to your worker ID temporarily to ensure credit/compensation. Once data collection is complete, information linking your MTurk worker ID to data collected through Pavlovia will be destroyed. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent6_space_txt = visual.TextStim(win=win, name='idm_consent6_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent6_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent7" ---
    idm_consent7_title_txt = visual.TextStim(win=win, name='idm_consent7_title_txt',
        text='Will I receive compensation for participating in this research study?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent7_info_txt = visual.TextStim(win=win, name='idm_consent7_info_txt',
        text='Your participation and earnest performance completing the two surveys and three computer-based tasks will entitle you to a fixed, standard compensation.\n\nIn addition, you may also receive a variable bonus. A single trial will be randomly-selected from one of three computer-based tasks. You will receive the monetary value associated with your specific choice on that trial, as per task instructions. The variable bonus encourages you to make each choice based on your true preference, as any trial has the chance to be made real with actual money. \n\n**IMPORTANT**\n\n1. Missing too many trials or responding in a manner that indicates you are not engaged with the task or do not understand instructions will result in the experiment terminating prematurely. You will not be compensated if the experiment is terminated for these reasons.\n\n2. You can only be paid for completing this study once. If you complete the IDM study a second time, you will not receive additional compensation.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent7_space_txt = visual.TextStim(win=win, name='idm_consent7_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent7_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent8" ---
    idm_consent8_title_txt = visual.TextStim(win=win, name='idm_consent8_title_txt',
        text='Who can I talk to if I have questions?',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent8_info_txt = visual.TextStim(win=win, name='idm_consent8_info_txt',
        text='If you have any questions or concerns regarding participation, contact the principal investigator:\n\nDr. Silvia Lopez-Guzman \nNIMHCDN@mail.nih.gov',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent8_space_txt = visual.TextStim(win=win, name='idm_consent8_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_consent8_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_consent9" ---
    idm_consent9_title_txt = visual.TextStim(win=win, name='idm_consent9_title_txt',
        text='Consent to Participate',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_consent9_info_txt = visual.TextStim(win=win, name='idm_consent9_info_txt',
        text='If, after reading and understanding this consent information, you...\n\n\n\n*AGREE TO PARTICIPATE* \nPress the SPACE button on your keyboard to continue the IDM study. \nBy doing so, you indicate you (1) are at least 18 years old, (2) have read and understand the provided consent information, and (3) agree to participate in the IDM study. \n\n\n\n*DO NOT AGREE TO PARTICIPATE* \nPress the "ESC" button on your keyboard twice to exit the IDM study.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_consent9_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_thanks" ---
    idm_thanks_title_txt = visual.TextStim(win=win, name='idm_thanks_title_txt',
        text='* Introspection and Decision Making Study *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_thanks_txt = visual.TextStim(win=win, name='idm_thanks_txt',
        text='Thank you for your decision to participate in the IDM study.\n',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_thanks_space_txt = visual.TextStim(win=win, name='idm_thanks_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_thanks_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_warn1" ---
    idm_warn1_title_txt = visual.TextStim(win=win, name='idm_warn1_title_txt',
        text='*Warning*',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=None, ori=0.0, 
        color=[0.8824, 0.0039, 0.0039], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_warn1_txt = visual.TextStim(win=win, name='idm_warn1_txt',
        text='Please note if you do not respond to at least 95% of task trials, or provide responses which indicate you are not following task instructions, the EXPERIMENT WILL END and you will not receive any form of bonus payment.\n \nIf you do not wish to continue, you may quit at any time by pressing the ESC button twice.\n\nYour ability to follow task instructions will be assessed at each stage of the experiment. Please pay attention to all instructions. Read each screen carefully to ensure you understand what to do. Practice trials are provided to teach you how each task is performed. \n\nPlease do your best and remain engaged throughout the entire experiment.  ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_warn1_space_txt = visual.TextStim(win=win, name='idm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_surv1_intro" ---
    idm_surv1_intro_title_txt = visual.TextStim(win=win, name='idm_surv1_intro_title_txt',
        text='* Demographics Survey *',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_surv1_intro_txt = visual.TextStim(win=win, name='idm_surv1_intro_txt',
        text='The following survey contains 11 multiple choice questions and should take less than 5 minutes to complete.\n\nPlease use the number keys at the top of your keyboard to indicate your response. \n\nThe number associated with each response is displayed to the left.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_surv1_intro_space_txt = visual.TextStim(win=win, name='idm_surv1_intro_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_surv1_intro_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_surv1" ---
    idm_surv1_question_txt = visual.TextStim(win=win, name='idm_surv1_question_txt',
        text='',
        font='Arial',
        pos=(-0.4, 0.0), height=0.04, wrapWidth=0.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_surv1_1 = visual.Rect(
        win=win, name='idm_surv1_1',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, 0.35), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    idm_surv1_1_txt = visual.TextStim(win=win, name='idm_surv1_1_txt',
        text='',
        font='Arial',
        pos=(0.3, 0.35), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    idm_surv1_2 = visual.Rect(
        win=win, name='idm_surv1_2',
        width=(0.6, 0.10)[0], height=(0.6, 0.10)[1],
        ori=0.0, pos=(0.3, 0.2), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-4.0, interpolate=True)
    idm_surv1_2_txt = visual.TextStim(win=win, name='idm_surv1_2_txt',
        text='',
        font='Arial',
        pos=(0.3, 0.2), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    idm_surv1_3 = visual.Rect(
        win=win, name='idm_surv1_3',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, 0.05), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-6.0, interpolate=True)
    idm_surv1_3_txt = visual.TextStim(win=win, name='idm_surv1_3_txt',
        text='',
        font='Arial',
        pos=(0.3, 0.05), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    idm_surv1_4 = visual.Rect(
        win=win, name='idm_surv1_4',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, -0.1), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-8.0, interpolate=True)
    idm_surv1_4_txt = visual.TextStim(win=win, name='idm_surv1_4_txt',
        text='',
        font='Arial',
        pos=(0.3, -0.1), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    idm_surv1_5 = visual.Rect(
        win=win, name='idm_surv1_5',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, -0.25), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-10.0, interpolate=True)
    idm_surv1_5_txt = visual.TextStim(win=win, name='idm_surv1_5_txt',
        text='',
        font='Arial',
        pos=(0.3, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    idm_surv1_6 = visual.Rect(
        win=win, name='idm_surv1_6',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, -0.4), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-12.0, interpolate=True)
    idm_surv1_6_txt = visual.TextStim(win=win, name='idm_surv1_6_txt',
        text='',
        font='Arial',
        pos=(0.3, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-13.0);
    idm_surv1_key1 = visual.TextStim(win=win, name='idm_surv1_key1',
        text='1',
        font='Arial',
        pos=(0.05, 0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-14.0);
    idm_surv1_key2 = visual.TextStim(win=win, name='idm_surv1_key2',
        text='2',
        font='Arial',
        pos=(0.05, 0.2), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-15.0);
    idm_surv1_key3 = visual.TextStim(win=win, name='idm_surv1_key3',
        text='3',
        font='Arial',
        pos=(0.05, 0.05), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-16.0);
    idm_surv1_key4 = visual.TextStim(win=win, name='idm_surv1_key4',
        text='4',
        font='Arial',
        pos=(0.05, -0.1), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-17.0);
    idm_surv1_key5 = visual.TextStim(win=win, name='idm_surv1_key5',
        text='5',
        font='Arial',
        pos=(0.05, -0.25), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-18.0);
    idm_surv1_key6 = visual.TextStim(win=win, name='idm_surv1_key6',
        text='6',
        font='Arial',
        pos=(0.05, -0.4), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-19.0);
    idm_surv1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_surv2_intro" ---
    idm_surv2_intro_title_txt = visual.TextStim(win=win, name='idm_surv2_intro_title_txt',
        text='* Interoceptive Accuracy Scale *',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_surv2_intro_txt = visual.TextStim(win=win, name='idm_surv2_intro_txt',
        text='The following survey consists of 21 five-point scale questions about your ability to perceive internal physiological states and should take less than 5 minutes to complete.\n\nPlease use the number keys at the top of your keyboard to indicate your response. \n\nThe number associated with each response is displayed to the left.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_surv2_intro_space_txt = visual.TextStim(win=win, name='idm_surv2_intro_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_surv2_intro_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_surv2" ---
    idm_surv2_stim_txt = visual.TextStim(win=win, name='idm_surv2_stim_txt',
        text='I can always accurately \nperceive when',
        font='Arial',
        pos=(-0.4, 0.1), height=0.05, wrapWidth=1.0, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_surv2_question_txt = visual.TextStim(win=win, name='idm_surv2_question_txt',
        text='',
        font='Arial',
        pos=(-0.4, -0.05), height=0.05, wrapWidth=0.7, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_surv2_1 = visual.Rect(
        win=win, name='idm_surv2_1',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, 0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-3.0, interpolate=True)
    idm_surv2_1_txt = visual.TextStim(win=win, name='idm_surv2_1_txt',
        text='Strongly Agree',
        font='Arial',
        pos=(0.3, 0.3), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    idm_surv2_2 = visual.Rect(
        win=win, name='idm_surv2_2',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, 0.15), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    idm_surv2_2_txt = visual.TextStim(win=win, name='idm_surv2_2_txt',
        text='Agree',
        font='Arial',
        pos=(0.3, 0.15), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    idm_surv2_3 = visual.Rect(
        win=win, name='idm_surv2_3',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-7.0, interpolate=True)
    idm_surv2_3_txt = visual.TextStim(win=win, name='idm_surv2_3_txt',
        text='Neither Agree or Disagree',
        font='Arial',
        pos=(0.3, 0), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    idm_surv2_4 = visual.Rect(
        win=win, name='idm_surv2_4',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, -0.15), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-9.0, interpolate=True)
    idm_surv2_4_txt = visual.TextStim(win=win, name='idm_surv2_4_txt',
        text='Disagree',
        font='Arial',
        pos=(0.3, -0.15), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    idm_surv2_5 = visual.Rect(
        win=win, name='idm_surv2_5',
        width=(0.6, 0.1)[0], height=(0.6, 0.1)[1],
        ori=0.0, pos=(0.3, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-11.0, interpolate=True)
    idm_surv2_5_txt = visual.TextStim(win=win, name='idm_surv2_5_txt',
        text='Strongly Disagree',
        font='Arial',
        pos=(0.3, -0.3), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-12.0);
    idm_surv2_key1 = visual.TextStim(win=win, name='idm_surv2_key1',
        text='1',
        font='Arial',
        pos=(0.05, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-13.0);
    idm_surv2_key2 = visual.TextStim(win=win, name='idm_surv2_key2',
        text='2',
        font='Arial',
        pos=(0.05, 0.15), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-14.0);
    idm_surv2_key3 = visual.TextStim(win=win, name='idm_surv2_key3',
        text='3',
        font='Arial',
        pos=(0.05, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-15.0);
    idm_surv2_key4 = visual.TextStim(win=win, name='idm_surv2_key4',
        text='4',
        font='Arial',
        pos=(0.05, -0.15), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-16.0);
    idm_surv2_key5 = visual.TextStim(win=win, name='idm_surv2_key5',
        text='5',
        font='Arial',
        pos=(0.05, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-17.0);
    idm_surv2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_instr1" ---
    idm_instr1_title_txt = visual.TextStim(win=win, name='idm_instr1_title_txt',
        text='* Introspection and Decision Making Study *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_instr1_txt = visual.TextStim(win=win, name='idm_instr1_txt',
        text='The computer-based decision making tasks will now begin. These tasks will be presented in random order. Opportunities will be provided for you to take breaks. Importantly, the IDM study must be completed in a single session. Do not close your browser until after you have received your *IDM Task Completion Code*\n\nAt the end of the experiment, a single trial will be randomly-selected from one of the computer-based tasks. This trial is your "bonus earnings trial" and will determine the amount of your variable bonus. How much money you receive will depend on the choice you made on that specific trial, as per task instructions.\n \nIn other words, each decision you make has a chance of actually happening! So make sure every choice *truly* reflects your preference.  \n\n',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_instr1_space_txt = visual.TextStim(win=win, name='idm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_instr2" ---
    idm_instr2_title_txt = visual.TextStim(win=win, name='idm_instr2_title_txt',
        text='* Introspection and Decision Making Study *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.5, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_instr2_cursor_txt = visual.TextStim(win=win, name='idm_instr2_cursor_txt',
        text='During this experiment, all responses will be made using your keyboard.\n\nBefore you begin, please take this moment to move your mouse cursor to the edge of the screen. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_instr2_space_txt = visual.TextStim(win=win, name='idm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_warn2" ---
    idm_warn2_title_txt = visual.TextStim(win=win, name='idm_warn2_title_txt',
        text='*Reminder*',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=None, ori=0.0, 
        color=[0.8824, 0.0039, 0.0039], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    idm_warn2_warning_txt = visual.TextStim(win=win, name='idm_warn2_warning_txt',
        text='Please remember if you respond to fewer than 95% of trials, or provide responses which indicate you are not following task instructions, the EXPERIMENT WILL END and you will not receive any form of payment or bonus. \n\nIf you do not wish to continue, you can end the task at any time by pressing the ESC button twice.\n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Remember, your choices could help you walk away with an additional bonus ranging from $2 to $65, depending on the seleced *bonus earnings trial*!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_warn2_space_txt = visual.TextStim(win=win, name='idm_warn2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_warn2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_namer1" ---
    
    # --- Initialize components for Routine "cpdm_instr1" ---
    cpdm_instr1_img = visual.ImageStim(
        win=win,
        name='cpdm_instr1_img', 
        image='cpdm/cpdm_keys.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.06), size=(0.65, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    cpdm_instr1_title_txt = visual.TextStim(win=win, name='cpdm_instr1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr1_txt = visual.TextStim(win=win, name='cpdm_instr1_txt',
        text='You will be presented with a series of oriented patterns across multiple trials. Your job is to decide if the pattern is tilting to the left or right. In your response, you will also indicate how confident you are in your decision. \nThere are four possible response combinations:\n\n\n\n\n\n\n\n\n\n\nFor each trial, you will have 2 seconds to respond. \n\n',
        font='Arial',
        pos=(0, -0.05), height=0.0325, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr1_Q_txt = visual.TextStim(win=win, name='cpdm_instr1_Q_txt',
        text='Press Q for LEFT tilt and HIGH confidence\n',
        font='Arial',
        pos=(-0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_instr1_P_txt = visual.TextStim(win=win, name='cpdm_instr1_P_txt',
        text='Press P for RIGHT tilt and HIGH confidence\n',
        font='Arial',
        pos=(0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr1_A_txt = visual.TextStim(win=win, name='cpdm_instr1_A_txt',
        text='Press A for LEFT tilt and LOW confidence\n',
        font='Arial',
        pos=(-0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cpdm_instr1_L_txt = visual.TextStim(win=win, name='cpdm_instr1_L_txt',
        text='Press L for RIGHT tilt and LOW confidence\n',
        font='Arial',
        pos=(0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_instr1_space_txt = visual.TextStim(win=win, name='cpdm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr2" ---
    cpdm_instr2_title_txt = visual.TextStim(win=win, name='cpdm_instr2_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr2_instr_txt = visual.TextStim(win=win, name='cpdm_instr2_instr_txt',
        text='You can tell "tilt" by which direction the top of the pattern is pointing:',
        font='Arial',
        pos=(0, 0.2), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr2_left_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_left_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cpdm_instr2_left_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_left_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=-5.0, pos=(-0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-3.0)
    cpdm_instr2_left_txt = visual.TextStim(win=win, name='cpdm_instr2_left_txt',
        text='This pattern tilts LEFT',
        font='Arial',
        pos=(-0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr2_right_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_right_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=True, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    cpdm_instr2_right_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_right_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=5.0, pos=(0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-6.0)
    cpdm_instr2_right_txt = visual.TextStim(win=win, name='cpdm_instr2_right_txt',
        text='This pattern tilts RIGHT',
        font='Arial',
        pos=(0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr2_space_txt = visual.TextStim(win=win, name='cpdm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr3" ---
    cpdm_instr3_title_txt = visual.TextStim(win=win, name='cpdm_instr3_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr3_txt = visual.TextStim(win=win, name='cpdm_instr3_txt',
        text='There are four (4) blocks of 200 trials. \n\nYour choice for each trial will determine how much money you could earn if that trial is randomly selected as your *bonus earnings* trial. The monetary values for each of the four responses may change from block to block. These values will be provided before each block, so pay careful attention.  ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr3_space_txt = visual.TextStim(win=win, name='cpdm_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr4" ---
    cpdm_instr4_title_txt = visual.TextStim(win=win, name='cpdm_instr4_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr4_txt = visual.TextStim(win=win, name='cpdm_instr4_txt',
        text='As you provide your responses, please note some pattern tilts will be harder to determine than others. On these trials, you may be less confident than on trials where the tilt is more obvious.\n\nPlease remember to distiguish between trials in which you feel high and low confidence regarding the tilt of the pattern.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr4_space_txt = visual.TextStim(win=win, name='cpdm_instr4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_warn" ---
    cpdm_warn1_title_txt = visual.TextStim(win=win, name='cpdm_warn1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_warn1_txt = visual.TextStim(win=win, name='cpdm_warn1_txt',
        text='IMPORTANT: The experiment will end if you (1) miss more than 5% of trials per block, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_warn1_space_txt = visual.TextStim(win=win, name='cpdm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_instr" ---
    cpdm_pract_instr_title_txt = visual.TextStim(win=win, name='cpdm_pract_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_pract_instr_txt = visual.TextStim(win=win, name='cpdm_pract_instr_txt',
        text="Let's practice!\n\nIn these example trials, the box you select will turn green if you make the correct choice regarding tilt of the pattern. If you are incorrect, the box you select will turn red. Feedback about performance during the practice trials is to help you understand the task, but will not be given during the actual experiment. ",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_pract_instr_space_txt = visual.TextStim(win=win, name='cpdm_pract_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_pract_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_pract_trial" ---
    # Run 'Begin Experiment' code from cpdm_pract_trial_code
    #set default gray for all four response boxes
    left_high_color = [0,0,0] 
    left_low_color = [0,0,0]
    right_high_color = [0,0,0]
    right_low_color = [0,0,0]
    cpdm_pract_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_pract_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_pract_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_pract_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_pract_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_pract_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_pract_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_high_txt',
        text='LEFT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_pract_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_high_txt',
        text='RIGHT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_pract_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_pract_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_pract_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_iti1" ---
    cpdm_pract_iti1_poly = visual.ShapeStim(
        win=win, name='cpdm_pract_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial_instr" ---
    cpdm_trial_instr_title_txt = visual.TextStim(win=win, name='cpdm_trial_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_trial_instr_txt = visual.TextStim(win=win, name='cpdm_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nIn the following four sections, you will be presented with a series of trials similar to those you just practiced. Here, you will not receive feedback about your performance. The option you select will turn light gray to indicate your choice. For each trial, you have 2 seconds to make your decision.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_trial_instr_space_txt = visual.TextStim(win=win, name='cpdm_trial_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_run_setter" ---
    
    # --- Initialize components for Routine "cpdm_loop_instr" ---
    # Run 'Begin Experiment' code from cpdm_loop_instr_code
    loop_spec_instr = ""
    run_counter = 1
    cpdm_loop_instr_code2 = visual.TextStim(win=win, name='cpdm_loop_instr_code2',
        text='',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_loop_instr_corr_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_corr_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_loop_instr_right_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_loop_instr_left_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_left_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_loop_instr_right_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_loop_instr_corr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_high_txt',
        text='',
        font='Arial',
        pos=(-0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_loop_instr_incorr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_high_txt',
        text='Incorrect\nHigh Confidence\n$0',
        font='Arial',
        pos=(0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_loop_instr_corr_low_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_low_txt',
        text='Correct\nLow Confidence\n$8',
        font='Arial',
        pos=(-0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='darkseagreen', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_loop_instr_incorr_low = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_low',
        text='Incorrect\nLow Confidence\n$6',
        font='Arial',
        pos=(0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_loop_instr_space_txt = visual.TextStim(win=win, name='cpdm_loop_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    cpdm_loop_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial" ---
    # Run 'Begin Experiment' code from cpdm_trial_code
    cpdm_trial_counter = 1
    cpdm_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_trial_left_high_txt',
        text='',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_trial_right_high_txt',
        text='',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_trial_iti1" ---
    cpdm_trials_iti1_poly = visual.ShapeStim(
        win=win, name='cpdm_trials_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_run_break1" ---
    # Run 'Begin Experiment' code from cpdm_run_break1_code
    cpdm_run_break_text = ""
    cpdm_space_text = ""
    cpdm_run_break1_title_txt = visual.TextStim(win=win, name='cpdm_run_break1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_run_break1_txt = visual.TextStim(win=win, name='cpdm_run_break1_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_run_break1_space_txt = visual.TextStim(win=win, name='cpdm_run_break1_space_txt',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_run_break1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "crdm_namer1" ---
    
    # --- Initialize components for Routine "crdm_instr1" ---
    crdm_instr1_title_txt = visual.TextStim(win=win, name='crdm_instr1_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr1_txt = visual.TextStim(win=win, name='crdm_instr1_txt',
        text='In this decision making task, you will be asked to make economic choices between: \n\n- Receiving a certain, smaller amount of money \nOR\n- Playing a lottery for the chance to win a larger amount of money \n\nYour choice for each trial will determine how much money you could earn if randomly selected as your bonus earnings trial. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr1_space_txt = visual.TextStim(win=win, name='crdm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr2" ---
    crdm_instr2_lottname_txt = visual.TextStim(win=win, name='crdm_instr2_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr2_txt = visual.TextStim(win=win, name='crdm_instr2_txt',
        text='The lottery consists of an imaginary bag containing 100 poker chips, some red and some blue. To play, you pull a random chip from the bag.  \n\nThe figure on the left represents the proportion of blue and red chips in the imaginary bag. \n\nHere, most chips are blue (75 of 100) and fewer are red (25 of 100).',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr2_img = visual.ImageStim(
        win=win,
        name='crdm_instr2_img', units='height', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr2_lott0_txt = visual.TextStim(win=win, name='crdm_instr2_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr2_lott20_txt = visual.TextStim(win=win, name='crdm_instr2_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr2_space_txt = visual.TextStim(win=win, name='crdm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr3" ---
    crdm_instr3_lottname_txt = visual.TextStim(win=win, name='crdm_instr3_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr3_txt = visual.TextStim(win=win, name='crdm_instr3_txt',
        text='Given information about the number of blue and red chips in the bag, you can decide whether you would prefer a certain monetary outcome or if you would rather play the lottery for a chance to win a different amount.\n\nIn this example, you have a 75% chance of pulling a blue chip and winning $20. Conversely, you have a 25% chance of pulling a red chip and receiving $0.\n\nThe value for each color will change from bag to bag. Read the $ amounts above the red and below the blue to know the value of each chip color.',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=1.0, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr3_img = visual.ImageStim(
        win=win,
        name='crdm_instr3_img', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr3_lott0_txt = visual.TextStim(win=win, name='crdm_instr3_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr3_lott20_txt = visual.TextStim(win=win, name='crdm_instr3_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr3_space_txt = visual.TextStim(win=win, name='crdm_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr4" ---
    crdm_instr4_lottname_txt = visual.TextStim(win=win, name='crdm_instr4_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr4_txt = visual.TextStim(win=win, name='crdm_instr4_txt',
        text='For some lotteries, information about the bag contents may be partially hidden. \n\nIn this example, at least 25 chips are blue and 25 chips are red. However, the color of the remaining 50 chips is unknown. The remaining 50 could be all red, all blue, or a combination of the two. ',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr4_img = visual.ImageStim(
        win=win,
        name='crdm_instr4_img', 
        image='crdm/ambig_50.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr4_lott0_txt = visual.TextStim(win=win, name='crdm_instr4_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr4_lott20_txt = visual.TextStim(win=win, name='crdm_instr4_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr4_space_txt = visual.TextStim(win=win, name='crdm_instr4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr5" ---
    crdm_instr5_txt = visual.TextStim(win=win, name='crdm_instr5_txt',
        text='The lottery bag will appear at the center of the screen. The certain dollar amount will be presented on either the right or left side of the bag. Here, a certain $5 would be the left option, and lottery would be the right option:',
        font='Arial',
        pos=(0, 0.35), height=0.03, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr5_img = visual.ImageStim(
        win=win,
        name='crdm_instr5_img', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_instr5_lott_top_txt = visual.TextStim(win=win, name='crdm_instr5_lott_top_txt',
        text='$0',
        font='Arial',
        pos=(0, 0.25), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_instr5_lott_bot_txt = visual.TextStim(win=win, name='crdm_instr5_lott_bot_txt',
        text='$20',
        font='Arial',
        pos=(0, -0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr5_sure_txt = visual.TextStim(win=win, name='crdm_instr5_sure_txt',
        text='$5',
        font='Arial',
        pos=(-0.5, -0.05), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr5_space_txt = visual.TextStim(win=win, name='crdm_instr5_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr5_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr6" ---
    crdm_instr6_title_txt = visual.TextStim(win=win, name='crdm_instr6_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr6_txt = visual.TextStim(win=win, name='crdm_instr6_txt',
        text='When the green circle appears, use the number keys at the top of your keyboard to indicate your choice:\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr6_img = visual.ImageStim(
        win=win,
        name='crdm_instr6_img', 
        image='crdm/crdm_2key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.1), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr6_space_txt = visual.TextStim(win=win, name='crdm_instr6_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr6_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr7" ---
    crdm_instr7_title_txt = visual.TextStim(win=win, name='crdm_instr7_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr7_txt = visual.TextStim(win=win, name='crdm_instr7_txt',
        text="After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr7_img = visual.ImageStim(
        win=win,
        name='crdm_instr7_img', 
        image='crdm/crdm_4key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.15), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr7_space_txt = visual.TextStim(win=win, name='crdm_instr7_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr7_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_warn" ---
    crdm_warn1_title_txt = visual.TextStim(win=win, name='crdm_warn1_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_warn1_txt = visual.TextStim(win=win, name='crdm_warn1_txt',
        text='IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_warn1_space_txt = visual.TextStim(win=win, name='crdm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract1_instr" ---
    crdm_pract1_instr_name_txt = visual.TextStim(win=win, name='crdm_pract1_instr_name_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_pract1_instr_txt = visual.TextStim(win=win, name='crdm_pract1_instr_txt',
        text="In this first section, you will only be asked to indicate your choice between the certain outcome and the lottery. You will not be asked to rate your choice confidence.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. \n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract1_instr_space_txt = visual.TextStim(win=win, name='crdm_pract1_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract1_instr_key = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_pract1_trial" ---
    # Run 'Begin Experiment' code from crdm_pract1_trial_code
    #position of certain amount option
    crdm_sure_pos1 = [] 
    crdm_sure_resp1 = []
    crdm_crdm_msg1 = ""
    
    #stimuli positions and respective responses
    #left/right screen locations
    crdm_pos1 = [[-0.5, 0], [0.5, 0]] 
    crdm_resp1 = ["1", "2"] #1 = left, 2 = right
    crdm_pract1_trial_img = visual.ImageStim(
        win=win,
        name='crdm_pract1_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_pract1_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_pract1_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract1_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_pract1_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract1_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_pract1_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix4 = visual.Rect(
        win=win, name='GRFX_fix4',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_pract1_trial_cue = visual.ShapeStim(
        win=win, name='crdm_pract1_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract1_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract1_feedback" ---
    crdm_pract1_feedback_txt = visual.TextStim(win=win, name='crdm_pract1_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_qp_instr" ---
    crdm_qp_instr_title_txt = visual.TextStim(win=win, name='crdm_qp_instr_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_qp_instr_txt = visual.TextStim(win=win, name='crdm_qp_instr_txt',
        text="Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_qp_instr_space_txt = visual.TextStim(win=win, name='crdm_qp_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_qp_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_questplus" ---
    # Run 'Begin Experiment' code from crdm_questplus_JS
    #position of certain amount option
    sure_pos = [] 
    sure_resp = []
    crdm_msg = ""
    
    #stimuli positions and respective responses
    pos = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    resp = ["1", "2"] #1 = left, 2 = right
    crdm_questplus_img = visual.ImageStim(
        win=win,
        name='crdm_questplus_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_questplus_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_questplus_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_questplus_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_questplus_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_questplus_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_questplus_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix3 = visual.Rect(
        win=win, name='GRFX_fix3',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_questplus_trial_cue = visual.ShapeStim(
        win=win, name='crdm_questplus_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_questplus_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_qp_feedback" ---
    crdm_qp_feedback_txt = visual.TextStim(win=win, name='crdm_qp_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_schedule_gen" ---
    
    # --- Initialize components for Routine "crdm_pract2_instr" ---
    crdm_pract2_instr_name_txt = visual.TextStim(win=win, name='crdm_pract2_instr_name_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_pract2_instr_txt = visual.TextStim(win=win, name='crdm_pract2_instr_txt',
        text="In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract2_instr_space_txt = visual.TextStim(win=win, name='crdm_pract2_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract2_instr_key = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_pract2_trial" ---
    # Run 'Begin Experiment' code from crdm_pract2_trial_code
    #position of certain amount option
    crdm_sure_pos2 = [] 
    crdm_sure_resp2 = []
    crdm_crdm_msg2 = ""
    
    #stimuli positions and respective responses
    #left/right screen locations
    crdm_pos2 = [[-0.5, 0], [0.5, 0]] 
    crdm_resp2 = ["1", "2"] #1 = left, 2 = right
    crdm_pract2_trial_img = visual.ImageStim(
        win=win,
        name='crdm_pract2_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_pract2_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_pract2_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract2_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_pract2_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract2_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_pract2_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix2 = visual.Rect(
        win=win, name='GRFX_fix2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_pract2_trial_cue = visual.ShapeStim(
        win=win, name='crdm_pract2_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract2_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract2_feedback" ---
    crdm_pract2_feedback_txt = visual.TextStim(win=win, name='crdm_pract2_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_pract2_conf" ---
    crdm_pract2_conf_txt = visual.TextStim(win=win, name='crdm_pract2_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract2_conf1 = visual.Rect(
        win=win, name='crdm_pract2_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    crdm_pract2_conf1_txt = visual.TextStim(win=win, name='crdm_pract2_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract2_conf2 = visual.Rect(
        win=win, name='crdm_pract2_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    crdm_pract2_conf2_txt = visual.TextStim(win=win, name='crdm_pract2_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_pract2_conf3 = visual.Rect(
        win=win, name='crdm_pract2_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract2_conf3_txt = visual.TextStim(win=win, name='crdm_pract2_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    crdm_pract2_conf4 = visual.Rect(
        win=win, name='crdm_pract2_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    crdm_pract2_conf4_txt = visual.TextStim(win=win, name='crdm_pract2_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    crdm_pract2_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract2_iti1" ---
    crdm_pract2_iti1_poly = visual.ShapeStim(
        win=win, name='crdm_pract2_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_trial_instr" ---
    crdm_trial_instr_title_txt = visual.TextStim(win=win, name='crdm_trial_instr_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_trial_instr_txt = visual.TextStim(win=win, name='crdm_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nMake your choice between the certain outcome and lottery as soon as you see the green circle. You will have 3 seconds to consider and 2 seconds to respond. You will then have an additional 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_trial_instr_space_txt = visual.TextStim(win=win, name='crdm_trial_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_trial" ---
    crdm_trial_img = visual.ImageStim(
        win=win,
        name='crdm_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_trial_lott_top = visual.TextStim(win=win, name='crdm_trial_lott_top',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_trial_lott_bot = visual.TextStim(win=win, name='crdm_trial_lott_bot',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_trial_sure_amt = visual.TextStim(win=win, name='crdm_trial_sure_amt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix = visual.Rect(
        win=win, name='GRFX_fix',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_trial_cue = visual.ShapeStim(
        win=win, name='crdm_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_feedback" ---
    crdm_feedback_txt = visual.TextStim(win=win, name='crdm_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_conf" ---
    crdm_conf_txt = visual.TextStim(win=win, name='crdm_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_conf1 = visual.Rect(
        win=win, name='crdm_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    crdm_conf1_txt = visual.TextStim(win=win, name='crdm_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_conf2 = visual.Rect(
        win=win, name='crdm_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    crdm_conf2_txt = visual.TextStim(win=win, name='crdm_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_conf3 = visual.Rect(
        win=win, name='crdm_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    crdm_conf3_txt = visual.TextStim(win=win, name='crdm_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    crdm_conf4 = visual.Rect(
        win=win, name='crdm_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    crdm_conf4_txt = visual.TextStim(win=win, name='crdm_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    crdm_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_trials_iti1" ---
    crdm_trials_iti1_poly = visual.ShapeStim(
        win=win, name='crdm_trials_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_end" ---
    # Run 'Begin Experiment' code from crdm_end_code
    crdm_task_end_text = ""
    crdm_space_text = ""
    crdm_end_title_txt = visual.TextStim(win=win, name='crdm_end_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_end_txt_ON = visual.TextStim(win=win, name='crdm_end_txt_ON',
        text='',
        font='Arial',
        pos=(0, 0), height=0.05, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_end_space_ON = visual.TextStim(win=win, name='crdm_end_space_ON',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_end_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "cdd_namer1" ---
    
    # --- Initialize components for Routine "cdd_instr1" ---
    cdd_instr1_title_txt = visual.TextStim(win=win, name='cdd_instr1_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr1_txt = visual.TextStim(win=win, name='cdd_instr1_txt',
        text='In this decision making task, you will be asked indicate your preference between: \n\n- An amount of money you could receive today \nOR\n- An amount of money you could receive in the future \n\nThe value of each option and the length of delay will change across trials. One of your choices in this section may be randomly selected as your *bonus earnings trial* at the end of the experiment.\n\nExample: \n- If you chose $25 dollars immediately, you would receive $25 today.   \n- If you chose $50 in 15 days, you would receive $50 in 15 days. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr1_space_txt = visual.TextStim(win=win, name='cdd_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_instr2" ---
    cdd_instr2_title_txt = visual.TextStim(win=win, name='cdd_instr2_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr2_txt = visual.TextStim(win=win, name='cdd_instr2_txt',
        text='Please read each options carefully. The immediate and delayed choices may switch sides.\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n\n\nWhen the green circle appears, you will have 2 seconds to choose.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr2_img = visual.ImageStim(
        win=win,
        name='cdd_instr2_img', 
        image='cdd/cdd_2key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cdd_instr2_space_txt = visual.TextStim(win=win, name='cdd_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_instr3" ---
    cdd_instr3_title_txt = visual.TextStim(win=win, name='cdd_instr3_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr3_txt = visual.TextStim(win=win, name='cdd_instr3_txt',
        text="After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr3_img = visual.ImageStim(
        win=win,
        name='cdd_instr3_img', 
        image='cdd/cdd_4key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.15), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cdd_instr3_space_txt = visual.TextStim(win=win, name='cdd_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_warn" ---
    cdd_warn1_title_txt = visual.TextStim(win=win, name='cdd_warn1_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_warn1_txt = visual.TextStim(win=win, name='cdd_warn1_txt',
        text='IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_warn1_space_txt = visual.TextStim(win=win, name='cdd_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract1_instr" ---
    cdd_pract1_instr_left_poly = visual.Rect(
        win=win, name='cdd_pract1_instr_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0, 0, 0],
        opacity=None, depth=0.0, interpolate=True)
    cdd_pract1_instr_right_poly = visual.Rect(
        win=win, name='cdd_pract1_instr_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0, 0, 0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract1_instr_txt = visual.TextStim(win=win, name='cdd_pract1_instr_txt',
        text="*EXAMPLE TRIAL*\n\nWhich would you prefer?\n\n\n\n\n\n\n\n\nLet's practice!",
        font='Arial',
        pos=(0, 0.05), height=0.05, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_pract1_instr_immed_txt = visual.TextStim(win=win, name='cdd_pract1_instr_immed_txt',
        text='$10\n\nTODAY',
        font='Arial',
        pos=(0.5, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract1_instr_delay_txt = visual.TextStim(win=win, name='cdd_pract1_instr_delay_txt',
        text='$50 \n\n9 DAYS',
        font='Arial',
        pos=(-0.5, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract1_instr_or_txt = visual.TextStim(win=win, name='cdd_pract1_instr_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract1_instr_space_txt = visual.TextStim(win=win, name='cdd_pract1_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_pract1_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_pract1_trial" ---
    # Run 'Begin Experiment' code from cdd_pract1_trial_code
    cdd_immed_pos1 = [] #position of immediate amt option
    cdd_immed_resp1 = [] #which key is immediate amt option
    cdd_msg1 = ""
    
    #stimuli positions and respective responses
    cdd_pos1 = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    cdd_resp1 = ["1", "2"] #1 = left, 2 = right
    cdd_pract1_trial_left_poly = visual.Rect(
        win=win, name='cdd_pract1_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract1_trial_right_poly = visual.Rect(
        win=win, name='cdd_pract1_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract1_trial_prompt_txt = visual.TextStim(win=win, name='cdd_pract1_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract1_trial_immed_txt = visual.TextStim(win=win, name='cdd_pract1_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract1_trial_or_txt = visual.TextStim(win=win, name='cdd_pract1_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract1_trial_delay_txt = visual.TextStim(win=win, name='cdd_pract1_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_pract1_trial_cue = visual.ShapeStim(
        win=win, name='cdd_pract1_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_pract1_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract1_feedback" ---
    cdd_pract1_feedback_txt = visual.TextStim(win=win, name='cdd_pract1_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_qp_instr" ---
    cdd_qp_instr_title_txt = visual.TextStim(win=win, name='cdd_qp_instr_title_txt',
        text='* Delayed Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_qp_instr_txt = visual.TextStim(win=win, name='cdd_qp_instr_txt',
        text="Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_qp_instr_space_txt = visual.TextStim(win=win, name='cdd_qp_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_qp_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_questplus" ---
    cdd_questplus_trial_left_poly = visual.Rect(
        win=win, name='cdd_questplus_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_questplus_trial_right_poly = visual.Rect(
        win=win, name='cdd_questplus_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_questplus_trial_prompt_txt = visual.TextStim(win=win, name='cdd_questplus_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_questplus_trial_immed_txt = visual.TextStim(win=win, name='cdd_questplus_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_questplus_trial_or_txt = visual.TextStim(win=win, name='cdd_questplus_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_questplus_trial_delay_txt = visual.TextStim(win=win, name='cdd_questplus_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    GRFX_fix2_2 = visual.Rect(
        win=win, name='GRFX_fix2_2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_questplus_trial_cue = visual.ShapeStim(
        win=win, name='cdd_questplus_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-8.0, interpolate=True)
    cdd_questplus_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_questplus_fb" ---
    cdd_qp_fb_txt = visual.TextStim(win=win, name='cdd_qp_fb_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_schedule_gen" ---
    
    # --- Initialize components for Routine "cdd_pract2_instr" ---
    cdd_pract2_intr_name_txt = visual.TextStim(win=win, name='cdd_pract2_intr_name_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.3), height=0.03, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_pract2_instr_txt = visual.TextStim(win=win, name='cdd_pract2_instr_txt',
        text="In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_pract_instr_space_txt_2 = visual.TextStim(win=win, name='cdd_pract_instr_space_txt_2',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_pract_instr_resp_2 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_pract2_trial" ---
    # Run 'Begin Experiment' code from cdd_pract2_trial_code
    cdd_immed_pos2 = [] #position of immediate amt option
    cdd_immed_resp2 = [] #which key is immediate amt option
    cdd_msg2 = ""
    
    #stimuli positions and respective responses
    cdd_pos2 = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    cdd_resp2 = ["1", "2"] #1 = left, 2 = right
    cdd_pract2_trial_left_poly = visual.Rect(
        win=win, name='cdd_pract2_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract2_trial_right_poly = visual.Rect(
        win=win, name='cdd_pract2_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract2_trial_prompt_txt = visual.TextStim(win=win, name='cdd_pract2_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract2_trial_immed_txt = visual.TextStim(win=win, name='cdd_pract2_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract2_trial_or_txt = visual.TextStim(win=win, name='cdd_pract2_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract2_trial_delay_txt = visual.TextStim(win=win, name='cdd_pract2_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    GRFX_fix3_2 = visual.Rect(
        win=win, name='GRFX_fix3_2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_pract2_trial_cue = visual.ShapeStim(
        win=win, name='cdd_pract2_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-8.0, interpolate=True)
    cdd_pract2_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract2_feedback" ---
    cdd_pract2_fb_txt = visual.TextStim(win=win, name='cdd_pract2_fb_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_pract2_conf" ---
    cdd_pract2_conf_txt = visual.TextStim(win=win, name='cdd_pract2_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_pract2_conf1 = visual.Rect(
        win=win, name='cdd_pract2_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract2_conf1_txt = visual.TextStim(win=win, name='cdd_pract2_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract2_conf2 = visual.Rect(
        win=win, name='cdd_pract2_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cdd_pract2_conf2_txt = visual.TextStim(win=win, name='cdd_pract2_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract2_conf3 = visual.Rect(
        win=win, name='cdd_pract2_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    cdd_pract2_conf3_txt = visual.TextStim(win=win, name='cdd_pract2_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cdd_pract2_conf4 = visual.Rect(
        win=win, name='cdd_pract2_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    cdd_pract2_conf4_txt = visual.TextStim(win=win, name='cdd_pract2_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cdd_pract2_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract2_iti1" ---
    cdd_pract2_iti1_poly = visual.ShapeStim(
        win=win, name='cdd_pract2_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_trial_instr" ---
    cdd_trial_instr_title_txt = visual.TextStim(win=win, name='cdd_trial_instr_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_trial_instr_txt = visual.TextStim(win=win, name='cdd_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nRemember to make your choice between the immediate and delayed amounts when you see the green circle. You will have 3 seconds to consider both options and 2 seconds to make your choice. After each choice, you will be given 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_trial_instr_space_txt = visual.TextStim(win=win, name='cdd_trial_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_trial" ---
    cdd_trial_left_poly = visual.Rect(
        win=win, name='cdd_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_trial_right_poly = visual.Rect(
        win=win, name='cdd_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_trial_prompt_txt = visual.TextStim(win=win, name='cdd_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_trial_immed_txt = visual.TextStim(win=win, name='cdd_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_trial_or_txt = visual.TextStim(win=win, name='cdd_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_trial_delay_txt = visual.TextStim(win=win, name='cdd_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_trial_cue = visual.ShapeStim(
        win=win, name='cdd_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_feedback" ---
    cdd_feedback_txt = visual.TextStim(win=win, name='cdd_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_conf" ---
    cdd_conf_txt = visual.TextStim(win=win, name='cdd_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_conf1 = visual.Rect(
        win=win, name='cdd_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cdd_conf1_txt = visual.TextStim(win=win, name='cdd_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_conf2 = visual.Rect(
        win=win, name='cdd_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cdd_conf2_txt = visual.TextStim(win=win, name='cdd_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_conf3 = visual.Rect(
        win=win, name='cdd_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    cdd_conf3_txt = visual.TextStim(win=win, name='cdd_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cdd_conf4 = visual.Rect(
        win=win, name='cdd_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    cdd_conf4_txt = visual.TextStim(win=win, name='cdd_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cdd_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_trial_iti1" ---
    cdd_trial_iti1_poly = visual.ShapeStim(
        win=win, name='cdd_trial_iti1_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[1.0000, 1.0000, 1.0000], fillColor=[1.0000, 1.0000, 1.0000],
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_end" ---
    # Run 'Begin Experiment' code from cdd_end_code
    cdd_task_end_text = ""
    cdd_space_text = ""
    cdd_end_title_txt = visual.TextStim(win=win, name='cdd_end_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_end_txt_ON = visual.TextStim(win=win, name='cdd_end_txt_ON',
        text='',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_end_space_ON = visual.TextStim(win=win, name='cdd_end_space_ON',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_end_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "cpdm_namer2" ---
    
    # --- Initialize components for Routine "cpdm_instr1" ---
    cpdm_instr1_img = visual.ImageStim(
        win=win,
        name='cpdm_instr1_img', 
        image='cpdm/cpdm_keys.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.06), size=(0.65, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    cpdm_instr1_title_txt = visual.TextStim(win=win, name='cpdm_instr1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr1_txt = visual.TextStim(win=win, name='cpdm_instr1_txt',
        text='You will be presented with a series of oriented patterns across multiple trials. Your job is to decide if the pattern is tilting to the left or right. In your response, you will also indicate how confident you are in your decision. \nThere are four possible response combinations:\n\n\n\n\n\n\n\n\n\n\nFor each trial, you will have 2 seconds to respond. \n\n',
        font='Arial',
        pos=(0, -0.05), height=0.0325, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr1_Q_txt = visual.TextStim(win=win, name='cpdm_instr1_Q_txt',
        text='Press Q for LEFT tilt and HIGH confidence\n',
        font='Arial',
        pos=(-0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_instr1_P_txt = visual.TextStim(win=win, name='cpdm_instr1_P_txt',
        text='Press P for RIGHT tilt and HIGH confidence\n',
        font='Arial',
        pos=(0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr1_A_txt = visual.TextStim(win=win, name='cpdm_instr1_A_txt',
        text='Press A for LEFT tilt and LOW confidence\n',
        font='Arial',
        pos=(-0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cpdm_instr1_L_txt = visual.TextStim(win=win, name='cpdm_instr1_L_txt',
        text='Press L for RIGHT tilt and LOW confidence\n',
        font='Arial',
        pos=(0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_instr1_space_txt = visual.TextStim(win=win, name='cpdm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr2" ---
    cpdm_instr2_title_txt = visual.TextStim(win=win, name='cpdm_instr2_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr2_instr_txt = visual.TextStim(win=win, name='cpdm_instr2_instr_txt',
        text='You can tell "tilt" by which direction the top of the pattern is pointing:',
        font='Arial',
        pos=(0, 0.2), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr2_left_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_left_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cpdm_instr2_left_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_left_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=-5.0, pos=(-0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-3.0)
    cpdm_instr2_left_txt = visual.TextStim(win=win, name='cpdm_instr2_left_txt',
        text='This pattern tilts LEFT',
        font='Arial',
        pos=(-0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr2_right_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_right_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=True, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    cpdm_instr2_right_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_right_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=5.0, pos=(0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-6.0)
    cpdm_instr2_right_txt = visual.TextStim(win=win, name='cpdm_instr2_right_txt',
        text='This pattern tilts RIGHT',
        font='Arial',
        pos=(0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr2_space_txt = visual.TextStim(win=win, name='cpdm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr3" ---
    cpdm_instr3_title_txt = visual.TextStim(win=win, name='cpdm_instr3_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr3_txt = visual.TextStim(win=win, name='cpdm_instr3_txt',
        text='There are four (4) blocks of 200 trials. \n\nYour choice for each trial will determine how much money you could earn if that trial is randomly selected as your *bonus earnings* trial. The monetary values for each of the four responses may change from block to block. These values will be provided before each block, so pay careful attention.  ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr3_space_txt = visual.TextStim(win=win, name='cpdm_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr4" ---
    cpdm_instr4_title_txt = visual.TextStim(win=win, name='cpdm_instr4_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr4_txt = visual.TextStim(win=win, name='cpdm_instr4_txt',
        text='As you provide your responses, please note some pattern tilts will be harder to determine than others. On these trials, you may be less confident than on trials where the tilt is more obvious.\n\nPlease remember to distiguish between trials in which you feel high and low confidence regarding the tilt of the pattern.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr4_space_txt = visual.TextStim(win=win, name='cpdm_instr4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_warn" ---
    cpdm_warn1_title_txt = visual.TextStim(win=win, name='cpdm_warn1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_warn1_txt = visual.TextStim(win=win, name='cpdm_warn1_txt',
        text='IMPORTANT: The experiment will end if you (1) miss more than 5% of trials per block, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_warn1_space_txt = visual.TextStim(win=win, name='cpdm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_instr" ---
    cpdm_pract_instr_title_txt = visual.TextStim(win=win, name='cpdm_pract_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_pract_instr_txt = visual.TextStim(win=win, name='cpdm_pract_instr_txt',
        text="Let's practice!\n\nIn these example trials, the box you select will turn green if you make the correct choice regarding tilt of the pattern. If you are incorrect, the box you select will turn red. Feedback about performance during the practice trials is to help you understand the task, but will not be given during the actual experiment. ",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_pract_instr_space_txt = visual.TextStim(win=win, name='cpdm_pract_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_pract_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_pract_trial" ---
    # Run 'Begin Experiment' code from cpdm_pract_trial_code
    #set default gray for all four response boxes
    left_high_color = [0,0,0] 
    left_low_color = [0,0,0]
    right_high_color = [0,0,0]
    right_low_color = [0,0,0]
    cpdm_pract_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_pract_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_pract_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_pract_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_pract_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_pract_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_pract_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_high_txt',
        text='LEFT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_pract_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_high_txt',
        text='RIGHT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_pract_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_pract_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_pract_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_iti2" ---
    cpdm_pract_iti_poly_2 = visual.ShapeStim(
        win=win, name='cpdm_pract_iti_poly_2', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial_instr" ---
    cpdm_trial_instr_title_txt = visual.TextStim(win=win, name='cpdm_trial_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_trial_instr_txt = visual.TextStim(win=win, name='cpdm_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nIn the following four sections, you will be presented with a series of trials similar to those you just practiced. Here, you will not receive feedback about your performance. The option you select will turn light gray to indicate your choice. For each trial, you have 2 seconds to make your decision.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_trial_instr_space_txt = visual.TextStim(win=win, name='cpdm_trial_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_run_setter" ---
    
    # --- Initialize components for Routine "cpdm_loop_instr" ---
    # Run 'Begin Experiment' code from cpdm_loop_instr_code
    loop_spec_instr = ""
    run_counter = 1
    cpdm_loop_instr_code2 = visual.TextStim(win=win, name='cpdm_loop_instr_code2',
        text='',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_loop_instr_corr_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_corr_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_loop_instr_right_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_loop_instr_left_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_left_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_loop_instr_right_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_loop_instr_corr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_high_txt',
        text='',
        font='Arial',
        pos=(-0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_loop_instr_incorr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_high_txt',
        text='Incorrect\nHigh Confidence\n$0',
        font='Arial',
        pos=(0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_loop_instr_corr_low_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_low_txt',
        text='Correct\nLow Confidence\n$8',
        font='Arial',
        pos=(-0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='darkseagreen', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_loop_instr_incorr_low = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_low',
        text='Incorrect\nLow Confidence\n$6',
        font='Arial',
        pos=(0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_loop_instr_space_txt = visual.TextStim(win=win, name='cpdm_loop_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    cpdm_loop_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial" ---
    # Run 'Begin Experiment' code from cpdm_trial_code
    cpdm_trial_counter = 1
    cpdm_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_trial_left_high_txt',
        text='',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_trial_right_high_txt',
        text='',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_trials_iti2" ---
    cpdm_trials_iti2_poly = visual.ShapeStim(
        win=win, name='cpdm_trials_iti2_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_run_break2" ---
    # Run 'Begin Experiment' code from cpdm_run_break2_code
    cpdm_run_break_text = ""
    cpdm_space_text = ""
    cpdm_run_break2_title_txt = visual.TextStim(win=win, name='cpdm_run_break2_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_run_break2_txt = visual.TextStim(win=win, name='cpdm_run_break2_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=1.0, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_run_break2_space_txt = visual.TextStim(win=win, name='cpdm_run_break2_space_txt',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_run_break2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "crdm_namer2" ---
    
    # --- Initialize components for Routine "crdm_instr1" ---
    crdm_instr1_title_txt = visual.TextStim(win=win, name='crdm_instr1_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr1_txt = visual.TextStim(win=win, name='crdm_instr1_txt',
        text='In this decision making task, you will be asked to make economic choices between: \n\n- Receiving a certain, smaller amount of money \nOR\n- Playing a lottery for the chance to win a larger amount of money \n\nYour choice for each trial will determine how much money you could earn if randomly selected as your bonus earnings trial. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr1_space_txt = visual.TextStim(win=win, name='crdm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr2" ---
    crdm_instr2_lottname_txt = visual.TextStim(win=win, name='crdm_instr2_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr2_txt = visual.TextStim(win=win, name='crdm_instr2_txt',
        text='The lottery consists of an imaginary bag containing 100 poker chips, some red and some blue. To play, you pull a random chip from the bag.  \n\nThe figure on the left represents the proportion of blue and red chips in the imaginary bag. \n\nHere, most chips are blue (75 of 100) and fewer are red (25 of 100).',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr2_img = visual.ImageStim(
        win=win,
        name='crdm_instr2_img', units='height', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr2_lott0_txt = visual.TextStim(win=win, name='crdm_instr2_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr2_lott20_txt = visual.TextStim(win=win, name='crdm_instr2_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr2_space_txt = visual.TextStim(win=win, name='crdm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr3" ---
    crdm_instr3_lottname_txt = visual.TextStim(win=win, name='crdm_instr3_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr3_txt = visual.TextStim(win=win, name='crdm_instr3_txt',
        text='Given information about the number of blue and red chips in the bag, you can decide whether you would prefer a certain monetary outcome or if you would rather play the lottery for a chance to win a different amount.\n\nIn this example, you have a 75% chance of pulling a blue chip and winning $20. Conversely, you have a 25% chance of pulling a red chip and receiving $0.\n\nThe value for each color will change from bag to bag. Read the $ amounts above the red and below the blue to know the value of each chip color.',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=1.0, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr3_img = visual.ImageStim(
        win=win,
        name='crdm_instr3_img', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr3_lott0_txt = visual.TextStim(win=win, name='crdm_instr3_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr3_lott20_txt = visual.TextStim(win=win, name='crdm_instr3_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr3_space_txt = visual.TextStim(win=win, name='crdm_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr4" ---
    crdm_instr4_lottname_txt = visual.TextStim(win=win, name='crdm_instr4_lottname_txt',
        text='*Playing the Lottery*',
        font='Arial',
        pos=(-0.2, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr4_txt = visual.TextStim(win=win, name='crdm_instr4_txt',
        text='For some lotteries, information about the bag contents may be partially hidden. \n\nIn this example, at least 25 chips are blue and 25 chips are red. However, the color of the remaining 50 chips is unknown. The remaining 50 could be all red, all blue, or a combination of the two. ',
        font='Arial',
        pos=(-0.2, 0), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr4_img = visual.ImageStim(
        win=win,
        name='crdm_instr4_img', 
        image='crdm/ambig_50.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0.6, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr4_lott0_txt = visual.TextStim(win=win, name='crdm_instr4_lott0_txt',
        text='$0',
        font='Arial',
        pos=(0.6, 0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr4_lott20_txt = visual.TextStim(win=win, name='crdm_instr4_lott20_txt',
        text='$20',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr4_space_txt = visual.TextStim(win=win, name='crdm_instr4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr5" ---
    crdm_instr5_txt = visual.TextStim(win=win, name='crdm_instr5_txt',
        text='The lottery bag will appear at the center of the screen. The certain dollar amount will be presented on either the right or left side of the bag. Here, a certain $5 would be the left option, and lottery would be the right option:',
        font='Arial',
        pos=(0, 0.35), height=0.03, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr5_img = visual.ImageStim(
        win=win,
        name='crdm_instr5_img', 
        image='crdm/risk_blue_75.bmp', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_instr5_lott_top_txt = visual.TextStim(win=win, name='crdm_instr5_lott_top_txt',
        text='$0',
        font='Arial',
        pos=(0, 0.25), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_instr5_lott_bot_txt = visual.TextStim(win=win, name='crdm_instr5_lott_bot_txt',
        text='$20',
        font='Arial',
        pos=(0, -0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr5_sure_txt = visual.TextStim(win=win, name='crdm_instr5_sure_txt',
        text='$5',
        font='Arial',
        pos=(-0.5, -0.05), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_instr5_space_txt = visual.TextStim(win=win, name='crdm_instr5_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_instr5_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr6" ---
    crdm_instr6_title_txt = visual.TextStim(win=win, name='crdm_instr6_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr6_txt = visual.TextStim(win=win, name='crdm_instr6_txt',
        text='When the green circle appears, use the number keys at the top of your keyboard to indicate your choice:\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr6_img = visual.ImageStim(
        win=win,
        name='crdm_instr6_img', 
        image='crdm/crdm_2key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.1), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr6_space_txt = visual.TextStim(win=win, name='crdm_instr6_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr6_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_instr7" ---
    crdm_instr7_title_txt = visual.TextStim(win=win, name='crdm_instr7_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_instr7_txt = visual.TextStim(win=win, name='crdm_instr7_txt',
        text="After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_instr7_img = visual.ImageStim(
        win=win,
        name='crdm_instr7_img', 
        image='crdm/crdm_4key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.15), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    crdm_instr7_space_txt = visual.TextStim(win=win, name='crdm_instr7_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_instr7_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_warn" ---
    crdm_warn1_title_txt = visual.TextStim(win=win, name='crdm_warn1_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_warn1_txt = visual.TextStim(win=win, name='crdm_warn1_txt',
        text='IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_warn1_space_txt = visual.TextStim(win=win, name='crdm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract1_instr" ---
    crdm_pract1_instr_name_txt = visual.TextStim(win=win, name='crdm_pract1_instr_name_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_pract1_instr_txt = visual.TextStim(win=win, name='crdm_pract1_instr_txt',
        text="In this first section, you will only be asked to indicate your choice between the certain outcome and the lottery. You will not be asked to rate your choice confidence.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. \n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract1_instr_space_txt = visual.TextStim(win=win, name='crdm_pract1_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract1_instr_key = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_pract1_trial" ---
    # Run 'Begin Experiment' code from crdm_pract1_trial_code
    #position of certain amount option
    crdm_sure_pos1 = [] 
    crdm_sure_resp1 = []
    crdm_crdm_msg1 = ""
    
    #stimuli positions and respective responses
    #left/right screen locations
    crdm_pos1 = [[-0.5, 0], [0.5, 0]] 
    crdm_resp1 = ["1", "2"] #1 = left, 2 = right
    crdm_pract1_trial_img = visual.ImageStim(
        win=win,
        name='crdm_pract1_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_pract1_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_pract1_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract1_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_pract1_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract1_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_pract1_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix4 = visual.Rect(
        win=win, name='GRFX_fix4',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_pract1_trial_cue = visual.ShapeStim(
        win=win, name='crdm_pract1_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract1_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract1_feedback" ---
    crdm_pract1_feedback_txt = visual.TextStim(win=win, name='crdm_pract1_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_qp_instr" ---
    crdm_qp_instr_title_txt = visual.TextStim(win=win, name='crdm_qp_instr_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_qp_instr_txt = visual.TextStim(win=win, name='crdm_qp_instr_txt',
        text="Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_qp_instr_space_txt = visual.TextStim(win=win, name='crdm_qp_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_qp_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_questplus" ---
    # Run 'Begin Experiment' code from crdm_questplus_JS
    #position of certain amount option
    sure_pos = [] 
    sure_resp = []
    crdm_msg = ""
    
    #stimuli positions and respective responses
    pos = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    resp = ["1", "2"] #1 = left, 2 = right
    crdm_questplus_img = visual.ImageStim(
        win=win,
        name='crdm_questplus_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_questplus_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_questplus_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_questplus_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_questplus_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_questplus_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_questplus_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix3 = visual.Rect(
        win=win, name='GRFX_fix3',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_questplus_trial_cue = visual.ShapeStim(
        win=win, name='crdm_questplus_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_questplus_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_qp_feedback" ---
    crdm_qp_feedback_txt = visual.TextStim(win=win, name='crdm_qp_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_schedule_gen" ---
    
    # --- Initialize components for Routine "crdm_pract2_instr" ---
    crdm_pract2_instr_name_txt = visual.TextStim(win=win, name='crdm_pract2_instr_name_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    crdm_pract2_instr_txt = visual.TextStim(win=win, name='crdm_pract2_instr_txt',
        text="In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract2_instr_space_txt = visual.TextStim(win=win, name='crdm_pract2_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract2_instr_key = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_pract2_trial" ---
    # Run 'Begin Experiment' code from crdm_pract2_trial_code
    #position of certain amount option
    crdm_sure_pos2 = [] 
    crdm_sure_resp2 = []
    crdm_crdm_msg2 = ""
    
    #stimuli positions and respective responses
    #left/right screen locations
    crdm_pos2 = [[-0.5, 0], [0.5, 0]] 
    crdm_resp2 = ["1", "2"] #1 = left, 2 = right
    crdm_pract2_trial_img = visual.ImageStim(
        win=win,
        name='crdm_pract2_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_pract2_trial_lott_top_txt = visual.TextStim(win=win, name='crdm_pract2_trial_lott_top_txt',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_pract2_trial_lott_bot_txt = visual.TextStim(win=win, name='crdm_pract2_trial_lott_bot_txt',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract2_trial_sure_amt_txt = visual.TextStim(win=win, name='crdm_pract2_trial_sure_amt_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix2 = visual.Rect(
        win=win, name='GRFX_fix2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_pract2_trial_cue = visual.ShapeStim(
        win=win, name='crdm_pract2_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract2_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract2_feedback" ---
    crdm_pract2_feedback_txt = visual.TextStim(win=win, name='crdm_pract2_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_pract2_conf" ---
    crdm_pract2_conf_txt = visual.TextStim(win=win, name='crdm_pract2_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_pract2_conf1 = visual.Rect(
        win=win, name='crdm_pract2_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    crdm_pract2_conf1_txt = visual.TextStim(win=win, name='crdm_pract2_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_pract2_conf2 = visual.Rect(
        win=win, name='crdm_pract2_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    crdm_pract2_conf2_txt = visual.TextStim(win=win, name='crdm_pract2_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_pract2_conf3 = visual.Rect(
        win=win, name='crdm_pract2_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    crdm_pract2_conf3_txt = visual.TextStim(win=win, name='crdm_pract2_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    crdm_pract2_conf4 = visual.Rect(
        win=win, name='crdm_pract2_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    crdm_pract2_conf4_txt = visual.TextStim(win=win, name='crdm_pract2_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    crdm_pract2_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_pract2_iti2" ---
    crdm_pract2_iti2_poly = visual.ShapeStim(
        win=win, name='crdm_pract2_iti2_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_trial_instr" ---
    crdm_trial_instr_title_txt = visual.TextStim(win=win, name='crdm_trial_instr_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_trial_instr_txt = visual.TextStim(win=win, name='crdm_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nMake your choice between the certain outcome and lottery as soon as you see the green circle. You will have 3 seconds to consider and 2 seconds to respond. You will then have an additional 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_trial_instr_space_txt = visual.TextStim(win=win, name='crdm_trial_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_init_fix" ---
    crdm_init_fix_poly = visual.ShapeStim(
        win=win, name='crdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_trial" ---
    crdm_trial_img = visual.ImageStim(
        win=win,
        name='crdm_trial_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    crdm_trial_lott_top = visual.TextStim(win=win, name='crdm_trial_lott_top',
        text='',
        font='Arial',
        pos=(0, 0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_trial_lott_bot = visual.TextStim(win=win, name='crdm_trial_lott_bot',
        text='',
        font='Arial',
        pos=(0, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_trial_sure_amt = visual.TextStim(win=win, name='crdm_trial_sure_amt',
        text='',
        font='Arial',
        pos=[0,0], height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    GRFX_fix = visual.Rect(
        win=win, name='GRFX_fix',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-5.0, interpolate=True)
    crdm_trial_cue = visual.ShapeStim(
        win=win, name='crdm_trial_cue',
        size=(0.04, 0.04), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-6.0, interpolate=True)
    crdm_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_feedback" ---
    crdm_feedback_txt = visual.TextStim(win=win, name='crdm_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "crdm_conf" ---
    crdm_conf_txt = visual.TextStim(win=win, name='crdm_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.5, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_conf1 = visual.Rect(
        win=win, name='crdm_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    crdm_conf1_txt = visual.TextStim(win=win, name='crdm_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_conf2 = visual.Rect(
        win=win, name='crdm_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    crdm_conf2_txt = visual.TextStim(win=win, name='crdm_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_conf3 = visual.Rect(
        win=win, name='crdm_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    crdm_conf3_txt = visual.TextStim(win=win, name='crdm_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    crdm_conf4 = visual.Rect(
        win=win, name='crdm_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    crdm_conf4_txt = visual.TextStim(win=win, name='crdm_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    crdm_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_trials_iti2" ---
    crdm_trials_iti2_poly = visual.ShapeStim(
        win=win, name='crdm_trials_iti2_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "crdm_end" ---
    # Run 'Begin Experiment' code from crdm_end_code
    crdm_task_end_text = ""
    crdm_space_text = ""
    crdm_end_title_txt = visual.TextStim(win=win, name='crdm_end_title_txt',
        text='* Risk & Ambiguity Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_end_txt_ON = visual.TextStim(win=win, name='crdm_end_txt_ON',
        text='',
        font='Arial',
        pos=(0, 0), height=0.05, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_end_space_ON = visual.TextStim(win=win, name='crdm_end_space_ON',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    crdm_end_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "cdd_namer2" ---
    
    # --- Initialize components for Routine "cdd_instr1" ---
    cdd_instr1_title_txt = visual.TextStim(win=win, name='cdd_instr1_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr1_txt = visual.TextStim(win=win, name='cdd_instr1_txt',
        text='In this decision making task, you will be asked indicate your preference between: \n\n- An amount of money you could receive today \nOR\n- An amount of money you could receive in the future \n\nThe value of each option and the length of delay will change across trials. One of your choices in this section may be randomly selected as your *bonus earnings trial* at the end of the experiment.\n\nExample: \n- If you chose $25 dollars immediately, you would receive $25 today.   \n- If you chose $50 in 15 days, you would receive $50 in 15 days. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr1_space_txt = visual.TextStim(win=win, name='cdd_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_instr2" ---
    cdd_instr2_title_txt = visual.TextStim(win=win, name='cdd_instr2_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr2_txt = visual.TextStim(win=win, name='cdd_instr2_txt',
        text='Please read each options carefully. The immediate and delayed choices may switch sides.\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n\n\nWhen the green circle appears, you will have 2 seconds to choose.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr2_img = visual.ImageStim(
        win=win,
        name='cdd_instr2_img', 
        image='cdd/cdd_2key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cdd_instr2_space_txt = visual.TextStim(win=win, name='cdd_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_instr3" ---
    cdd_instr3_title_txt = visual.TextStim(win=win, name='cdd_instr3_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_instr3_txt = visual.TextStim(win=win, name='cdd_instr3_txt',
        text="After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_instr3_img = visual.ImageStim(
        win=win,
        name='cdd_instr3_img', 
        image='cdd/cdd_4key.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.15), size=(0.6, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cdd_instr3_space_txt = visual.TextStim(win=win, name='cdd_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_warn" ---
    cdd_warn1_title_txt = visual.TextStim(win=win, name='cdd_warn1_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_warn1_txt = visual.TextStim(win=win, name='cdd_warn1_txt',
        text='IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_warn1_space_txt = visual.TextStim(win=win, name='cdd_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract1_instr" ---
    cdd_pract1_instr_left_poly = visual.Rect(
        win=win, name='cdd_pract1_instr_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0, 0, 0],
        opacity=None, depth=0.0, interpolate=True)
    cdd_pract1_instr_right_poly = visual.Rect(
        win=win, name='cdd_pract1_instr_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0, 0, 0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract1_instr_txt = visual.TextStim(win=win, name='cdd_pract1_instr_txt',
        text="*EXAMPLE TRIAL*\n\nWhich would you prefer?\n\n\n\n\n\n\n\n\nLet's practice!",
        font='Arial',
        pos=(0, 0.05), height=0.05, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_pract1_instr_immed_txt = visual.TextStim(win=win, name='cdd_pract1_instr_immed_txt',
        text='$10\n\nTODAY',
        font='Arial',
        pos=(0.5, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract1_instr_delay_txt = visual.TextStim(win=win, name='cdd_pract1_instr_delay_txt',
        text='$50 \n\n9 DAYS',
        font='Arial',
        pos=(-0.5, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract1_instr_or_txt = visual.TextStim(win=win, name='cdd_pract1_instr_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract1_instr_space_txt = visual.TextStim(win=win, name='cdd_pract1_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_pract1_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_pract1_trial" ---
    # Run 'Begin Experiment' code from cdd_pract1_trial_code
    cdd_immed_pos1 = [] #position of immediate amt option
    cdd_immed_resp1 = [] #which key is immediate amt option
    cdd_msg1 = ""
    
    #stimuli positions and respective responses
    cdd_pos1 = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    cdd_resp1 = ["1", "2"] #1 = left, 2 = right
    cdd_pract1_trial_left_poly = visual.Rect(
        win=win, name='cdd_pract1_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract1_trial_right_poly = visual.Rect(
        win=win, name='cdd_pract1_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract1_trial_prompt_txt = visual.TextStim(win=win, name='cdd_pract1_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract1_trial_immed_txt = visual.TextStim(win=win, name='cdd_pract1_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract1_trial_or_txt = visual.TextStim(win=win, name='cdd_pract1_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract1_trial_delay_txt = visual.TextStim(win=win, name='cdd_pract1_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_pract1_trial_cue = visual.ShapeStim(
        win=win, name='cdd_pract1_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_pract1_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract1_feedback" ---
    cdd_pract1_feedback_txt = visual.TextStim(win=win, name='cdd_pract1_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_qp_instr" ---
    cdd_qp_instr_title_txt = visual.TextStim(win=win, name='cdd_qp_instr_title_txt',
        text='* Delayed Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_qp_instr_txt = visual.TextStim(win=win, name='cdd_qp_instr_txt',
        text="Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_qp_instr_space_txt = visual.TextStim(win=win, name='cdd_qp_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_qp_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_questplus" ---
    cdd_questplus_trial_left_poly = visual.Rect(
        win=win, name='cdd_questplus_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_questplus_trial_right_poly = visual.Rect(
        win=win, name='cdd_questplus_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_questplus_trial_prompt_txt = visual.TextStim(win=win, name='cdd_questplus_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_questplus_trial_immed_txt = visual.TextStim(win=win, name='cdd_questplus_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_questplus_trial_or_txt = visual.TextStim(win=win, name='cdd_questplus_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_questplus_trial_delay_txt = visual.TextStim(win=win, name='cdd_questplus_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    GRFX_fix2_2 = visual.Rect(
        win=win, name='GRFX_fix2_2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_questplus_trial_cue = visual.ShapeStim(
        win=win, name='cdd_questplus_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-8.0, interpolate=True)
    cdd_questplus_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_questplus_fb" ---
    cdd_qp_fb_txt = visual.TextStim(win=win, name='cdd_qp_fb_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_schedule_gen" ---
    
    # --- Initialize components for Routine "cdd_pract2_instr" ---
    cdd_pract2_intr_name_txt = visual.TextStim(win=win, name='cdd_pract2_intr_name_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.3), height=0.03, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cdd_pract2_instr_txt = visual.TextStim(win=win, name='cdd_pract2_instr_txt',
        text="In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_pract_instr_space_txt_2 = visual.TextStim(win=win, name='cdd_pract_instr_space_txt_2',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_pract_instr_resp_2 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_pract2_trial" ---
    # Run 'Begin Experiment' code from cdd_pract2_trial_code
    cdd_immed_pos2 = [] #position of immediate amt option
    cdd_immed_resp2 = [] #which key is immediate amt option
    cdd_msg2 = ""
    
    #stimuli positions and respective responses
    cdd_pos2 = [[-0.5, 0], [0.5, 0]] #left/right screen locations
    cdd_resp2 = ["1", "2"] #1 = left, 2 = right
    cdd_pract2_trial_left_poly = visual.Rect(
        win=win, name='cdd_pract2_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_pract2_trial_right_poly = visual.Rect(
        win=win, name='cdd_pract2_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract2_trial_prompt_txt = visual.TextStim(win=win, name='cdd_pract2_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract2_trial_immed_txt = visual.TextStim(win=win, name='cdd_pract2_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_pract2_trial_or_txt = visual.TextStim(win=win, name='cdd_pract2_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract2_trial_delay_txt = visual.TextStim(win=win, name='cdd_pract2_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    GRFX_fix3_2 = visual.Rect(
        win=win, name='GRFX_fix3_2',
        width=(2, 2)[0], height=(2, 2)[1],
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[0,0,0], fillColor=[0,0,0],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_pract2_trial_cue = visual.ShapeStim(
        win=win, name='cdd_pract2_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-8.0, interpolate=True)
    cdd_pract2_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract2_feedback" ---
    cdd_pract2_fb_txt = visual.TextStim(win=win, name='cdd_pract2_fb_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_pract2_conf" ---
    cdd_pract2_conf_txt = visual.TextStim(win=win, name='cdd_pract2_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_pract2_conf1 = visual.Rect(
        win=win, name='cdd_pract2_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cdd_pract2_conf1_txt = visual.TextStim(win=win, name='cdd_pract2_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_pract2_conf2 = visual.Rect(
        win=win, name='cdd_pract2_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cdd_pract2_conf2_txt = visual.TextStim(win=win, name='cdd_pract2_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_pract2_conf3 = visual.Rect(
        win=win, name='cdd_pract2_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    cdd_pract2_conf3_txt = visual.TextStim(win=win, name='cdd_pract2_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cdd_pract2_conf4 = visual.Rect(
        win=win, name='cdd_pract2_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    cdd_pract2_conf4_txt = visual.TextStim(win=win, name='cdd_pract2_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cdd_pract2_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_pract2_iti2" ---
    cdd_pract2_iti2_poly = visual.ShapeStim(
        win=win, name='cdd_pract2_iti2_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_trial_instr" ---
    cdd_trial_instr_title_txt = visual.TextStim(win=win, name='cdd_trial_instr_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_trial_instr_txt = visual.TextStim(win=win, name='cdd_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nRemember to make your choice between the immediate and delayed amounts when you see the green circle. You will have 3 seconds to consider both options and 2 seconds to make your choice. After each choice, you will be given 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, -0.05), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_trial_instr_space_txt = visual.TextStim(win=win, name='cdd_trial_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_init_fix" ---
    cdd_init_fix_polygon = visual.ShapeStim(
        win=win, name='cdd_init_fix_polygon', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_trial" ---
    cdd_trial_left_poly = visual.Rect(
        win=win, name='cdd_trial_left_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-1.0, interpolate=True)
    cdd_trial_right_poly = visual.Rect(
        win=win, name='cdd_trial_right_poly',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.5, 0), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor=[0,0,0],
        opacity=None, depth=-2.0, interpolate=True)
    cdd_trial_prompt_txt = visual.TextStim(win=win, name='cdd_trial_prompt_txt',
        text='Which would you prefer?',
        font='Arial',
        pos=(0, 0.3), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_trial_immed_txt = visual.TextStim(win=win, name='cdd_trial_immed_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_trial_or_txt = visual.TextStim(win=win, name='cdd_trial_or_txt',
        text='OR',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_trial_delay_txt = visual.TextStim(win=win, name='cdd_trial_delay_txt',
        text='',
        font='Arial',
        pos=[0,0], height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_trial_cue = visual.ShapeStim(
        win=win, name='cdd_trial_cue',
        size=(0.05, 0.05), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, 1.0000, -1.0000], fillColor=[-1.0000, 1.0000, -1.0000],
        opacity=None, depth=-7.0, interpolate=True)
    cdd_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_feedback" ---
    cdd_feedback_txt = visual.TextStim(win=win, name='cdd_feedback_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "cdd_conf" ---
    cdd_conf_txt = visual.TextStim(win=win, name='cdd_conf_txt',
        text='How confident are you in your choice?',
        font='Arial',
        pos=(0, 0), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_conf1 = visual.Rect(
        win=win, name='cdd_conf1',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cdd_conf1_txt = visual.TextStim(win=win, name='cdd_conf1_txt',
        text='Not at all\nconfident\n\n1',
        font='Arial',
        pos=(-0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_conf2 = visual.Rect(
        win=win, name='cdd_conf2',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(-0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cdd_conf2_txt = visual.TextStim(win=win, name='cdd_conf2_txt',
        text='Less\nconfident\n\n2',
        font='Arial',
        pos=(-0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_conf3 = visual.Rect(
        win=win, name='cdd_conf3',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.2, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-6.0, interpolate=True)
    cdd_conf3_txt = visual.TextStim(win=win, name='cdd_conf3_txt',
        text='Somewhat\nconfident\n\n3',
        font='Arial',
        pos=(0.2, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cdd_conf4 = visual.Rect(
        win=win, name='cdd_conf4',
        width=(0.3, 0.3)[0], height=(0.3, 0.3)[1],
        ori=0.0, pos=(0.6, -0.3), anchor='center',
        lineWidth=10.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-8.0, interpolate=True)
    cdd_conf4_txt = visual.TextStim(win=win, name='cdd_conf4_txt',
        text='Very\nconfident\n\n4',
        font='Arial',
        pos=(0.6, -0.3), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cdd_conf_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_trial_iti2" ---
    cdd_trial_iti2_poly = visual.ShapeStim(
        win=win, name='cdd_trial_iti2_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor=[1.0000, 1.0000, 1.0000], fillColor=[1.0000, 1.0000, 1.0000],
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cdd_end" ---
    # Run 'Begin Experiment' code from cdd_end_code
    cdd_task_end_text = ""
    cdd_space_text = ""
    cdd_end_title_txt = visual.TextStim(win=win, name='cdd_end_title_txt',
        text='* Delay Discounting Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_end_txt_ON = visual.TextStim(win=win, name='cdd_end_txt_ON',
        text='',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_end_space_ON = visual.TextStim(win=win, name='cdd_end_space_ON',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_end_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "cpdm_namer3" ---
    
    # --- Initialize components for Routine "cpdm_instr1" ---
    cpdm_instr1_img = visual.ImageStim(
        win=win,
        name='cpdm_instr1_img', 
        image='cpdm/cpdm_keys.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.06), size=(0.65, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    cpdm_instr1_title_txt = visual.TextStim(win=win, name='cpdm_instr1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr1_txt = visual.TextStim(win=win, name='cpdm_instr1_txt',
        text='You will be presented with a series of oriented patterns across multiple trials. Your job is to decide if the pattern is tilting to the left or right. In your response, you will also indicate how confident you are in your decision. \nThere are four possible response combinations:\n\n\n\n\n\n\n\n\n\n\nFor each trial, you will have 2 seconds to respond. \n\n',
        font='Arial',
        pos=(0, -0.05), height=0.0325, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr1_Q_txt = visual.TextStim(win=win, name='cpdm_instr1_Q_txt',
        text='Press Q for LEFT tilt and HIGH confidence\n',
        font='Arial',
        pos=(-0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_instr1_P_txt = visual.TextStim(win=win, name='cpdm_instr1_P_txt',
        text='Press P for RIGHT tilt and HIGH confidence\n',
        font='Arial',
        pos=(0.3, 0.07), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr1_A_txt = visual.TextStim(win=win, name='cpdm_instr1_A_txt',
        text='Press A for LEFT tilt and LOW confidence\n',
        font='Arial',
        pos=(-0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cpdm_instr1_L_txt = visual.TextStim(win=win, name='cpdm_instr1_L_txt',
        text='Press L for RIGHT tilt and LOW confidence\n',
        font='Arial',
        pos=(0.3, -0.225), height=0.025, wrapWidth=None, ori=0.0, 
        color=[1.0000, 0.6863, -1.0000], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_instr1_space_txt = visual.TextStim(win=win, name='cpdm_instr1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr2" ---
    cpdm_instr2_title_txt = visual.TextStim(win=win, name='cpdm_instr2_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr2_instr_txt = visual.TextStim(win=win, name='cpdm_instr2_instr_txt',
        text='You can tell "tilt" by which direction the top of the pattern is pointing:',
        font='Arial',
        pos=(0, 0.2), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr2_left_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_left_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    cpdm_instr2_left_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_left_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=-5.0, pos=(-0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-3.0)
    cpdm_instr2_left_txt = visual.TextStim(win=win, name='cpdm_instr2_left_txt',
        text='This pattern tilts LEFT',
        font='Arial',
        pos=(-0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_instr2_right_arrow = visual.ImageStim(
        win=win,
        name='cpdm_instr2_right_arrow', 
        image='cpdm/arrow.png', mask=None, anchor='center',
        ori=0.0, pos=(0.4, 0.05), size=(0.15, 0.05),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=True, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    cpdm_instr2_right_gabor = visual.GratingStim(
        win=win, name='cpdm_instr2_right_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=5.0, pos=(0.4, -0.1), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=0.2, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-6.0)
    cpdm_instr2_right_txt = visual.TextStim(win=win, name='cpdm_instr2_right_txt',
        text='This pattern tilts RIGHT',
        font='Arial',
        pos=(0.4, -0.25), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_instr2_space_txt = visual.TextStim(win=win, name='cpdm_instr2_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_instr2_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr3" ---
    cpdm_instr3_title_txt = visual.TextStim(win=win, name='cpdm_instr3_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr3_txt = visual.TextStim(win=win, name='cpdm_instr3_txt',
        text='There are four (4) blocks of 200 trials. \n\nYour choice for each trial will determine how much money you could earn if that trial is randomly selected as your *bonus earnings* trial. The monetary values for each of the four responses may change from block to block. These values will be provided before each block, so pay careful attention.  ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr3_space_txt = visual.TextStim(win=win, name='cpdm_instr3_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_instr4" ---
    cpdm_instr4_title_txt = visual.TextStim(win=win, name='cpdm_instr4_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_instr4_txt = visual.TextStim(win=win, name='cpdm_instr4_txt',
        text='As you provide your responses, please note some pattern tilts will be harder to determine than others. On these trials, you may be less confident than on trials where the tilt is more obvious.\n\nPlease remember to distiguish between trials in which you feel high and low confidence regarding the tilt of the pattern.',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_instr4_space_txt = visual.TextStim(win=win, name='cpdm_instr4_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_instr4_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_warn" ---
    cpdm_warn1_title_txt = visual.TextStim(win=win, name='cpdm_warn1_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_warn1_txt = visual.TextStim(win=win, name='cpdm_warn1_txt',
        text='IMPORTANT: The experiment will end if you (1) miss more than 5% of trials per block, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_warn1_space_txt = visual.TextStim(win=win, name='cpdm_warn1_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_warn1_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_instr" ---
    cpdm_pract_instr_title_txt = visual.TextStim(win=win, name='cpdm_pract_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_pract_instr_txt = visual.TextStim(win=win, name='cpdm_pract_instr_txt',
        text="Let's practice!\n\nIn these example trials, the box you select will turn green if you make the correct choice regarding tilt of the pattern. If you are incorrect, the box you select will turn red. Feedback about performance during the practice trials is to help you understand the task, but will not be given during the actual experiment. ",
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_pract_instr_space_txt = visual.TextStim(win=win, name='cpdm_pract_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_pract_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_pract_trial" ---
    # Run 'Begin Experiment' code from cpdm_pract_trial_code
    #set default gray for all four response boxes
    left_high_color = [0,0,0] 
    left_low_color = [0,0,0]
    right_high_color = [0,0,0]
    right_low_color = [0,0,0]
    cpdm_pract_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_pract_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_pract_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_pract_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_pract_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_pract_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_pract_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_pract_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_high_txt',
        text='LEFT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_pract_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_high_txt',
        text='RIGHT\n\nHIGH Confidence\n\n$9 or $0',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_pract_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_pract_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_pract_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_pract_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_pract_iti3" ---
    cpdm_pract_iti3_poly = visual.ShapeStim(
        win=win, name='cpdm_pract_iti3_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial_instr" ---
    cpdm_trial_instr_title_txt = visual.TextStim(win=win, name='cpdm_trial_instr_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    cpdm_trial_instr_txt = visual.TextStim(win=win, name='cpdm_trial_instr_txt',
        text='Now that you have practiced, the actual task will begin.\n\nIn the following four sections, you will be presented with a series of trials similar to those you just practiced. Here, you will not receive feedback about your performance. The option you select will turn light gray to indicate your choice. For each trial, you have 2 seconds to make your decision.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
        font='Arial',
        pos=(0, 0), height=0.03, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_trial_instr_space_txt = visual.TextStim(win=win, name='cpdm_trial_instr_space_txt',
        text='Press SPACE to begin.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_trial_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_run_setter" ---
    
    # --- Initialize components for Routine "cpdm_loop_instr" ---
    # Run 'Begin Experiment' code from cpdm_loop_instr_code
    loop_spec_instr = ""
    run_counter = 1
    cpdm_loop_instr_code2 = visual.TextStim(win=win, name='cpdm_loop_instr_code2',
        text='',
        font='Arial',
        pos=(0, 0.35), height=0.06, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_loop_instr_corr_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_corr_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_loop_instr_right_high_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_high_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, 0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_loop_instr_left_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_left_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(-0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_loop_instr_right_low_poly = visual.Rect(
        win=win, name='cpdm_loop_instr_right_low_poly',
        width=(0.25, 0.25)[0], height=(0.25, 0.25)[1],
        ori=0.0, pos=(0.125, -0.125), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor=[0.0000, 0.0000, 0.0000],
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_loop_instr_corr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_high_txt',
        text='',
        font='Arial',
        pos=(-0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_loop_instr_incorr_high_txt = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_high_txt',
        text='Incorrect\nHigh Confidence\n$0',
        font='Arial',
        pos=(0.125, 0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_loop_instr_corr_low_txt = visual.TextStim(win=win, name='cpdm_loop_instr_corr_low_txt',
        text='Correct\nLow Confidence\n$8',
        font='Arial',
        pos=(-0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='darkseagreen', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_loop_instr_incorr_low = visual.TextStim(win=win, name='cpdm_loop_instr_incorr_low',
        text='Incorrect\nLow Confidence\n$6',
        font='Arial',
        pos=(0.125, -0.125), height=0.03, wrapWidth=None, ori=0.0, 
        color='salmon', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_loop_instr_space_txt = visual.TextStim(win=win, name='cpdm_loop_instr_space_txt',
        text='Press SPACE to continue.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    cpdm_loop_instr_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_init_fix" ---
    cpdm_init_fix_poly = visual.ShapeStim(
        win=win, name='cpdm_init_fix_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=0.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_trial" ---
    # Run 'Begin Experiment' code from cpdm_trial_code
    cpdm_trial_counter = 1
    cpdm_trial_gabor = visual.GratingStim(
        win=win, name='cpdm_trial_gabor',
        tex='sin', mask='gauss', anchor='center',
        ori=1.0, pos=(0, 0), size=(0.25, 0.25), sf=6.0, phase=0.0,
        color=[1,1,1], colorSpace='rgb',
        opacity=None, contrast=1.0, blendmode='avg',
        texRes=128.0, interpolate=True, depth=-1.0)
    cpdm_trial_left_high_poly = visual.Rect(
        win=win, name='cpdm_trial_left_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    cpdm_trial_right_high_poly = visual.Rect(
        win=win, name='cpdm_trial_right_high_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, 0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    cpdm_trial_left_low_poly = visual.Rect(
        win=win, name='cpdm_trial_left_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(-0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    cpdm_trial_right_low_poly = visual.Rect(
        win=win, name='cpdm_trial_right_low_poly',
        width=(0.35, 0.35)[0], height=(0.35, 0.35)[1],
        ori=0.0, pos=(0.45, -0.25), anchor='center',
        lineWidth=15.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    cpdm_trial_left_high_txt = visual.TextStim(win=win, name='cpdm_trial_left_high_txt',
        text='',
        font='Arial',
        pos=(-0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_trial_right_high_txt = visual.TextStim(win=win, name='cpdm_trial_right_high_txt',
        text='',
        font='Arial',
        pos=(0.45, 0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_trial_left_low_txt = visual.TextStim(win=win, name='cpdm_trial_left_low_txt',
        text='LEFT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(-0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_trial_right_low_txt = visual.TextStim(win=win, name='cpdm_trial_right_low_txt',
        text='RIGHT\n\nLOW Confidence\n\n$8 or $6',
        font='Arial',
        pos=(0.45, -0.25), height=0.035, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    cpdm_trial_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cpdm_trials_iti3" ---
    cpdm_trials_iti3_poly = visual.ShapeStim(
        win=win, name='cpdm_trials_iti3_poly', vertices='cross',
        size=(0.05, 0.05),
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "cpdm_run_break3" ---
    # Run 'Begin Experiment' code from cpdm_run_break3_code
    cpdm_run_break_text = ""
    cpdm_space_text = ""
    cpdm_run_break3_title_txt = visual.TextStim(win=win, name='cpdm_run_break3_title_txt',
        text='* Visual Decision Making Task *',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_run_break3_txt = visual.TextStim(win=win, name='cpdm_run_break3_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.05, wrapWidth=1.35, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_run_break3_space_txt = visual.TextStim(win=win, name='cpdm_run_break3_space_txt',
        text='',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_run_break3_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_term_check" ---
    
    # --- Initialize components for Routine "idm_rand_select" ---
    
    # --- Initialize components for Routine "cpdm_bonus" ---
    cpdm_bonus_thanks_txt = visual.TextStim(win=win, name='cpdm_bonus_thanks_txt',
        text='Your randomly selected *bonus earnings trial* is from the\nVisual Decision Making Task!',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=1.35, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cpdm_bonus_earnings_txt = visual.TextStim(win=win, name='cpdm_bonus_earnings_txt',
        text='',
        font='Arial',
        pos=(0, 0.10), height=0.04, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cpdm_bonus_amt_txt = visual.TextStim(win=win, name='cpdm_bonus_amt_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.08, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cpdm_bonus_answer_txt = visual.TextStim(win=win, name='cpdm_bonus_answer_txt',
        text='Your answer was',
        font='Arial',
        pos=(0, -0.1), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cpdm_bonus_acc_txt = visual.TextStim(win=win, name='cpdm_bonus_acc_txt',
        text='',
        font='Arial',
        pos=(0, -0.15), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cpdm_bonus_and_txt = visual.TextStim(win=win, name='cpdm_bonus_and_txt',
        text='and',
        font='Arial',
        pos=(0, -0.2), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cpdm_bonus_conf_txt = visual.TextStim(win=win, name='cpdm_bonus_conf_txt',
        text='',
        font='Arial',
        pos=(0, -0.25), height=0.04, wrapWidth=None, ori=0.0, 
        color=[0.0588, 0.6157, 0.9608], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    cpdm_bonus_space_txt = visual.TextStim(win=win, name='cpdm_bonus_space_txt',
        text='Press SPACE to receive your *COMPLETION CODE*',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    cpdm_bonus_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "crdm_bonus" ---
    crdm_bonus_thanks_txt = visual.TextStim(win=win, name='crdm_bonus_thanks_txt',
        text='Your randomly selected *bonus earnings trial* is from the\nRisk & Ambiguity Task!',
        font='Arial',
        pos=(0, 0.35), height=0.05, wrapWidth=1.35, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    crdm_bonus_lott_top = visual.TextStim(win=win, name='crdm_bonus_lott_top',
        text='',
        font='Arial',
        pos=(0.6, 0.2), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    crdm_bonus_img = visual.ImageStim(
        win=win,
        name='crdm_bonus_img', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.6, -0.1), size=(0.3, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    crdm_bonus_lott_bot = visual.TextStim(win=win, name='crdm_bonus_lott_bot',
        text='',
        font='Arial',
        pos=(0.6, -0.4), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    crdm_bonus_sure_amt_txt = visual.TextStim(win=win, name='crdm_bonus_sure_amt_txt',
        text='',
        font='Arial',
        pos=(0.35, -0.1), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    crdm_bonus_prompt_txt = visual.TextStim(win=win, name='crdm_bonus_prompt_txt',
        text='In this trial, you chose:',
        font='Arial',
        pos=(-0.2, 0.2), height=0.04, wrapWidth=1.0, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    crdm_bonus_choice_text_txt = visual.TextStim(win=win, name='crdm_bonus_choice_text_txt',
        text='',
        font='Arial',
        pos=(-0.2, 0.1), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    crdm_bonus_choice_outcome_txt = visual.TextStim(win=win, name='crdm_bonus_choice_outcome_txt',
        text='',
        font='Arial',
        pos=(-0.2, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    crdm_bonus_drawn_txt = visual.TextStim(win=win, name='crdm_bonus_drawn_txt',
        text='',
        font='Arial',
        pos=(-0.2, -0.1), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    crdm_bonus_chip_poly = visual.ShapeStim(
        win=win, name='crdm_bonus_chip_poly',
        size=(0.075, 0.075), vertices='circle',
        ori=0.0, pos=(0, 0), anchor='center',
        lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
        opacity=None, depth=-10.0, interpolate=True)
    crdm_bonus_winnings_txt = visual.TextStim(win=win, name='crdm_bonus_winnings_txt',
        text='',
        font='Arial',
        pos=(-0.2, -0.2), height=0.08, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    crdm_bonus_space_txt = visual.TextStim(win=win, name='crdm_bonus_space_txt',
        text='Press SPACE to receive your *COMPLETION CODE*',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-12.0);
    crdm_bonus_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "cdd_bonus" ---
    cdd_bonus_thanks_txt = visual.TextStim(win=win, name='cdd_bonus_thanks_txt',
        text='Your randomly selected *bonus earnings trial* is from the\nDelay Discounting Task!',
        font='Arial',
        pos=(0, 0.3), height=0.05, wrapWidth=1.35, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    cdd_bonus_box = visual.TextStim(win=win, name='cdd_bonus_box',
        text='',
        font='Arial',
        pos=(0, 0.15), height=0.04, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    cdd_bonus_choice_txt = visual.TextStim(win=win, name='cdd_bonus_choice_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.08, wrapWidth=None, ori=0.0, 
        color=[0.7098, 0.2941, -0.7490], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    cdd_bonus_rather_txt = visual.TextStim(win=win, name='cdd_bonus_rather_txt',
        text='rather than',
        font='Arial',
        pos=(0, -0.125), height=0.04, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    cdd_bonus_other_txt = visual.TextStim(win=win, name='cdd_bonus_other_txt',
        text='',
        font='Arial',
        pos=(0, -0.225), height=0.055, wrapWidth=None, ori=0.0, 
        color=[0.9608, 0.0039, -0.1059], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    cdd_bonus_space_txt = visual.TextStim(win=win, name='cdd_bonus_space_txt',
        text='Press SPACE to receive your *COMPLETION CODE*',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    cdd_bonus_resp = keyboard.Keyboard()
    
    # --- Initialize components for Routine "idm_comp_code" ---
    # Run 'Begin Experiment' code from idm_code_code
    comp_code = ""
    idm_comp_code_header_txt = visual.TextStim(win=win, name='idm_comp_code_header_txt',
        text='Thank you for your participation!\nYour IDM Task Completion Code is:',
        font='Arial',
        pos=(0, 0.25), height=0.05, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    idm_comp_code_num_txt = visual.TextStim(win=win, name='idm_comp_code_num_txt',
        text='',
        font='Arial',
        pos=(0, 0), height=0.08, wrapWidth=None, ori=0.0, 
        color=[0.1216, 0.4745, 0.1216], colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    idm_comp_code_instr_txt = visual.TextStim(win=win, name='idm_comp_code_instr_txt',
        text='Return to Amazon Mechanical Turk and enter the completion code to receive credit for your participation and ensure payment.',
        font='Arial',
        pos=(0, -0.2), height=0.04, wrapWidth=1.25, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    idm_comp_code_space_txt = visual.TextStim(win=win, name='idm_comp_code_space_txt',
        text='Press SPACE to exit session.',
        font='Arial',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    idm_comp_code_key_resp = keyboard.Keyboard()
    
    # create some handy timers
    if globalClock is None:
        globalClock = core.Clock()  # to track the time since experiment started
    if ioServer is not None:
        ioServer.syncClock(globalClock)
    logging.setDefaultClock(globalClock)
    routineTimer = core.Clock()  # to track time remaining of each (possibly non-slip) routine
    win.flip()  # flip window to reset last flip timer
    # store the exact time the global clock started
    expInfo['expStart'] = data.getDateStr(format='%Y-%m-%d %Hh%M.%S.%f %z', fractionalSecondDigits=6)
    
    # --- Prepare to start Routine "idm_consent1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent1.started', globalClock.getTime())
    idm_consent1_resp.keys = []
    idm_consent1_resp.rt = []
    _idm_consent1_resp_allKeys = []
    # keep track of which components have finished
    idm_consent1Components = [idm_consent1_welcome_txt, idm_consent1_info_txt, idm_consent1_space_txt, idm_consent1_resp]
    for thisComponent in idm_consent1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent1_welcome_txt* updates
        
        # if idm_consent1_welcome_txt is starting this frame...
        if idm_consent1_welcome_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent1_welcome_txt.frameNStart = frameN  # exact frame index
            idm_consent1_welcome_txt.tStart = t  # local t and not account for scr refresh
            idm_consent1_welcome_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent1_welcome_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent1_welcome_txt.status = STARTED
            idm_consent1_welcome_txt.setAutoDraw(True)
        
        # if idm_consent1_welcome_txt is active this frame...
        if idm_consent1_welcome_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent1_info_txt* updates
        
        # if idm_consent1_info_txt is starting this frame...
        if idm_consent1_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent1_info_txt.frameNStart = frameN  # exact frame index
            idm_consent1_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent1_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent1_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent1_info_txt.status = STARTED
            idm_consent1_info_txt.setAutoDraw(True)
        
        # if idm_consent1_info_txt is active this frame...
        if idm_consent1_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent1_space_txt* updates
        
        # if idm_consent1_space_txt is starting this frame...
        if idm_consent1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent1_space_txt.frameNStart = frameN  # exact frame index
            idm_consent1_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent1_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent1_space_txt.status = STARTED
            idm_consent1_space_txt.setAutoDraw(True)
        
        # if idm_consent1_space_txt is active this frame...
        if idm_consent1_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent1_resp* updates
        waitOnFlip = False
        
        # if idm_consent1_resp is starting this frame...
        if idm_consent1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent1_resp.frameNStart = frameN  # exact frame index
            idm_consent1_resp.tStart = t  # local t and not account for scr refresh
            idm_consent1_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent1_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent1_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent1_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent1_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent1_resp_allKeys.extend(theseKeys)
            if len(_idm_consent1_resp_allKeys):
                idm_consent1_resp.keys = _idm_consent1_resp_allKeys[-1].name  # just the last key pressed
                idm_consent1_resp.rt = _idm_consent1_resp_allKeys[-1].rt
                idm_consent1_resp.duration = _idm_consent1_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent1" ---
    for thisComponent in idm_consent1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent1.stopped', globalClock.getTime())
    # the Routine "idm_consent1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent2.started', globalClock.getTime())
    idm_consent2_resp.keys = []
    idm_consent2_resp.rt = []
    _idm_consent2_resp_allKeys = []
    # keep track of which components have finished
    idm_consent2Components = [idm_consent2_title_txt, idm_consent2_info_txt, idm_consent2_space_txt, idm_consent2_resp]
    for thisComponent in idm_consent2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent2_title_txt* updates
        
        # if idm_consent2_title_txt is starting this frame...
        if idm_consent2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent2_title_txt.frameNStart = frameN  # exact frame index
            idm_consent2_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent2_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent2_title_txt.status = STARTED
            idm_consent2_title_txt.setAutoDraw(True)
        
        # if idm_consent2_title_txt is active this frame...
        if idm_consent2_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent2_info_txt* updates
        
        # if idm_consent2_info_txt is starting this frame...
        if idm_consent2_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent2_info_txt.frameNStart = frameN  # exact frame index
            idm_consent2_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent2_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent2_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent2_info_txt.status = STARTED
            idm_consent2_info_txt.setAutoDraw(True)
        
        # if idm_consent2_info_txt is active this frame...
        if idm_consent2_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent2_space_txt* updates
        
        # if idm_consent2_space_txt is starting this frame...
        if idm_consent2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent2_space_txt.frameNStart = frameN  # exact frame index
            idm_consent2_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent2_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent2_space_txt.status = STARTED
            idm_consent2_space_txt.setAutoDraw(True)
        
        # if idm_consent2_space_txt is active this frame...
        if idm_consent2_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent2_resp* updates
        waitOnFlip = False
        
        # if idm_consent2_resp is starting this frame...
        if idm_consent2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent2_resp.frameNStart = frameN  # exact frame index
            idm_consent2_resp.tStart = t  # local t and not account for scr refresh
            idm_consent2_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent2_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent2_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent2_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent2_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent2_resp_allKeys.extend(theseKeys)
            if len(_idm_consent2_resp_allKeys):
                idm_consent2_resp.keys = _idm_consent2_resp_allKeys[-1].name  # just the last key pressed
                idm_consent2_resp.rt = _idm_consent2_resp_allKeys[-1].rt
                idm_consent2_resp.duration = _idm_consent2_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent2" ---
    for thisComponent in idm_consent2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent2.stopped', globalClock.getTime())
    # the Routine "idm_consent2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent3.started', globalClock.getTime())
    idm_consent3_resp.keys = []
    idm_consent3_resp.rt = []
    _idm_consent3_resp_allKeys = []
    # keep track of which components have finished
    idm_consent3Components = [idm_consent3_title_txt, idm_consent3_info_txt, idm_consent3_space_txt, idm_consent3_resp]
    for thisComponent in idm_consent3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent3_title_txt* updates
        
        # if idm_consent3_title_txt is starting this frame...
        if idm_consent3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent3_title_txt.frameNStart = frameN  # exact frame index
            idm_consent3_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent3_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent3_title_txt.status = STARTED
            idm_consent3_title_txt.setAutoDraw(True)
        
        # if idm_consent3_title_txt is active this frame...
        if idm_consent3_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent3_info_txt* updates
        
        # if idm_consent3_info_txt is starting this frame...
        if idm_consent3_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent3_info_txt.frameNStart = frameN  # exact frame index
            idm_consent3_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent3_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent3_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent3_info_txt.status = STARTED
            idm_consent3_info_txt.setAutoDraw(True)
        
        # if idm_consent3_info_txt is active this frame...
        if idm_consent3_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent3_space_txt* updates
        
        # if idm_consent3_space_txt is starting this frame...
        if idm_consent3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent3_space_txt.frameNStart = frameN  # exact frame index
            idm_consent3_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent3_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent3_space_txt.status = STARTED
            idm_consent3_space_txt.setAutoDraw(True)
        
        # if idm_consent3_space_txt is active this frame...
        if idm_consent3_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent3_resp* updates
        waitOnFlip = False
        
        # if idm_consent3_resp is starting this frame...
        if idm_consent3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent3_resp.frameNStart = frameN  # exact frame index
            idm_consent3_resp.tStart = t  # local t and not account for scr refresh
            idm_consent3_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent3_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent3_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent3_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent3_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent3_resp_allKeys.extend(theseKeys)
            if len(_idm_consent3_resp_allKeys):
                idm_consent3_resp.keys = _idm_consent3_resp_allKeys[-1].name  # just the last key pressed
                idm_consent3_resp.rt = _idm_consent3_resp_allKeys[-1].rt
                idm_consent3_resp.duration = _idm_consent3_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent3" ---
    for thisComponent in idm_consent3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent3.stopped', globalClock.getTime())
    # the Routine "idm_consent3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent4" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent4.started', globalClock.getTime())
    idm_consent4_resp.keys = []
    idm_consent4_resp.rt = []
    _idm_consent4_resp_allKeys = []
    # keep track of which components have finished
    idm_consent4Components = [idm_consent4_title_txt, idm_consent4_info_txt, idm_consent4_space_txt, idm_consent4_resp]
    for thisComponent in idm_consent4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent4" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent4_title_txt* updates
        
        # if idm_consent4_title_txt is starting this frame...
        if idm_consent4_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent4_title_txt.frameNStart = frameN  # exact frame index
            idm_consent4_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent4_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent4_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent4_title_txt.status = STARTED
            idm_consent4_title_txt.setAutoDraw(True)
        
        # if idm_consent4_title_txt is active this frame...
        if idm_consent4_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent4_info_txt* updates
        
        # if idm_consent4_info_txt is starting this frame...
        if idm_consent4_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent4_info_txt.frameNStart = frameN  # exact frame index
            idm_consent4_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent4_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent4_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent4_info_txt.status = STARTED
            idm_consent4_info_txt.setAutoDraw(True)
        
        # if idm_consent4_info_txt is active this frame...
        if idm_consent4_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent4_space_txt* updates
        
        # if idm_consent4_space_txt is starting this frame...
        if idm_consent4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent4_space_txt.frameNStart = frameN  # exact frame index
            idm_consent4_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent4_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent4_space_txt.status = STARTED
            idm_consent4_space_txt.setAutoDraw(True)
        
        # if idm_consent4_space_txt is active this frame...
        if idm_consent4_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent4_resp* updates
        waitOnFlip = False
        
        # if idm_consent4_resp is starting this frame...
        if idm_consent4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent4_resp.frameNStart = frameN  # exact frame index
            idm_consent4_resp.tStart = t  # local t and not account for scr refresh
            idm_consent4_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent4_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent4_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent4_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent4_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent4_resp_allKeys.extend(theseKeys)
            if len(_idm_consent4_resp_allKeys):
                idm_consent4_resp.keys = _idm_consent4_resp_allKeys[-1].name  # just the last key pressed
                idm_consent4_resp.rt = _idm_consent4_resp_allKeys[-1].rt
                idm_consent4_resp.duration = _idm_consent4_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent4" ---
    for thisComponent in idm_consent4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent4.stopped', globalClock.getTime())
    # the Routine "idm_consent4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent5" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent5.started', globalClock.getTime())
    idm_consent5_resp.keys = []
    idm_consent5_resp.rt = []
    _idm_consent5_resp_allKeys = []
    # keep track of which components have finished
    idm_consent5Components = [idm_consent5_title_txt, idm_consent5_info_txt, idm_consent5_space_txt, idm_consent5_resp]
    for thisComponent in idm_consent5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent5" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent5_title_txt* updates
        
        # if idm_consent5_title_txt is starting this frame...
        if idm_consent5_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent5_title_txt.frameNStart = frameN  # exact frame index
            idm_consent5_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent5_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent5_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent5_title_txt.status = STARTED
            idm_consent5_title_txt.setAutoDraw(True)
        
        # if idm_consent5_title_txt is active this frame...
        if idm_consent5_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent5_info_txt* updates
        
        # if idm_consent5_info_txt is starting this frame...
        if idm_consent5_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent5_info_txt.frameNStart = frameN  # exact frame index
            idm_consent5_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent5_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent5_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent5_info_txt.status = STARTED
            idm_consent5_info_txt.setAutoDraw(True)
        
        # if idm_consent5_info_txt is active this frame...
        if idm_consent5_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent5_space_txt* updates
        
        # if idm_consent5_space_txt is starting this frame...
        if idm_consent5_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent5_space_txt.frameNStart = frameN  # exact frame index
            idm_consent5_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent5_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent5_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent5_space_txt.status = STARTED
            idm_consent5_space_txt.setAutoDraw(True)
        
        # if idm_consent5_space_txt is active this frame...
        if idm_consent5_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent5_resp* updates
        waitOnFlip = False
        
        # if idm_consent5_resp is starting this frame...
        if idm_consent5_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent5_resp.frameNStart = frameN  # exact frame index
            idm_consent5_resp.tStart = t  # local t and not account for scr refresh
            idm_consent5_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent5_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent5_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent5_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent5_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent5_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent5_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent5_resp_allKeys.extend(theseKeys)
            if len(_idm_consent5_resp_allKeys):
                idm_consent5_resp.keys = _idm_consent5_resp_allKeys[-1].name  # just the last key pressed
                idm_consent5_resp.rt = _idm_consent5_resp_allKeys[-1].rt
                idm_consent5_resp.duration = _idm_consent5_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent5" ---
    for thisComponent in idm_consent5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent5.stopped', globalClock.getTime())
    # the Routine "idm_consent5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent6" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent6.started', globalClock.getTime())
    idm_consent6_resp.keys = []
    idm_consent6_resp.rt = []
    _idm_consent6_resp_allKeys = []
    # keep track of which components have finished
    idm_consent6Components = [idm_consent6_title_txt, idm_consent6_info_txt, idm_consent6_space_txt, idm_consent6_resp]
    for thisComponent in idm_consent6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent6" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent6_title_txt* updates
        
        # if idm_consent6_title_txt is starting this frame...
        if idm_consent6_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent6_title_txt.frameNStart = frameN  # exact frame index
            idm_consent6_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent6_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent6_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent6_title_txt.status = STARTED
            idm_consent6_title_txt.setAutoDraw(True)
        
        # if idm_consent6_title_txt is active this frame...
        if idm_consent6_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent6_info_txt* updates
        
        # if idm_consent6_info_txt is starting this frame...
        if idm_consent6_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent6_info_txt.frameNStart = frameN  # exact frame index
            idm_consent6_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent6_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent6_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent6_info_txt.status = STARTED
            idm_consent6_info_txt.setAutoDraw(True)
        
        # if idm_consent6_info_txt is active this frame...
        if idm_consent6_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent6_space_txt* updates
        
        # if idm_consent6_space_txt is starting this frame...
        if idm_consent6_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent6_space_txt.frameNStart = frameN  # exact frame index
            idm_consent6_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent6_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent6_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent6_space_txt.status = STARTED
            idm_consent6_space_txt.setAutoDraw(True)
        
        # if idm_consent6_space_txt is active this frame...
        if idm_consent6_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent6_resp* updates
        waitOnFlip = False
        
        # if idm_consent6_resp is starting this frame...
        if idm_consent6_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent6_resp.frameNStart = frameN  # exact frame index
            idm_consent6_resp.tStart = t  # local t and not account for scr refresh
            idm_consent6_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent6_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent6_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent6_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent6_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent6_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent6_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent6_resp_allKeys.extend(theseKeys)
            if len(_idm_consent6_resp_allKeys):
                idm_consent6_resp.keys = _idm_consent6_resp_allKeys[-1].name  # just the last key pressed
                idm_consent6_resp.rt = _idm_consent6_resp_allKeys[-1].rt
                idm_consent6_resp.duration = _idm_consent6_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent6" ---
    for thisComponent in idm_consent6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent6.stopped', globalClock.getTime())
    # the Routine "idm_consent6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent7" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent7.started', globalClock.getTime())
    idm_consent7_resp.keys = []
    idm_consent7_resp.rt = []
    _idm_consent7_resp_allKeys = []
    # keep track of which components have finished
    idm_consent7Components = [idm_consent7_title_txt, idm_consent7_info_txt, idm_consent7_space_txt, idm_consent7_resp]
    for thisComponent in idm_consent7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent7" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent7_title_txt* updates
        
        # if idm_consent7_title_txt is starting this frame...
        if idm_consent7_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent7_title_txt.frameNStart = frameN  # exact frame index
            idm_consent7_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent7_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent7_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent7_title_txt.status = STARTED
            idm_consent7_title_txt.setAutoDraw(True)
        
        # if idm_consent7_title_txt is active this frame...
        if idm_consent7_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent7_info_txt* updates
        
        # if idm_consent7_info_txt is starting this frame...
        if idm_consent7_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent7_info_txt.frameNStart = frameN  # exact frame index
            idm_consent7_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent7_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent7_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent7_info_txt.status = STARTED
            idm_consent7_info_txt.setAutoDraw(True)
        
        # if idm_consent7_info_txt is active this frame...
        if idm_consent7_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent7_space_txt* updates
        
        # if idm_consent7_space_txt is starting this frame...
        if idm_consent7_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent7_space_txt.frameNStart = frameN  # exact frame index
            idm_consent7_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent7_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent7_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent7_space_txt.status = STARTED
            idm_consent7_space_txt.setAutoDraw(True)
        
        # if idm_consent7_space_txt is active this frame...
        if idm_consent7_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent7_resp* updates
        waitOnFlip = False
        
        # if idm_consent7_resp is starting this frame...
        if idm_consent7_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent7_resp.frameNStart = frameN  # exact frame index
            idm_consent7_resp.tStart = t  # local t and not account for scr refresh
            idm_consent7_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent7_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent7_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent7_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent7_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent7_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent7_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent7_resp_allKeys.extend(theseKeys)
            if len(_idm_consent7_resp_allKeys):
                idm_consent7_resp.keys = _idm_consent7_resp_allKeys[-1].name  # just the last key pressed
                idm_consent7_resp.rt = _idm_consent7_resp_allKeys[-1].rt
                idm_consent7_resp.duration = _idm_consent7_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent7" ---
    for thisComponent in idm_consent7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent7.stopped', globalClock.getTime())
    # the Routine "idm_consent7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent8" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent8.started', globalClock.getTime())
    idm_consent8_resp.keys = []
    idm_consent8_resp.rt = []
    _idm_consent8_resp_allKeys = []
    # keep track of which components have finished
    idm_consent8Components = [idm_consent8_title_txt, idm_consent8_info_txt, idm_consent8_space_txt, idm_consent8_resp]
    for thisComponent in idm_consent8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent8" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent8_title_txt* updates
        
        # if idm_consent8_title_txt is starting this frame...
        if idm_consent8_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent8_title_txt.frameNStart = frameN  # exact frame index
            idm_consent8_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent8_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent8_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent8_title_txt.status = STARTED
            idm_consent8_title_txt.setAutoDraw(True)
        
        # if idm_consent8_title_txt is active this frame...
        if idm_consent8_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent8_info_txt* updates
        
        # if idm_consent8_info_txt is starting this frame...
        if idm_consent8_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent8_info_txt.frameNStart = frameN  # exact frame index
            idm_consent8_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent8_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent8_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent8_info_txt.status = STARTED
            idm_consent8_info_txt.setAutoDraw(True)
        
        # if idm_consent8_info_txt is active this frame...
        if idm_consent8_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent8_space_txt* updates
        
        # if idm_consent8_space_txt is starting this frame...
        if idm_consent8_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent8_space_txt.frameNStart = frameN  # exact frame index
            idm_consent8_space_txt.tStart = t  # local t and not account for scr refresh
            idm_consent8_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent8_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent8_space_txt.status = STARTED
            idm_consent8_space_txt.setAutoDraw(True)
        
        # if idm_consent8_space_txt is active this frame...
        if idm_consent8_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent8_resp* updates
        waitOnFlip = False
        
        # if idm_consent8_resp is starting this frame...
        if idm_consent8_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent8_resp.frameNStart = frameN  # exact frame index
            idm_consent8_resp.tStart = t  # local t and not account for scr refresh
            idm_consent8_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent8_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent8_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent8_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent8_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent8_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent8_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent8_resp_allKeys.extend(theseKeys)
            if len(_idm_consent8_resp_allKeys):
                idm_consent8_resp.keys = _idm_consent8_resp_allKeys[-1].name  # just the last key pressed
                idm_consent8_resp.rt = _idm_consent8_resp_allKeys[-1].rt
                idm_consent8_resp.duration = _idm_consent8_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent8" ---
    for thisComponent in idm_consent8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent8.stopped', globalClock.getTime())
    # the Routine "idm_consent8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_consent9" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_consent9.started', globalClock.getTime())
    idm_consent9_resp.keys = []
    idm_consent9_resp.rt = []
    _idm_consent9_resp_allKeys = []
    # keep track of which components have finished
    idm_consent9Components = [idm_consent9_title_txt, idm_consent9_info_txt, idm_consent9_resp]
    for thisComponent in idm_consent9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_consent9" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_consent9_title_txt* updates
        
        # if idm_consent9_title_txt is starting this frame...
        if idm_consent9_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent9_title_txt.frameNStart = frameN  # exact frame index
            idm_consent9_title_txt.tStart = t  # local t and not account for scr refresh
            idm_consent9_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent9_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent9_title_txt.status = STARTED
            idm_consent9_title_txt.setAutoDraw(True)
        
        # if idm_consent9_title_txt is active this frame...
        if idm_consent9_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent9_info_txt* updates
        
        # if idm_consent9_info_txt is starting this frame...
        if idm_consent9_info_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent9_info_txt.frameNStart = frameN  # exact frame index
            idm_consent9_info_txt.tStart = t  # local t and not account for scr refresh
            idm_consent9_info_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent9_info_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent9_info_txt.status = STARTED
            idm_consent9_info_txt.setAutoDraw(True)
        
        # if idm_consent9_info_txt is active this frame...
        if idm_consent9_info_txt.status == STARTED:
            # update params
            pass
        
        # *idm_consent9_resp* updates
        waitOnFlip = False
        
        # if idm_consent9_resp is starting this frame...
        if idm_consent9_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_consent9_resp.frameNStart = frameN  # exact frame index
            idm_consent9_resp.tStart = t  # local t and not account for scr refresh
            idm_consent9_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_consent9_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_consent9_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_consent9_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_consent9_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_consent9_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_consent9_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_consent9_resp_allKeys.extend(theseKeys)
            if len(_idm_consent9_resp_allKeys):
                idm_consent9_resp.keys = _idm_consent9_resp_allKeys[-1].name  # just the last key pressed
                idm_consent9_resp.rt = _idm_consent9_resp_allKeys[-1].rt
                idm_consent9_resp.duration = _idm_consent9_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_consent9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_consent9" ---
    for thisComponent in idm_consent9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_consent9.stopped', globalClock.getTime())
    # the Routine "idm_consent9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_thanks" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_thanks.started', globalClock.getTime())
    idm_thanks_resp.keys = []
    idm_thanks_resp.rt = []
    _idm_thanks_resp_allKeys = []
    # keep track of which components have finished
    idm_thanksComponents = [idm_thanks_title_txt, idm_thanks_txt, idm_thanks_space_txt, idm_thanks_resp]
    for thisComponent in idm_thanksComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_thanks" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_thanks_title_txt* updates
        
        # if idm_thanks_title_txt is starting this frame...
        if idm_thanks_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_thanks_title_txt.frameNStart = frameN  # exact frame index
            idm_thanks_title_txt.tStart = t  # local t and not account for scr refresh
            idm_thanks_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_thanks_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_thanks_title_txt.status = STARTED
            idm_thanks_title_txt.setAutoDraw(True)
        
        # if idm_thanks_title_txt is active this frame...
        if idm_thanks_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_thanks_txt* updates
        
        # if idm_thanks_txt is starting this frame...
        if idm_thanks_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_thanks_txt.frameNStart = frameN  # exact frame index
            idm_thanks_txt.tStart = t  # local t and not account for scr refresh
            idm_thanks_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_thanks_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_thanks_txt.status = STARTED
            idm_thanks_txt.setAutoDraw(True)
        
        # if idm_thanks_txt is active this frame...
        if idm_thanks_txt.status == STARTED:
            # update params
            pass
        
        # *idm_thanks_space_txt* updates
        
        # if idm_thanks_space_txt is starting this frame...
        if idm_thanks_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_thanks_space_txt.frameNStart = frameN  # exact frame index
            idm_thanks_space_txt.tStart = t  # local t and not account for scr refresh
            idm_thanks_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_thanks_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_thanks_space_txt.status = STARTED
            idm_thanks_space_txt.setAutoDraw(True)
        
        # if idm_thanks_space_txt is active this frame...
        if idm_thanks_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_thanks_resp* updates
        waitOnFlip = False
        
        # if idm_thanks_resp is starting this frame...
        if idm_thanks_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_thanks_resp.frameNStart = frameN  # exact frame index
            idm_thanks_resp.tStart = t  # local t and not account for scr refresh
            idm_thanks_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_thanks_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_thanks_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_thanks_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_thanks_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_thanks_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_thanks_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_thanks_resp_allKeys.extend(theseKeys)
            if len(_idm_thanks_resp_allKeys):
                idm_thanks_resp.keys = _idm_thanks_resp_allKeys[-1].name  # just the last key pressed
                idm_thanks_resp.rt = _idm_thanks_resp_allKeys[-1].rt
                idm_thanks_resp.duration = _idm_thanks_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_thanksComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_thanks" ---
    for thisComponent in idm_thanksComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_thanks.stopped', globalClock.getTime())
    # the Routine "idm_thanks" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_warn1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_warn1.started', globalClock.getTime())
    idm_warn1_resp.keys = []
    idm_warn1_resp.rt = []
    _idm_warn1_resp_allKeys = []
    # keep track of which components have finished
    idm_warn1Components = [idm_warn1_title_txt, idm_warn1_txt, idm_warn1_space_txt, idm_warn1_resp]
    for thisComponent in idm_warn1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_warn1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_warn1_title_txt* updates
        
        # if idm_warn1_title_txt is starting this frame...
        if idm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn1_title_txt.frameNStart = frameN  # exact frame index
            idm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
            idm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn1_title_txt.status = STARTED
            idm_warn1_title_txt.setAutoDraw(True)
        
        # if idm_warn1_title_txt is active this frame...
        if idm_warn1_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn1_txt* updates
        
        # if idm_warn1_txt is starting this frame...
        if idm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn1_txt.frameNStart = frameN  # exact frame index
            idm_warn1_txt.tStart = t  # local t and not account for scr refresh
            idm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn1_txt.status = STARTED
            idm_warn1_txt.setAutoDraw(True)
        
        # if idm_warn1_txt is active this frame...
        if idm_warn1_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn1_space_txt* updates
        
        # if idm_warn1_space_txt is starting this frame...
        if idm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn1_space_txt.frameNStart = frameN  # exact frame index
            idm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
            idm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn1_space_txt.status = STARTED
            idm_warn1_space_txt.setAutoDraw(True)
        
        # if idm_warn1_space_txt is active this frame...
        if idm_warn1_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn1_resp* updates
        waitOnFlip = False
        
        # if idm_warn1_resp is starting this frame...
        if idm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn1_resp.frameNStart = frameN  # exact frame index
            idm_warn1_resp.tStart = t  # local t and not account for scr refresh
            idm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn1_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_warn1_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_warn1_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_warn1_resp_allKeys.extend(theseKeys)
            if len(_idm_warn1_resp_allKeys):
                idm_warn1_resp.keys = _idm_warn1_resp_allKeys[-1].name  # just the last key pressed
                idm_warn1_resp.rt = _idm_warn1_resp_allKeys[-1].rt
                idm_warn1_resp.duration = _idm_warn1_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_warn1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_warn1" ---
    for thisComponent in idm_warn1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_warn1.stopped', globalClock.getTime())
    # the Routine "idm_warn1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_surv1_intro" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_surv1_intro.started', globalClock.getTime())
    idm_surv1_intro_resp.keys = []
    idm_surv1_intro_resp.rt = []
    _idm_surv1_intro_resp_allKeys = []
    # keep track of which components have finished
    idm_surv1_introComponents = [idm_surv1_intro_title_txt, idm_surv1_intro_txt, idm_surv1_intro_space_txt, idm_surv1_intro_resp]
    for thisComponent in idm_surv1_introComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_surv1_intro" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_surv1_intro_title_txt* updates
        
        # if idm_surv1_intro_title_txt is starting this frame...
        if idm_surv1_intro_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv1_intro_title_txt.frameNStart = frameN  # exact frame index
            idm_surv1_intro_title_txt.tStart = t  # local t and not account for scr refresh
            idm_surv1_intro_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv1_intro_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv1_intro_title_txt.status = STARTED
            idm_surv1_intro_title_txt.setAutoDraw(True)
        
        # if idm_surv1_intro_title_txt is active this frame...
        if idm_surv1_intro_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv1_intro_txt* updates
        
        # if idm_surv1_intro_txt is starting this frame...
        if idm_surv1_intro_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv1_intro_txt.frameNStart = frameN  # exact frame index
            idm_surv1_intro_txt.tStart = t  # local t and not account for scr refresh
            idm_surv1_intro_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv1_intro_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv1_intro_txt.status = STARTED
            idm_surv1_intro_txt.setAutoDraw(True)
        
        # if idm_surv1_intro_txt is active this frame...
        if idm_surv1_intro_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv1_intro_space_txt* updates
        
        # if idm_surv1_intro_space_txt is starting this frame...
        if idm_surv1_intro_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv1_intro_space_txt.frameNStart = frameN  # exact frame index
            idm_surv1_intro_space_txt.tStart = t  # local t and not account for scr refresh
            idm_surv1_intro_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv1_intro_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv1_intro_space_txt.status = STARTED
            idm_surv1_intro_space_txt.setAutoDraw(True)
        
        # if idm_surv1_intro_space_txt is active this frame...
        if idm_surv1_intro_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv1_intro_resp* updates
        waitOnFlip = False
        
        # if idm_surv1_intro_resp is starting this frame...
        if idm_surv1_intro_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv1_intro_resp.frameNStart = frameN  # exact frame index
            idm_surv1_intro_resp.tStart = t  # local t and not account for scr refresh
            idm_surv1_intro_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv1_intro_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv1_intro_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_surv1_intro_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_surv1_intro_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_surv1_intro_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_surv1_intro_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_surv1_intro_resp_allKeys.extend(theseKeys)
            if len(_idm_surv1_intro_resp_allKeys):
                idm_surv1_intro_resp.keys = _idm_surv1_intro_resp_allKeys[-1].name  # just the last key pressed
                idm_surv1_intro_resp.rt = _idm_surv1_intro_resp_allKeys[-1].rt
                idm_surv1_intro_resp.duration = _idm_surv1_intro_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_surv1_introComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_surv1_intro" ---
    for thisComponent in idm_surv1_introComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_surv1_intro.stopped', globalClock.getTime())
    # the Routine "idm_surv1_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    survey1 = data.TrialHandler(nReps=1.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions('idm_survey1.xlsx'),
        seed=None, name='survey1')
    thisExp.addLoop(survey1)  # add the loop to the experiment
    thisSurvey1 = survey1.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisSurvey1.rgb)
    if thisSurvey1 != None:
        for paramName in thisSurvey1:
            globals()[paramName] = thisSurvey1[paramName]
    
    for thisSurvey1 in survey1:
        currentLoop = survey1
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisSurvey1.rgb)
        if thisSurvey1 != None:
            for paramName in thisSurvey1:
                globals()[paramName] = thisSurvey1[paramName]
        
        # --- Prepare to start Routine "idm_surv1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_surv1.started', globalClock.getTime())
        # Run 'Begin Routine' code from idm_surv1_code
        survbox1_color = [0,0,0]
        survbox2_color = [0,0,0]
        survbox3_color = [0,0,0]
        survbox4_color = [0,0,0]
        survbox5_color = [0,0,0]
        survbox6_color = [0,0,0]
        font_color1 = [0,0,0]
        font_color2 = [0,0,0]
        font_color3 = [0,0,0]
        font_color4 = [0,0,0]
        font_color5 = [0,0,0]
        font_color6 = [0,0,0]
        resp1_txt = ""
        resp2_txt = ""
        resp3_txt = ""
        resp4_txt = ""
        resp5_txt = ""
        resp6_txt = ""
        
        if resps == 2:
            surv_keylist = ["1", "2"]
            survbox1_color = "white"
            survbox2_color = "white"
            font_color1 = "white"
            font_color2 = "white"
            resp1_txt = resp1
            resp2_txt = resp2
        elif resps == 3:
            surv_keylist = ["1", "2", "3"]
            survbox1_color = "white"
            survbox2_color = "white"
            survbox3_color = "white"
            font_color1 = "white"
            font_color2 = "white"
            font_color3 = "white"
            resp1_txt = resp1
            resp2_txt = resp2
            resp3_txt = resp3
        elif resps == 4:
            surv_keylist = ["1", "2", "3", "4"]
            survbox1_color = "white"
            survbox2_color = "white"
            survbox3_color = "white"
            survbox4_color = "white"
            font_color1 = "white"
            font_color2 = "white"
            font_color3 = "white"
            font_color4 = "white"
            resp1_txt = resp1
            resp2_txt = resp2
            resp3_txt = resp3
            resp4_txt = resp4
        elif resps == 5:
            surv_keylist = ["1", "2", "3", "4", "5"]
            survbox1_color = "white"
            survbox2_color = "white"
            survbox3_color = "white"
            survbox4_color = "white"
            survbox5_color = "white"
            font_color1 = "white"
            font_color2 = "white"
            font_color3 = "white"
            font_color4 = "white"
            font_color5 = "white"
            resp1_txt = resp1
            resp2_txt = resp2
            resp3_txt = resp3
            resp4_txt = resp4
            resp5_txt = resp5
        elif resps == 6:
            surv_keylist = ["1", "2", "3", "4", "5", "6"]
            survbox1_color = "white"
            survbox2_color = "white"
            survbox3_color = "white"
            survbox4_color = "white"
            survbox5_color = "white"
            survbox6_color = "white"
            font_color1 = "white"
            font_color2 = "white"
            font_color3 = "white"
            font_color4 = "white"
            font_color5 = "white"
            font_color6 = "white"
            resp1_txt = resp1
            resp2_txt = resp2
            resp3_txt = resp3
            resp4_txt = resp4
            resp5_txt = resp5
            resp6_txt = resp6
        idm_surv1_question_txt.setText(question)
        idm_surv1_1.setLineColor(survbox1_color)
        idm_surv1_1_txt.setText(resp1_txt)
        idm_surv1_2.setLineColor(survbox2_color)
        idm_surv1_2_txt.setText(resp2_txt)
        idm_surv1_3.setLineColor(survbox3_color)
        idm_surv1_3_txt.setText(resp3_txt)
        idm_surv1_4.setLineColor(survbox4_color)
        idm_surv1_4_txt.setText(resp4_txt)
        idm_surv1_5.setLineColor(survbox5_color)
        idm_surv1_5_txt.setText(resp5_txt)
        idm_surv1_6.setLineColor(survbox6_color)
        idm_surv1_6_txt.setText(resp6_txt)
        idm_surv1_key1.setColor(font_color1, colorSpace='rgb')
        idm_surv1_key2.setColor(font_color2, colorSpace='rgb')
        idm_surv1_key3.setColor(font_color3, colorSpace='rgb')
        idm_surv1_key4.setColor(font_color4, colorSpace='rgb')
        idm_surv1_key5.setColor(font_color5, colorSpace='rgb')
        idm_surv1_key6.setColor(font_color6, colorSpace='rgb')
        idm_surv1_resp.keys = []
        idm_surv1_resp.rt = []
        _idm_surv1_resp_allKeys = []
        # keep track of which components have finished
        idm_surv1Components = [idm_surv1_question_txt, idm_surv1_1, idm_surv1_1_txt, idm_surv1_2, idm_surv1_2_txt, idm_surv1_3, idm_surv1_3_txt, idm_surv1_4, idm_surv1_4_txt, idm_surv1_5, idm_surv1_5_txt, idm_surv1_6, idm_surv1_6_txt, idm_surv1_key1, idm_surv1_key2, idm_surv1_key3, idm_surv1_key4, idm_surv1_key5, idm_surv1_key6, idm_surv1_resp]
        for thisComponent in idm_surv1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_surv1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            # Run 'Each Frame' code from idm_surv1_code
            key = idm_surv1_resp.keys
            
            if resps == 2:
                if key == "1" or key == "2":
                    continueRoutine = False
            elif resps == 3:
                if key == "1" or key == "2" or key == "3":
                    continueRoutine = False
            elif resps == 4:
                if key == "1" or key == "2" or key == "3" or key == "4":
                    continueRoutine = False
            elif resps == 5:
                if key == "1" or key == "2" or key == "3" or key == "4" or key == "5":
                    continueRoutine = False
            elif resps == 6:
                if key == "1" or key == "2" or key == "3" or key == "4" or key == "5" or key == "6":
                    continueRoutine = False
            
            # *idm_surv1_question_txt* updates
            
            # if idm_surv1_question_txt is starting this frame...
            if idm_surv1_question_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_question_txt.frameNStart = frameN  # exact frame index
                idm_surv1_question_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_question_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_question_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_question_txt.status = STARTED
                idm_surv1_question_txt.setAutoDraw(True)
            
            # if idm_surv1_question_txt is active this frame...
            if idm_surv1_question_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_1* updates
            
            # if idm_surv1_1 is starting this frame...
            if idm_surv1_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_1.frameNStart = frameN  # exact frame index
                idm_surv1_1.tStart = t  # local t and not account for scr refresh
                idm_surv1_1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_1, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_1.status = STARTED
                idm_surv1_1.setAutoDraw(True)
            
            # if idm_surv1_1 is active this frame...
            if idm_surv1_1.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_1_txt* updates
            
            # if idm_surv1_1_txt is starting this frame...
            if idm_surv1_1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_1_txt.frameNStart = frameN  # exact frame index
                idm_surv1_1_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_1_txt.status = STARTED
                idm_surv1_1_txt.setAutoDraw(True)
            
            # if idm_surv1_1_txt is active this frame...
            if idm_surv1_1_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_2* updates
            
            # if idm_surv1_2 is starting this frame...
            if idm_surv1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_2.frameNStart = frameN  # exact frame index
                idm_surv1_2.tStart = t  # local t and not account for scr refresh
                idm_surv1_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_2.status = STARTED
                idm_surv1_2.setAutoDraw(True)
            
            # if idm_surv1_2 is active this frame...
            if idm_surv1_2.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_2_txt* updates
            
            # if idm_surv1_2_txt is starting this frame...
            if idm_surv1_2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_2_txt.frameNStart = frameN  # exact frame index
                idm_surv1_2_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_2_txt.status = STARTED
                idm_surv1_2_txt.setAutoDraw(True)
            
            # if idm_surv1_2_txt is active this frame...
            if idm_surv1_2_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_3* updates
            
            # if idm_surv1_3 is starting this frame...
            if idm_surv1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_3.frameNStart = frameN  # exact frame index
                idm_surv1_3.tStart = t  # local t and not account for scr refresh
                idm_surv1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_3, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_3.status = STARTED
                idm_surv1_3.setAutoDraw(True)
            
            # if idm_surv1_3 is active this frame...
            if idm_surv1_3.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_3_txt* updates
            
            # if idm_surv1_3_txt is starting this frame...
            if idm_surv1_3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_3_txt.frameNStart = frameN  # exact frame index
                idm_surv1_3_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_3_txt.status = STARTED
                idm_surv1_3_txt.setAutoDraw(True)
            
            # if idm_surv1_3_txt is active this frame...
            if idm_surv1_3_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_4* updates
            
            # if idm_surv1_4 is starting this frame...
            if idm_surv1_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_4.frameNStart = frameN  # exact frame index
                idm_surv1_4.tStart = t  # local t and not account for scr refresh
                idm_surv1_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_4, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_4.status = STARTED
                idm_surv1_4.setAutoDraw(True)
            
            # if idm_surv1_4 is active this frame...
            if idm_surv1_4.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_4_txt* updates
            
            # if idm_surv1_4_txt is starting this frame...
            if idm_surv1_4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_4_txt.frameNStart = frameN  # exact frame index
                idm_surv1_4_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_4_txt.status = STARTED
                idm_surv1_4_txt.setAutoDraw(True)
            
            # if idm_surv1_4_txt is active this frame...
            if idm_surv1_4_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_5* updates
            
            # if idm_surv1_5 is starting this frame...
            if idm_surv1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_5.frameNStart = frameN  # exact frame index
                idm_surv1_5.tStart = t  # local t and not account for scr refresh
                idm_surv1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_5, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_5.status = STARTED
                idm_surv1_5.setAutoDraw(True)
            
            # if idm_surv1_5 is active this frame...
            if idm_surv1_5.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_5_txt* updates
            
            # if idm_surv1_5_txt is starting this frame...
            if idm_surv1_5_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_5_txt.frameNStart = frameN  # exact frame index
                idm_surv1_5_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_5_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_5_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_5_txt.status = STARTED
                idm_surv1_5_txt.setAutoDraw(True)
            
            # if idm_surv1_5_txt is active this frame...
            if idm_surv1_5_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_6* updates
            
            # if idm_surv1_6 is starting this frame...
            if idm_surv1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_6.frameNStart = frameN  # exact frame index
                idm_surv1_6.tStart = t  # local t and not account for scr refresh
                idm_surv1_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_6, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_6.status = STARTED
                idm_surv1_6.setAutoDraw(True)
            
            # if idm_surv1_6 is active this frame...
            if idm_surv1_6.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_6_txt* updates
            
            # if idm_surv1_6_txt is starting this frame...
            if idm_surv1_6_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_6_txt.frameNStart = frameN  # exact frame index
                idm_surv1_6_txt.tStart = t  # local t and not account for scr refresh
                idm_surv1_6_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_6_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_6_txt.status = STARTED
                idm_surv1_6_txt.setAutoDraw(True)
            
            # if idm_surv1_6_txt is active this frame...
            if idm_surv1_6_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key1* updates
            
            # if idm_surv1_key1 is starting this frame...
            if idm_surv1_key1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key1.frameNStart = frameN  # exact frame index
                idm_surv1_key1.tStart = t  # local t and not account for scr refresh
                idm_surv1_key1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key1, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key1.status = STARTED
                idm_surv1_key1.setAutoDraw(True)
            
            # if idm_surv1_key1 is active this frame...
            if idm_surv1_key1.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key2* updates
            
            # if idm_surv1_key2 is starting this frame...
            if idm_surv1_key2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key2.frameNStart = frameN  # exact frame index
                idm_surv1_key2.tStart = t  # local t and not account for scr refresh
                idm_surv1_key2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key2, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key2.status = STARTED
                idm_surv1_key2.setAutoDraw(True)
            
            # if idm_surv1_key2 is active this frame...
            if idm_surv1_key2.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key3* updates
            
            # if idm_surv1_key3 is starting this frame...
            if idm_surv1_key3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key3.frameNStart = frameN  # exact frame index
                idm_surv1_key3.tStart = t  # local t and not account for scr refresh
                idm_surv1_key3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key3, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key3.status = STARTED
                idm_surv1_key3.setAutoDraw(True)
            
            # if idm_surv1_key3 is active this frame...
            if idm_surv1_key3.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key4* updates
            
            # if idm_surv1_key4 is starting this frame...
            if idm_surv1_key4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key4.frameNStart = frameN  # exact frame index
                idm_surv1_key4.tStart = t  # local t and not account for scr refresh
                idm_surv1_key4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key4, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key4.status = STARTED
                idm_surv1_key4.setAutoDraw(True)
            
            # if idm_surv1_key4 is active this frame...
            if idm_surv1_key4.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key5* updates
            
            # if idm_surv1_key5 is starting this frame...
            if idm_surv1_key5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key5.frameNStart = frameN  # exact frame index
                idm_surv1_key5.tStart = t  # local t and not account for scr refresh
                idm_surv1_key5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key5, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key5.status = STARTED
                idm_surv1_key5.setAutoDraw(True)
            
            # if idm_surv1_key5 is active this frame...
            if idm_surv1_key5.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_key6* updates
            
            # if idm_surv1_key6 is starting this frame...
            if idm_surv1_key6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_key6.frameNStart = frameN  # exact frame index
                idm_surv1_key6.tStart = t  # local t and not account for scr refresh
                idm_surv1_key6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_key6, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_key6.status = STARTED
                idm_surv1_key6.setAutoDraw(True)
            
            # if idm_surv1_key6 is active this frame...
            if idm_surv1_key6.status == STARTED:
                # update params
                pass
            
            # *idm_surv1_resp* updates
            waitOnFlip = False
            
            # if idm_surv1_resp is starting this frame...
            if idm_surv1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv1_resp.frameNStart = frameN  # exact frame index
                idm_surv1_resp.tStart = t  # local t and not account for scr refresh
                idm_surv1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(idm_surv1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(idm_surv1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if idm_surv1_resp.status == STARTED and not waitOnFlip:
                theseKeys = idm_surv1_resp.getKeys(keyList=["1", "2", "3", "4", "5", "6"], ignoreKeys=["escape"], waitRelease=False)
                _idm_surv1_resp_allKeys.extend(theseKeys)
                if len(_idm_surv1_resp_allKeys):
                    idm_surv1_resp.keys = _idm_surv1_resp_allKeys[-1].name  # just the last key pressed
                    idm_surv1_resp.rt = _idm_surv1_resp_allKeys[-1].rt
                    idm_surv1_resp.duration = _idm_surv1_resp_allKeys[-1].duration
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_surv1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_surv1" ---
        for thisComponent in idm_surv1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_surv1.stopped', globalClock.getTime())
        # Run 'End Routine' code from idm_surv1_code
        surv_key = idm_surv1_resp.keys
        
        if surv_key == "1":
            survey1.addData("surv1_resp", resp1)
        elif surv_key == "2":
            survey1.addData("surv1_resp", resp2)
        elif surv_key == "3":
            survey1.addData("surv1_resp", resp3)
        elif surv_key == "4":
            survey1.addData("surv1_resp", resp4)
        elif surv_key == "5":
            survey1.addData("surv1_resp", resp5)
        elif surv_key == "6":
            survey1.addData("surv1_resp", resp6)
        
        # check responses
        if idm_surv1_resp.keys in ['', [], None]:  # No response was made
            idm_surv1_resp.keys = None
        survey1.addData('idm_surv1_resp.keys',idm_surv1_resp.keys)
        if idm_surv1_resp.keys != None:  # we had a response
            survey1.addData('idm_surv1_resp.rt', idm_surv1_resp.rt)
            survey1.addData('idm_surv1_resp.duration', idm_surv1_resp.duration)
        # the Routine "idm_surv1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 1.0 repeats of 'survey1'
    
    
    # --- Prepare to start Routine "idm_surv2_intro" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_surv2_intro.started', globalClock.getTime())
    idm_surv2_intro_resp.keys = []
    idm_surv2_intro_resp.rt = []
    _idm_surv2_intro_resp_allKeys = []
    # keep track of which components have finished
    idm_surv2_introComponents = [idm_surv2_intro_title_txt, idm_surv2_intro_txt, idm_surv2_intro_space_txt, idm_surv2_intro_resp]
    for thisComponent in idm_surv2_introComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_surv2_intro" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_surv2_intro_title_txt* updates
        
        # if idm_surv2_intro_title_txt is starting this frame...
        if idm_surv2_intro_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv2_intro_title_txt.frameNStart = frameN  # exact frame index
            idm_surv2_intro_title_txt.tStart = t  # local t and not account for scr refresh
            idm_surv2_intro_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv2_intro_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv2_intro_title_txt.status = STARTED
            idm_surv2_intro_title_txt.setAutoDraw(True)
        
        # if idm_surv2_intro_title_txt is active this frame...
        if idm_surv2_intro_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv2_intro_txt* updates
        
        # if idm_surv2_intro_txt is starting this frame...
        if idm_surv2_intro_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv2_intro_txt.frameNStart = frameN  # exact frame index
            idm_surv2_intro_txt.tStart = t  # local t and not account for scr refresh
            idm_surv2_intro_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv2_intro_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv2_intro_txt.status = STARTED
            idm_surv2_intro_txt.setAutoDraw(True)
        
        # if idm_surv2_intro_txt is active this frame...
        if idm_surv2_intro_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv2_intro_space_txt* updates
        
        # if idm_surv2_intro_space_txt is starting this frame...
        if idm_surv2_intro_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv2_intro_space_txt.frameNStart = frameN  # exact frame index
            idm_surv2_intro_space_txt.tStart = t  # local t and not account for scr refresh
            idm_surv2_intro_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv2_intro_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv2_intro_space_txt.status = STARTED
            idm_surv2_intro_space_txt.setAutoDraw(True)
        
        # if idm_surv2_intro_space_txt is active this frame...
        if idm_surv2_intro_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_surv2_intro_resp* updates
        waitOnFlip = False
        
        # if idm_surv2_intro_resp is starting this frame...
        if idm_surv2_intro_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_surv2_intro_resp.frameNStart = frameN  # exact frame index
            idm_surv2_intro_resp.tStart = t  # local t and not account for scr refresh
            idm_surv2_intro_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_surv2_intro_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_surv2_intro_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_surv2_intro_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_surv2_intro_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_surv2_intro_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_surv2_intro_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_surv2_intro_resp_allKeys.extend(theseKeys)
            if len(_idm_surv2_intro_resp_allKeys):
                idm_surv2_intro_resp.keys = _idm_surv2_intro_resp_allKeys[-1].name  # just the last key pressed
                idm_surv2_intro_resp.rt = _idm_surv2_intro_resp_allKeys[-1].rt
                idm_surv2_intro_resp.duration = _idm_surv2_intro_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_surv2_introComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_surv2_intro" ---
    for thisComponent in idm_surv2_introComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_surv2_intro.stopped', globalClock.getTime())
    # the Routine "idm_surv2_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    survey2 = data.TrialHandler(nReps=1.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions('idm_survey2.xlsx'),
        seed=None, name='survey2')
    thisExp.addLoop(survey2)  # add the loop to the experiment
    thisSurvey2 = survey2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisSurvey2.rgb)
    if thisSurvey2 != None:
        for paramName in thisSurvey2:
            globals()[paramName] = thisSurvey2[paramName]
    
    for thisSurvey2 in survey2:
        currentLoop = survey2
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisSurvey2.rgb)
        if thisSurvey2 != None:
            for paramName in thisSurvey2:
                globals()[paramName] = thisSurvey2[paramName]
        
        # --- Prepare to start Routine "idm_surv2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_surv2.started', globalClock.getTime())
        idm_surv2_question_txt.setText(question)
        idm_surv2_resp.keys = []
        idm_surv2_resp.rt = []
        _idm_surv2_resp_allKeys = []
        # keep track of which components have finished
        idm_surv2Components = [idm_surv2_stim_txt, idm_surv2_question_txt, idm_surv2_1, idm_surv2_1_txt, idm_surv2_2, idm_surv2_2_txt, idm_surv2_3, idm_surv2_3_txt, idm_surv2_4, idm_surv2_4_txt, idm_surv2_5, idm_surv2_5_txt, idm_surv2_key1, idm_surv2_key2, idm_surv2_key3, idm_surv2_key4, idm_surv2_key5, idm_surv2_resp]
        for thisComponent in idm_surv2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_surv2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *idm_surv2_stim_txt* updates
            
            # if idm_surv2_stim_txt is starting this frame...
            if idm_surv2_stim_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_stim_txt.frameNStart = frameN  # exact frame index
                idm_surv2_stim_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_stim_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_stim_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_stim_txt.status = STARTED
                idm_surv2_stim_txt.setAutoDraw(True)
            
            # if idm_surv2_stim_txt is active this frame...
            if idm_surv2_stim_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_question_txt* updates
            
            # if idm_surv2_question_txt is starting this frame...
            if idm_surv2_question_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_question_txt.frameNStart = frameN  # exact frame index
                idm_surv2_question_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_question_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_question_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_question_txt.status = STARTED
                idm_surv2_question_txt.setAutoDraw(True)
            
            # if idm_surv2_question_txt is active this frame...
            if idm_surv2_question_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_1* updates
            
            # if idm_surv2_1 is starting this frame...
            if idm_surv2_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_1.frameNStart = frameN  # exact frame index
                idm_surv2_1.tStart = t  # local t and not account for scr refresh
                idm_surv2_1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_1, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_1.status = STARTED
                idm_surv2_1.setAutoDraw(True)
            
            # if idm_surv2_1 is active this frame...
            if idm_surv2_1.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_1_txt* updates
            
            # if idm_surv2_1_txt is starting this frame...
            if idm_surv2_1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_1_txt.frameNStart = frameN  # exact frame index
                idm_surv2_1_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_1_txt.status = STARTED
                idm_surv2_1_txt.setAutoDraw(True)
            
            # if idm_surv2_1_txt is active this frame...
            if idm_surv2_1_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_2* updates
            
            # if idm_surv2_2 is starting this frame...
            if idm_surv2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_2.frameNStart = frameN  # exact frame index
                idm_surv2_2.tStart = t  # local t and not account for scr refresh
                idm_surv2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_2.status = STARTED
                idm_surv2_2.setAutoDraw(True)
            
            # if idm_surv2_2 is active this frame...
            if idm_surv2_2.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_2_txt* updates
            
            # if idm_surv2_2_txt is starting this frame...
            if idm_surv2_2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_2_txt.frameNStart = frameN  # exact frame index
                idm_surv2_2_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_2_txt.status = STARTED
                idm_surv2_2_txt.setAutoDraw(True)
            
            # if idm_surv2_2_txt is active this frame...
            if idm_surv2_2_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_3* updates
            
            # if idm_surv2_3 is starting this frame...
            if idm_surv2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_3.frameNStart = frameN  # exact frame index
                idm_surv2_3.tStart = t  # local t and not account for scr refresh
                idm_surv2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_3, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_3.status = STARTED
                idm_surv2_3.setAutoDraw(True)
            
            # if idm_surv2_3 is active this frame...
            if idm_surv2_3.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_3_txt* updates
            
            # if idm_surv2_3_txt is starting this frame...
            if idm_surv2_3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_3_txt.frameNStart = frameN  # exact frame index
                idm_surv2_3_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_3_txt.status = STARTED
                idm_surv2_3_txt.setAutoDraw(True)
            
            # if idm_surv2_3_txt is active this frame...
            if idm_surv2_3_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_4* updates
            
            # if idm_surv2_4 is starting this frame...
            if idm_surv2_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_4.frameNStart = frameN  # exact frame index
                idm_surv2_4.tStart = t  # local t and not account for scr refresh
                idm_surv2_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_4, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_4.status = STARTED
                idm_surv2_4.setAutoDraw(True)
            
            # if idm_surv2_4 is active this frame...
            if idm_surv2_4.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_4_txt* updates
            
            # if idm_surv2_4_txt is starting this frame...
            if idm_surv2_4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_4_txt.frameNStart = frameN  # exact frame index
                idm_surv2_4_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_4_txt.status = STARTED
                idm_surv2_4_txt.setAutoDraw(True)
            
            # if idm_surv2_4_txt is active this frame...
            if idm_surv2_4_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_5* updates
            
            # if idm_surv2_5 is starting this frame...
            if idm_surv2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_5.frameNStart = frameN  # exact frame index
                idm_surv2_5.tStart = t  # local t and not account for scr refresh
                idm_surv2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_5, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_5.status = STARTED
                idm_surv2_5.setAutoDraw(True)
            
            # if idm_surv2_5 is active this frame...
            if idm_surv2_5.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_5_txt* updates
            
            # if idm_surv2_5_txt is starting this frame...
            if idm_surv2_5_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_5_txt.frameNStart = frameN  # exact frame index
                idm_surv2_5_txt.tStart = t  # local t and not account for scr refresh
                idm_surv2_5_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_5_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_5_txt.status = STARTED
                idm_surv2_5_txt.setAutoDraw(True)
            
            # if idm_surv2_5_txt is active this frame...
            if idm_surv2_5_txt.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_key1* updates
            
            # if idm_surv2_key1 is starting this frame...
            if idm_surv2_key1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_key1.frameNStart = frameN  # exact frame index
                idm_surv2_key1.tStart = t  # local t and not account for scr refresh
                idm_surv2_key1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_key1, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_key1.status = STARTED
                idm_surv2_key1.setAutoDraw(True)
            
            # if idm_surv2_key1 is active this frame...
            if idm_surv2_key1.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_key2* updates
            
            # if idm_surv2_key2 is starting this frame...
            if idm_surv2_key2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_key2.frameNStart = frameN  # exact frame index
                idm_surv2_key2.tStart = t  # local t and not account for scr refresh
                idm_surv2_key2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_key2, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_key2.status = STARTED
                idm_surv2_key2.setAutoDraw(True)
            
            # if idm_surv2_key2 is active this frame...
            if idm_surv2_key2.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_key3* updates
            
            # if idm_surv2_key3 is starting this frame...
            if idm_surv2_key3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_key3.frameNStart = frameN  # exact frame index
                idm_surv2_key3.tStart = t  # local t and not account for scr refresh
                idm_surv2_key3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_key3, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_key3.status = STARTED
                idm_surv2_key3.setAutoDraw(True)
            
            # if idm_surv2_key3 is active this frame...
            if idm_surv2_key3.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_key4* updates
            
            # if idm_surv2_key4 is starting this frame...
            if idm_surv2_key4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_key4.frameNStart = frameN  # exact frame index
                idm_surv2_key4.tStart = t  # local t and not account for scr refresh
                idm_surv2_key4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_key4, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_key4.status = STARTED
                idm_surv2_key4.setAutoDraw(True)
            
            # if idm_surv2_key4 is active this frame...
            if idm_surv2_key4.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_key5* updates
            
            # if idm_surv2_key5 is starting this frame...
            if idm_surv2_key5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_key5.frameNStart = frameN  # exact frame index
                idm_surv2_key5.tStart = t  # local t and not account for scr refresh
                idm_surv2_key5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_key5, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_key5.status = STARTED
                idm_surv2_key5.setAutoDraw(True)
            
            # if idm_surv2_key5 is active this frame...
            if idm_surv2_key5.status == STARTED:
                # update params
                pass
            
            # *idm_surv2_resp* updates
            waitOnFlip = False
            
            # if idm_surv2_resp is starting this frame...
            if idm_surv2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                idm_surv2_resp.frameNStart = frameN  # exact frame index
                idm_surv2_resp.tStart = t  # local t and not account for scr refresh
                idm_surv2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(idm_surv2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                idm_surv2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(idm_surv2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(idm_surv2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if idm_surv2_resp.status == STARTED and not waitOnFlip:
                theseKeys = idm_surv2_resp.getKeys(keyList=["1", "2", "3", "4", "5"], ignoreKeys=["escape"], waitRelease=False)
                _idm_surv2_resp_allKeys.extend(theseKeys)
                if len(_idm_surv2_resp_allKeys):
                    idm_surv2_resp.keys = _idm_surv2_resp_allKeys[-1].name  # just the last key pressed
                    idm_surv2_resp.rt = _idm_surv2_resp_allKeys[-1].rt
                    idm_surv2_resp.duration = _idm_surv2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_surv2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_surv2" ---
        for thisComponent in idm_surv2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_surv2.stopped', globalClock.getTime())
        # Run 'End Routine' code from idm_surv2_code_2
        surv_key = idm_surv2_resp.keys
        
        if surv_key == "1":
            survey2.addData("surv2_resp", resp1)
        elif surv_key == "2":
            survey2.addData("surv2_resp", resp2)
        elif surv_key == "3":
            survey2.addData("surv2_resp", resp3)
        elif surv_key == "4":
            survey2.addData("surv2_resp", resp4)
        elif surv_key == "5":
            survey2.addData("surv2_resp", resp5)
        
        
        # check responses
        if idm_surv2_resp.keys in ['', [], None]:  # No response was made
            idm_surv2_resp.keys = None
        survey2.addData('idm_surv2_resp.keys',idm_surv2_resp.keys)
        if idm_surv2_resp.keys != None:  # we had a response
            survey2.addData('idm_surv2_resp.rt', idm_surv2_resp.rt)
            survey2.addData('idm_surv2_resp.duration', idm_surv2_resp.duration)
        # the Routine "idm_surv2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 1.0 repeats of 'survey2'
    
    
    # --- Prepare to start Routine "idm_instr1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_instr1.started', globalClock.getTime())
    idm_instr1_resp.keys = []
    idm_instr1_resp.rt = []
    _idm_instr1_resp_allKeys = []
    # keep track of which components have finished
    idm_instr1Components = [idm_instr1_title_txt, idm_instr1_txt, idm_instr1_space_txt, idm_instr1_resp]
    for thisComponent in idm_instr1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_instr1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_instr1_title_txt* updates
        
        # if idm_instr1_title_txt is starting this frame...
        if idm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr1_title_txt.frameNStart = frameN  # exact frame index
            idm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
            idm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr1_title_txt.status = STARTED
            idm_instr1_title_txt.setAutoDraw(True)
        
        # if idm_instr1_title_txt is active this frame...
        if idm_instr1_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr1_txt* updates
        
        # if idm_instr1_txt is starting this frame...
        if idm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr1_txt.frameNStart = frameN  # exact frame index
            idm_instr1_txt.tStart = t  # local t and not account for scr refresh
            idm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr1_txt.status = STARTED
            idm_instr1_txt.setAutoDraw(True)
        
        # if idm_instr1_txt is active this frame...
        if idm_instr1_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr1_space_txt* updates
        
        # if idm_instr1_space_txt is starting this frame...
        if idm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr1_space_txt.frameNStart = frameN  # exact frame index
            idm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
            idm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr1_space_txt.status = STARTED
            idm_instr1_space_txt.setAutoDraw(True)
        
        # if idm_instr1_space_txt is active this frame...
        if idm_instr1_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr1_resp* updates
        waitOnFlip = False
        
        # if idm_instr1_resp is starting this frame...
        if idm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr1_resp.frameNStart = frameN  # exact frame index
            idm_instr1_resp.tStart = t  # local t and not account for scr refresh
            idm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr1_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_instr1_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_instr1_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_instr1_resp_allKeys.extend(theseKeys)
            if len(_idm_instr1_resp_allKeys):
                idm_instr1_resp.keys = _idm_instr1_resp_allKeys[-1].name  # just the last key pressed
                idm_instr1_resp.rt = _idm_instr1_resp_allKeys[-1].rt
                idm_instr1_resp.duration = _idm_instr1_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_instr1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_instr1" ---
    for thisComponent in idm_instr1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_instr1.stopped', globalClock.getTime())
    # the Routine "idm_instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_instr2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_instr2.started', globalClock.getTime())
    idm_instr2_resp.keys = []
    idm_instr2_resp.rt = []
    _idm_instr2_resp_allKeys = []
    # keep track of which components have finished
    idm_instr2Components = [idm_instr2_title_txt, idm_instr2_cursor_txt, idm_instr2_space_txt, idm_instr2_resp]
    for thisComponent in idm_instr2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_instr2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_instr2_title_txt* updates
        
        # if idm_instr2_title_txt is starting this frame...
        if idm_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr2_title_txt.frameNStart = frameN  # exact frame index
            idm_instr2_title_txt.tStart = t  # local t and not account for scr refresh
            idm_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr2_title_txt.status = STARTED
            idm_instr2_title_txt.setAutoDraw(True)
        
        # if idm_instr2_title_txt is active this frame...
        if idm_instr2_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr2_cursor_txt* updates
        
        # if idm_instr2_cursor_txt is starting this frame...
        if idm_instr2_cursor_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr2_cursor_txt.frameNStart = frameN  # exact frame index
            idm_instr2_cursor_txt.tStart = t  # local t and not account for scr refresh
            idm_instr2_cursor_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr2_cursor_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr2_cursor_txt.status = STARTED
            idm_instr2_cursor_txt.setAutoDraw(True)
        
        # if idm_instr2_cursor_txt is active this frame...
        if idm_instr2_cursor_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr2_space_txt* updates
        
        # if idm_instr2_space_txt is starting this frame...
        if idm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr2_space_txt.frameNStart = frameN  # exact frame index
            idm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
            idm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr2_space_txt.status = STARTED
            idm_instr2_space_txt.setAutoDraw(True)
        
        # if idm_instr2_space_txt is active this frame...
        if idm_instr2_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_instr2_resp* updates
        waitOnFlip = False
        
        # if idm_instr2_resp is starting this frame...
        if idm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_instr2_resp.frameNStart = frameN  # exact frame index
            idm_instr2_resp.tStart = t  # local t and not account for scr refresh
            idm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_instr2_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_instr2_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_instr2_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_instr2_resp_allKeys.extend(theseKeys)
            if len(_idm_instr2_resp_allKeys):
                idm_instr2_resp.keys = _idm_instr2_resp_allKeys[-1].name  # just the last key pressed
                idm_instr2_resp.rt = _idm_instr2_resp_allKeys[-1].rt
                idm_instr2_resp.duration = _idm_instr2_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_instr2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_instr2" ---
    for thisComponent in idm_instr2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_instr2.stopped', globalClock.getTime())
    # the Routine "idm_instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_warn2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_warn2.started', globalClock.getTime())
    idm_warn2_resp.keys = []
    idm_warn2_resp.rt = []
    _idm_warn2_resp_allKeys = []
    # keep track of which components have finished
    idm_warn2Components = [idm_warn2_title_txt, idm_warn2_warning_txt, idm_warn2_space_txt, idm_warn2_resp]
    for thisComponent in idm_warn2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_warn2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_warn2_title_txt* updates
        
        # if idm_warn2_title_txt is starting this frame...
        if idm_warn2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn2_title_txt.frameNStart = frameN  # exact frame index
            idm_warn2_title_txt.tStart = t  # local t and not account for scr refresh
            idm_warn2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn2_title_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn2_title_txt.status = STARTED
            idm_warn2_title_txt.setAutoDraw(True)
        
        # if idm_warn2_title_txt is active this frame...
        if idm_warn2_title_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn2_warning_txt* updates
        
        # if idm_warn2_warning_txt is starting this frame...
        if idm_warn2_warning_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn2_warning_txt.frameNStart = frameN  # exact frame index
            idm_warn2_warning_txt.tStart = t  # local t and not account for scr refresh
            idm_warn2_warning_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn2_warning_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn2_warning_txt.status = STARTED
            idm_warn2_warning_txt.setAutoDraw(True)
        
        # if idm_warn2_warning_txt is active this frame...
        if idm_warn2_warning_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn2_space_txt* updates
        
        # if idm_warn2_space_txt is starting this frame...
        if idm_warn2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn2_space_txt.frameNStart = frameN  # exact frame index
            idm_warn2_space_txt.tStart = t  # local t and not account for scr refresh
            idm_warn2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn2_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn2_space_txt.status = STARTED
            idm_warn2_space_txt.setAutoDraw(True)
        
        # if idm_warn2_space_txt is active this frame...
        if idm_warn2_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_warn2_resp* updates
        waitOnFlip = False
        
        # if idm_warn2_resp is starting this frame...
        if idm_warn2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_warn2_resp.frameNStart = frameN  # exact frame index
            idm_warn2_resp.tStart = t  # local t and not account for scr refresh
            idm_warn2_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_warn2_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_warn2_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_warn2_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_warn2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_warn2_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_warn2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_warn2_resp_allKeys.extend(theseKeys)
            if len(_idm_warn2_resp_allKeys):
                idm_warn2_resp.keys = _idm_warn2_resp_allKeys[-1].name  # just the last key pressed
                idm_warn2_resp.rt = _idm_warn2_resp_allKeys[-1].rt
                idm_warn2_resp.duration = _idm_warn2_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_warn2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_warn2" ---
    for thisComponent in idm_warn2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_warn2.stopped', globalClock.getTime())
    # the Routine "idm_warn2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    should_run1 = data.TrialHandler(nReps=loop1, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run1')
    thisExp.addLoop(should_run1)  # add the loop to the experiment
    thisShould_run1 = should_run1.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run1.rgb)
    if thisShould_run1 != None:
        for paramName in thisShould_run1:
            globals()[paramName] = thisShould_run1[paramName]
    
    for thisShould_run1 in should_run1:
        currentLoop = should_run1
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run1.rgb)
        if thisShould_run1 != None:
            for paramName in thisShould_run1:
                globals()[paramName] = thisShould_run1[paramName]
        
        # --- Prepare to start Routine "cpdm_namer1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_namer1.started', globalClock.getTime())
        # Run 'Begin Routine' code from cpdm_namer1_code
        #provides specific loop names for each of three interations of CPDM
        #to provide flexibility of cpdm_pract_trial and cpdm_trial routines
        practice_loop_name = "cpdm_pract_trials1"
        loop_name = "cpdm_trials1"
        # keep track of which components have finished
        cpdm_namer1Components = []
        for thisComponent in cpdm_namer1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_namer1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_namer1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_namer1" ---
        for thisComponent in cpdm_namer1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_namer1.stopped', globalClock.getTime())
        # the Routine "cpdm_namer1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr1.started', globalClock.getTime())
        cpdm_instr1_resp.keys = []
        cpdm_instr1_resp.rt = []
        _cpdm_instr1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr1Components = [cpdm_instr1_img, cpdm_instr1_title_txt, cpdm_instr1_txt, cpdm_instr1_Q_txt, cpdm_instr1_P_txt, cpdm_instr1_A_txt, cpdm_instr1_L_txt, cpdm_instr1_space_txt, cpdm_instr1_resp]
        for thisComponent in cpdm_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr1_img* updates
            
            # if cpdm_instr1_img is starting this frame...
            if cpdm_instr1_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_img.frameNStart = frameN  # exact frame index
                cpdm_instr1_img.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_img.status = STARTED
                cpdm_instr1_img.setAutoDraw(True)
            
            # if cpdm_instr1_img is active this frame...
            if cpdm_instr1_img.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_title_txt* updates
            
            # if cpdm_instr1_title_txt is starting this frame...
            if cpdm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_title_txt.status = STARTED
                cpdm_instr1_title_txt.setAutoDraw(True)
            
            # if cpdm_instr1_title_txt is active this frame...
            if cpdm_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_txt* updates
            
            # if cpdm_instr1_txt is starting this frame...
            if cpdm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_txt.status = STARTED
                cpdm_instr1_txt.setAutoDraw(True)
            
            # if cpdm_instr1_txt is active this frame...
            if cpdm_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_Q_txt* updates
            
            # if cpdm_instr1_Q_txt is starting this frame...
            if cpdm_instr1_Q_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_Q_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_Q_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_Q_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_Q_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_Q_txt.status = STARTED
                cpdm_instr1_Q_txt.setAutoDraw(True)
            
            # if cpdm_instr1_Q_txt is active this frame...
            if cpdm_instr1_Q_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_P_txt* updates
            
            # if cpdm_instr1_P_txt is starting this frame...
            if cpdm_instr1_P_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_P_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_P_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_P_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_P_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_P_txt.status = STARTED
                cpdm_instr1_P_txt.setAutoDraw(True)
            
            # if cpdm_instr1_P_txt is active this frame...
            if cpdm_instr1_P_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_A_txt* updates
            
            # if cpdm_instr1_A_txt is starting this frame...
            if cpdm_instr1_A_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_A_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_A_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_A_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_A_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_A_txt.status = STARTED
                cpdm_instr1_A_txt.setAutoDraw(True)
            
            # if cpdm_instr1_A_txt is active this frame...
            if cpdm_instr1_A_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_L_txt* updates
            
            # if cpdm_instr1_L_txt is starting this frame...
            if cpdm_instr1_L_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_L_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_L_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_L_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_L_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_L_txt.status = STARTED
                cpdm_instr1_L_txt.setAutoDraw(True)
            
            # if cpdm_instr1_L_txt is active this frame...
            if cpdm_instr1_L_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_space_txt* updates
            
            # if cpdm_instr1_space_txt is starting this frame...
            if cpdm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_space_txt.status = STARTED
                cpdm_instr1_space_txt.setAutoDraw(True)
            
            # if cpdm_instr1_space_txt is active this frame...
            if cpdm_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr1_resp is starting this frame...
            if cpdm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_resp.frameNStart = frameN  # exact frame index
                cpdm_instr1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr1_resp_allKeys):
                    cpdm_instr1_resp.keys = _cpdm_instr1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr1_resp.rt = _cpdm_instr1_resp_allKeys[-1].rt
                    cpdm_instr1_resp.duration = _cpdm_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr1" ---
        for thisComponent in cpdm_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr1.stopped', globalClock.getTime())
        # the Routine "cpdm_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr2.started', globalClock.getTime())
        cpdm_instr2_resp.keys = []
        cpdm_instr2_resp.rt = []
        _cpdm_instr2_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr2Components = [cpdm_instr2_title_txt, cpdm_instr2_instr_txt, cpdm_instr2_left_arrow, cpdm_instr2_left_gabor, cpdm_instr2_left_txt, cpdm_instr2_right_arrow, cpdm_instr2_right_gabor, cpdm_instr2_right_txt, cpdm_instr2_space_txt, cpdm_instr2_resp]
        for thisComponent in cpdm_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr2_title_txt* updates
            
            # if cpdm_instr2_title_txt is starting this frame...
            if cpdm_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_title_txt.status = STARTED
                cpdm_instr2_title_txt.setAutoDraw(True)
            
            # if cpdm_instr2_title_txt is active this frame...
            if cpdm_instr2_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_instr_txt* updates
            
            # if cpdm_instr2_instr_txt is starting this frame...
            if cpdm_instr2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_instr_txt.status = STARTED
                cpdm_instr2_instr_txt.setAutoDraw(True)
            
            # if cpdm_instr2_instr_txt is active this frame...
            if cpdm_instr2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_arrow* updates
            
            # if cpdm_instr2_left_arrow is starting this frame...
            if cpdm_instr2_left_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_arrow.status = STARTED
                cpdm_instr2_left_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_left_arrow is active this frame...
            if cpdm_instr2_left_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_gabor* updates
            
            # if cpdm_instr2_left_gabor is starting this frame...
            if cpdm_instr2_left_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_gabor.status = STARTED
                cpdm_instr2_left_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_left_gabor is active this frame...
            if cpdm_instr2_left_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_txt* updates
            
            # if cpdm_instr2_left_txt is starting this frame...
            if cpdm_instr2_left_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_txt.status = STARTED
                cpdm_instr2_left_txt.setAutoDraw(True)
            
            # if cpdm_instr2_left_txt is active this frame...
            if cpdm_instr2_left_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_arrow* updates
            
            # if cpdm_instr2_right_arrow is starting this frame...
            if cpdm_instr2_right_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_arrow.status = STARTED
                cpdm_instr2_right_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_right_arrow is active this frame...
            if cpdm_instr2_right_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_gabor* updates
            
            # if cpdm_instr2_right_gabor is starting this frame...
            if cpdm_instr2_right_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_gabor.status = STARTED
                cpdm_instr2_right_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_right_gabor is active this frame...
            if cpdm_instr2_right_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_txt* updates
            
            # if cpdm_instr2_right_txt is starting this frame...
            if cpdm_instr2_right_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_txt.status = STARTED
                cpdm_instr2_right_txt.setAutoDraw(True)
            
            # if cpdm_instr2_right_txt is active this frame...
            if cpdm_instr2_right_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_space_txt* updates
            
            # if cpdm_instr2_space_txt is starting this frame...
            if cpdm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_space_txt.status = STARTED
                cpdm_instr2_space_txt.setAutoDraw(True)
            
            # if cpdm_instr2_space_txt is active this frame...
            if cpdm_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr2_resp is starting this frame...
            if cpdm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_resp.frameNStart = frameN  # exact frame index
                cpdm_instr2_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr2_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr2_resp_allKeys):
                    cpdm_instr2_resp.keys = _cpdm_instr2_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr2_resp.rt = _cpdm_instr2_resp_allKeys[-1].rt
                    cpdm_instr2_resp.duration = _cpdm_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr2" ---
        for thisComponent in cpdm_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr2.stopped', globalClock.getTime())
        # the Routine "cpdm_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr3.started', globalClock.getTime())
        cpdm_instr3_resp.keys = []
        cpdm_instr3_resp.rt = []
        _cpdm_instr3_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr3Components = [cpdm_instr3_title_txt, cpdm_instr3_txt, cpdm_instr3_space_txt, cpdm_instr3_resp]
        for thisComponent in cpdm_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr3_title_txt* updates
            
            # if cpdm_instr3_title_txt is starting this frame...
            if cpdm_instr3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_title_txt.status = STARTED
                cpdm_instr3_title_txt.setAutoDraw(True)
            
            # if cpdm_instr3_title_txt is active this frame...
            if cpdm_instr3_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_txt* updates
            
            # if cpdm_instr3_txt is starting this frame...
            if cpdm_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_txt.status = STARTED
                cpdm_instr3_txt.setAutoDraw(True)
            
            # if cpdm_instr3_txt is active this frame...
            if cpdm_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_space_txt* updates
            
            # if cpdm_instr3_space_txt is starting this frame...
            if cpdm_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_space_txt.status = STARTED
                cpdm_instr3_space_txt.setAutoDraw(True)
            
            # if cpdm_instr3_space_txt is active this frame...
            if cpdm_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr3_resp is starting this frame...
            if cpdm_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_resp.frameNStart = frameN  # exact frame index
                cpdm_instr3_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr3_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr3_resp_allKeys):
                    cpdm_instr3_resp.keys = _cpdm_instr3_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr3_resp.rt = _cpdm_instr3_resp_allKeys[-1].rt
                    cpdm_instr3_resp.duration = _cpdm_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr3" ---
        for thisComponent in cpdm_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr3.stopped', globalClock.getTime())
        # the Routine "cpdm_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr4.started', globalClock.getTime())
        cpdm_instr4_resp.keys = []
        cpdm_instr4_resp.rt = []
        _cpdm_instr4_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr4Components = [cpdm_instr4_title_txt, cpdm_instr4_txt, cpdm_instr4_space_txt, cpdm_instr4_resp]
        for thisComponent in cpdm_instr4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr4_title_txt* updates
            
            # if cpdm_instr4_title_txt is starting this frame...
            if cpdm_instr4_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_title_txt.status = STARTED
                cpdm_instr4_title_txt.setAutoDraw(True)
            
            # if cpdm_instr4_title_txt is active this frame...
            if cpdm_instr4_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_txt* updates
            
            # if cpdm_instr4_txt is starting this frame...
            if cpdm_instr4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_txt.status = STARTED
                cpdm_instr4_txt.setAutoDraw(True)
            
            # if cpdm_instr4_txt is active this frame...
            if cpdm_instr4_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_space_txt* updates
            
            # if cpdm_instr4_space_txt is starting this frame...
            if cpdm_instr4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_space_txt.status = STARTED
                cpdm_instr4_space_txt.setAutoDraw(True)
            
            # if cpdm_instr4_space_txt is active this frame...
            if cpdm_instr4_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr4_resp is starting this frame...
            if cpdm_instr4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_resp.frameNStart = frameN  # exact frame index
                cpdm_instr4_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr4_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr4_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr4_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr4_resp_allKeys):
                    cpdm_instr4_resp.keys = _cpdm_instr4_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr4_resp.rt = _cpdm_instr4_resp_allKeys[-1].rt
                    cpdm_instr4_resp.duration = _cpdm_instr4_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr4" ---
        for thisComponent in cpdm_instr4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr4.stopped', globalClock.getTime())
        # the Routine "cpdm_instr4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_warn.started', globalClock.getTime())
        cpdm_warn1_resp.keys = []
        cpdm_warn1_resp.rt = []
        _cpdm_warn1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_warnComponents = [cpdm_warn1_title_txt, cpdm_warn1_txt, cpdm_warn1_space_txt, cpdm_warn1_resp]
        for thisComponent in cpdm_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_warn1_title_txt* updates
            
            # if cpdm_warn1_title_txt is starting this frame...
            if cpdm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_title_txt.status = STARTED
                cpdm_warn1_title_txt.setAutoDraw(True)
            
            # if cpdm_warn1_title_txt is active this frame...
            if cpdm_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_txt* updates
            
            # if cpdm_warn1_txt is starting this frame...
            if cpdm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_txt.status = STARTED
                cpdm_warn1_txt.setAutoDraw(True)
            
            # if cpdm_warn1_txt is active this frame...
            if cpdm_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_space_txt* updates
            
            # if cpdm_warn1_space_txt is starting this frame...
            if cpdm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_space_txt.status = STARTED
                cpdm_warn1_space_txt.setAutoDraw(True)
            
            # if cpdm_warn1_space_txt is active this frame...
            if cpdm_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_resp* updates
            waitOnFlip = False
            
            # if cpdm_warn1_resp is starting this frame...
            if cpdm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_resp.frameNStart = frameN  # exact frame index
                cpdm_warn1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_warn1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_warn1_resp_allKeys):
                    cpdm_warn1_resp.keys = _cpdm_warn1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_warn1_resp.rt = _cpdm_warn1_resp_allKeys[-1].rt
                    cpdm_warn1_resp.duration = _cpdm_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_warn" ---
        for thisComponent in cpdm_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_warn.stopped', globalClock.getTime())
        # the Routine "cpdm_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_pract_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_pract_instr.started', globalClock.getTime())
        cpdm_pract_instr_resp.keys = []
        cpdm_pract_instr_resp.rt = []
        _cpdm_pract_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_pract_instrComponents = [cpdm_pract_instr_title_txt, cpdm_pract_instr_txt, cpdm_pract_instr_space_txt, cpdm_pract_instr_resp]
        for thisComponent in cpdm_pract_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_pract_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_pract_instr_title_txt* updates
            
            # if cpdm_pract_instr_title_txt is starting this frame...
            if cpdm_pract_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_title_txt.status = STARTED
                cpdm_pract_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_title_txt is active this frame...
            if cpdm_pract_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_txt* updates
            
            # if cpdm_pract_instr_txt is starting this frame...
            if cpdm_pract_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_txt.status = STARTED
                cpdm_pract_instr_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_txt is active this frame...
            if cpdm_pract_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_space_txt* updates
            
            # if cpdm_pract_instr_space_txt is starting this frame...
            if cpdm_pract_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_space_txt.status = STARTED
                cpdm_pract_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_space_txt is active this frame...
            if cpdm_pract_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_pract_instr_resp is starting this frame...
            if cpdm_pract_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_pract_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_pract_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_pract_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_pract_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_pract_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_pract_instr_resp_allKeys):
                    cpdm_pract_instr_resp.keys = _cpdm_pract_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_pract_instr_resp.rt = _cpdm_pract_instr_resp_allKeys[-1].rt
                    cpdm_pract_instr_resp.duration = _cpdm_pract_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_pract_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_pract_instr" ---
        for thisComponent in cpdm_pract_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_pract_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_pract_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cpdm_init_fixComponents = [cpdm_init_fix_poly]
        for thisComponent in cpdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_init_fix_poly* updates
            
            # if cpdm_init_fix_poly is starting this frame...
            if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_init_fix_poly.status = STARTED
                cpdm_init_fix_poly.setAutoDraw(True)
            
            # if cpdm_init_fix_poly is active this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if cpdm_init_fix_poly is stopping this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    cpdm_init_fix_poly.status = FINISHED
                    cpdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_init_fix" ---
        for thisComponent in cpdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cpdm_pract_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_practice.xlsx'),
            seed=None, name='cpdm_pract_trials1')
        thisExp.addLoop(cpdm_pract_trials1)  # add the loop to the experiment
        thisCpdm_pract_trials1 = cpdm_pract_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials1.rgb)
        if thisCpdm_pract_trials1 != None:
            for paramName in thisCpdm_pract_trials1:
                globals()[paramName] = thisCpdm_pract_trials1[paramName]
        
        for thisCpdm_pract_trials1 in cpdm_pract_trials1:
            currentLoop = cpdm_pract_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials1.rgb)
            if thisCpdm_pract_trials1 != None:
                for paramName in thisCpdm_pract_trials1:
                    globals()[paramName] = thisCpdm_pract_trials1[paramName]
            
            # --- Prepare to start Routine "cpdm_pract_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_trial_code
            my_loop = eval(practice_loop_name)
            trial_acc = 0
            trial_conf = 0 
            
            #set default gray for all four response boxes
            left_high_color = [0,0,0] 
            left_low_color = [0,0,0]
            right_high_color = [0,0,0]
            right_low_color = [0,0,0]
            
            is_clockwise = False 
            if cpdm_gabor_orient > 0.0: 
                is_clockwise = True
            elif cpdm_gabor_orient == 0.0: 
                rand_num = random.randint(1,2)
                if rand_num == 1:
                    is_clockwise = True
                else:
                    is_clockwise = False
            cpdm_pract_trial_gabor.setContrast(cpdm_gabor_contrast)
            cpdm_pract_trial_gabor.setOri(cpdm_gabor_orient)
            cpdm_pract_trial_resp.keys = []
            cpdm_pract_trial_resp.rt = []
            _cpdm_pract_trial_resp_allKeys = []
            # keep track of which components have finished
            cpdm_pract_trialComponents = [cpdm_pract_trial_gabor, cpdm_pract_trial_left_high_poly, cpdm_pract_trial_right_high_poly, cpdm_pract_trial_left_low_poly, cpdm_pract_trial_right_low_poly, cpdm_pract_trial_left_high_txt, cpdm_pract_trial_right_high_txt, cpdm_pract_trial_left_low_txt, cpdm_pract_trial_right_low_txt, cpdm_pract_trial_resp]
            for thisComponent in cpdm_pract_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.3:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cpdm_pract_trial_code
                #each trial and resp
                #checks which key Ss pressed and changed the color of the selected box
                #depending on correctness of selection
                #also changes correct_resp variable which is recorded in End Routine
                
                #resp is received
                key = cpdm_pract_trial_resp.keys
                if len(key) == 1: 
                    #Ss selected Left-High
                    if key == "q": 
                        trial_conf = 1
                        #and correct resp is Left
                        if is_clockwise == False: 
                            #change upper-left box to green
                            left_high_color = "green" 
                            #set correct resp to 1
                            trial_acc = 1 
                        #incorrect left resp
                        else: 
                            left_high_color = "red"
                    elif key == "a":
                        #correct left resp
                        if is_clockwise == False: 
                            left_low_color = "green"
                            trial_acc = 1
                        else:
                            left_low_color = "red"
                    elif key == "p":
                        trial_conf = 1
                        #correct right resp
                        if is_clockwise == True: 
                            right_high_color = "green"
                            trial_acc = 1
                            trial_conf = 1
                        #incorrect right resp
                        else: 
                            right_high_color = "red"
                    elif key == "l":
                        #correct right resp
                        if is_clockwise == True: 
                            right_low_color = "green"
                            trial_acc = 1
                        #incorrect right resp
                        else: 
                            right_low_color = "red"
                
                # *cpdm_pract_trial_gabor* updates
                
                # if cpdm_pract_trial_gabor is starting this frame...
                if cpdm_pract_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_gabor.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_gabor.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_gabor.status = STARTED
                    cpdm_pract_trial_gabor.setAutoDraw(True)
                
                # if cpdm_pract_trial_gabor is active this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_gabor is stopping this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_gabor.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_gabor.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_gabor.status = FINISHED
                        cpdm_pract_trial_gabor.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_poly* updates
                
                # if cpdm_pract_trial_left_high_poly is starting this frame...
                if cpdm_pract_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_poly.status = STARTED
                    cpdm_pract_trial_left_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_poly is active this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_high_poly.setFillColor(left_high_color, log=False)
                
                # if cpdm_pract_trial_left_high_poly is stopping this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_poly.status = FINISHED
                        cpdm_pract_trial_left_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_poly* updates
                
                # if cpdm_pract_trial_right_high_poly is starting this frame...
                if cpdm_pract_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_poly.status = STARTED
                    cpdm_pract_trial_right_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_poly is active this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_high_poly.setFillColor(right_high_color, log=False)
                
                # if cpdm_pract_trial_right_high_poly is stopping this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_poly.status = FINISHED
                        cpdm_pract_trial_right_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_poly* updates
                
                # if cpdm_pract_trial_left_low_poly is starting this frame...
                if cpdm_pract_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_poly.status = STARTED
                    cpdm_pract_trial_left_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_poly is active this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_low_poly.setFillColor(left_low_color, log=False)
                
                # if cpdm_pract_trial_left_low_poly is stopping this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_poly.status = FINISHED
                        cpdm_pract_trial_left_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_poly* updates
                
                # if cpdm_pract_trial_right_low_poly is starting this frame...
                if cpdm_pract_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_poly.status = STARTED
                    cpdm_pract_trial_right_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_poly is active this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_low_poly.setFillColor(right_low_color, log=False)
                
                # if cpdm_pract_trial_right_low_poly is stopping this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_poly.status = FINISHED
                        cpdm_pract_trial_right_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_txt* updates
                
                # if cpdm_pract_trial_left_high_txt is starting this frame...
                if cpdm_pract_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_txt.status = STARTED
                    cpdm_pract_trial_left_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_txt is active this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_high_txt is stopping this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_txt.status = FINISHED
                        cpdm_pract_trial_left_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_txt* updates
                
                # if cpdm_pract_trial_right_high_txt is starting this frame...
                if cpdm_pract_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_txt.status = STARTED
                    cpdm_pract_trial_right_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_txt is active this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_high_txt is stopping this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_txt.status = FINISHED
                        cpdm_pract_trial_right_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_txt* updates
                
                # if cpdm_pract_trial_left_low_txt is starting this frame...
                if cpdm_pract_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_txt.status = STARTED
                    cpdm_pract_trial_left_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_txt is active this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_low_txt is stopping this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_txt.status = FINISHED
                        cpdm_pract_trial_left_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_txt* updates
                
                # if cpdm_pract_trial_right_low_txt is starting this frame...
                if cpdm_pract_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_txt.status = STARTED
                    cpdm_pract_trial_right_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_txt is active this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_low_txt is stopping this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_txt.status = FINISHED
                        cpdm_pract_trial_right_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_resp* updates
                waitOnFlip = False
                
                # if cpdm_pract_trial_resp is starting this frame...
                if cpdm_pract_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_resp.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_pract_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_pract_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cpdm_pract_trial_resp is stopping this frame...
                if cpdm_pract_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_resp.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_resp.status = FINISHED
                        cpdm_pract_trial_resp.status = FINISHED
                if cpdm_pract_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_pract_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_pract_trial_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_pract_trial_resp_allKeys):
                        cpdm_pract_trial_resp.keys = _cpdm_pract_trial_resp_allKeys[0].name  # just the first key pressed
                        cpdm_pract_trial_resp.rt = _cpdm_pract_trial_resp_allKeys[0].rt
                        cpdm_pract_trial_resp.duration = _cpdm_pract_trial_resp_allKeys[0].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_trial" ---
            for thisComponent in cpdm_pract_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_pract_trial_code
            my_loop.addData("cpdm_pract_acc", trial_acc)
            my_loop.addData("cpdm_pract_conf", trial_conf)
            my_loop.addData("cpdm_trial_type", "practice")
            
            # check responses
            if cpdm_pract_trial_resp.keys in ['', [], None]:  # No response was made
                cpdm_pract_trial_resp.keys = None
            cpdm_pract_trials1.addData('cpdm_pract_trial_resp.keys',cpdm_pract_trial_resp.keys)
            if cpdm_pract_trial_resp.keys != None:  # we had a response
                cpdm_pract_trials1.addData('cpdm_pract_trial_resp.rt', cpdm_pract_trial_resp.rt)
                cpdm_pract_trials1.addData('cpdm_pract_trial_resp.duration', cpdm_pract_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.300000)
            
            # --- Prepare to start Routine "cpdm_pract_iti1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_iti1.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_iti1_code
            #5 CPDM practice trials
            if cpdm_pract_trials1.thisTrialN == 4:
                continueRoutine = False
            # keep track of which components have finished
            cpdm_pract_iti1Components = [cpdm_pract_iti1_poly]
            for thisComponent in cpdm_pract_iti1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_iti1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_pract_iti1_poly* updates
                
                # if cpdm_pract_iti1_poly is starting this frame...
                if cpdm_pract_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_iti1_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_iti1_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_iti1_poly.status = STARTED
                    cpdm_pract_iti1_poly.setAutoDraw(True)
                
                # if cpdm_pract_iti1_poly is active this frame...
                if cpdm_pract_iti1_poly.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_iti1_poly is stopping this frame...
                if cpdm_pract_iti1_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_iti1_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_iti1_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_iti1_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_iti1_poly.status = FINISHED
                        cpdm_pract_iti1_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_iti1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_iti1" ---
            for thisComponent in cpdm_pract_iti1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_iti1.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cpdm_pract_trials1'
        
        
        # --- Prepare to start Routine "cpdm_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_trial_instr.started', globalClock.getTime())
        cpdm_trial_instr_resp.keys = []
        cpdm_trial_instr_resp.rt = []
        _cpdm_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_trial_instrComponents = [cpdm_trial_instr_title_txt, cpdm_trial_instr_txt, cpdm_trial_instr_space_txt, cpdm_trial_instr_resp]
        for thisComponent in cpdm_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_trial_instr_title_txt* updates
            
            # if cpdm_trial_instr_title_txt is starting this frame...
            if cpdm_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_title_txt.status = STARTED
                cpdm_trial_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_title_txt is active this frame...
            if cpdm_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_txt* updates
            
            # if cpdm_trial_instr_txt is starting this frame...
            if cpdm_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_txt.status = STARTED
                cpdm_trial_instr_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_txt is active this frame...
            if cpdm_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_space_txt* updates
            
            # if cpdm_trial_instr_space_txt is starting this frame...
            if cpdm_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_space_txt.status = STARTED
                cpdm_trial_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_space_txt is active this frame...
            if cpdm_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_trial_instr_resp is starting this frame...
            if cpdm_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_trial_instr_resp_allKeys):
                    cpdm_trial_instr_resp.keys = _cpdm_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_trial_instr_resp.rt = _cpdm_trial_instr_resp_allKeys[-1].rt
                    cpdm_trial_instr_resp.duration = _cpdm_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_trial_instr" ---
        for thisComponent in cpdm_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_trial_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        condition_runs1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_run_type.xlsx'),
            seed=None, name='condition_runs1')
        thisExp.addLoop(condition_runs1)  # add the loop to the experiment
        thisCondition_runs1 = condition_runs1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs1.rgb)
        if thisCondition_runs1 != None:
            for paramName in thisCondition_runs1:
                globals()[paramName] = thisCondition_runs1[paramName]
        
        for thisCondition_runs1 in condition_runs1:
            currentLoop = condition_runs1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs1.rgb)
            if thisCondition_runs1 != None:
                for paramName in thisCondition_runs1:
                    globals()[paramName] = thisCondition_runs1[paramName]
            
            # --- Prepare to start Routine "cpdm_run_setter" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_setter.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_setter_code
            #Block QC check variables
            run_resps = []
            cpdm_catch_trials = []
            
            #selects contrast schedule depending on run type
            #low volatility
            run_schedule = "cpdm/cpdm-1contrast.xlsx" 
            
            #flexible response text for high confidence options depending on run type
            if "low_risk" in cpdm_run_dimension:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $9 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $9 or $0"
            else:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $13 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $13 or $0"
            
            #create list of 200 random ITIs
            #iterate through list of ITIs, multiple by number of floats, divide by sum of original list
            #creates random list of ITI value for each trial which sum to 200
            cpdm_iti_list = [random.random() for i in range(200)] 
            cpdm_s = sum(cpdm_iti_list) 
            cpdm_iti_list = [i*200/cpdm_s for i in cpdm_iti_list]
            # keep track of which components have finished
            cpdm_run_setterComponents = []
            for thisComponent in cpdm_run_setterComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_setter" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_setterComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_setter" ---
            for thisComponent in cpdm_run_setterComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_setter.stopped', globalClock.getTime())
            # the Routine "cpdm_run_setter" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_loop_instr" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_loop_instr.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_loop_instr_code
            if "low_risk" in cpdm_run_dimension:
                corr_high_txt = "Correct \n High Confidence \n $9"
            else:
                corr_high_txt = "Correct \n High Confidence \n $13"
            cpdm_loop_instr_code2.setText("Block " + str(run_counter))
            cpdm_loop_instr_corr_high_txt.setText(corr_high_txt)
            cpdm_loop_instr_resp.keys = []
            cpdm_loop_instr_resp.rt = []
            _cpdm_loop_instr_resp_allKeys = []
            # keep track of which components have finished
            cpdm_loop_instrComponents = [cpdm_loop_instr_code2, cpdm_loop_instr_corr_high_poly, cpdm_loop_instr_right_high_poly, cpdm_loop_instr_left_low_poly, cpdm_loop_instr_right_low_poly, cpdm_loop_instr_corr_high_txt, cpdm_loop_instr_incorr_high_txt, cpdm_loop_instr_corr_low_txt, cpdm_loop_instr_incorr_low, cpdm_loop_instr_space_txt, cpdm_loop_instr_resp]
            for thisComponent in cpdm_loop_instrComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_loop_instr" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_loop_instr_code2* updates
                
                # if cpdm_loop_instr_code2 is starting this frame...
                if cpdm_loop_instr_code2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_code2.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_code2.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_code2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_code2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_code2.status = STARTED
                    cpdm_loop_instr_code2.setAutoDraw(True)
                
                # if cpdm_loop_instr_code2 is active this frame...
                if cpdm_loop_instr_code2.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_poly* updates
                
                # if cpdm_loop_instr_corr_high_poly is starting this frame...
                if cpdm_loop_instr_corr_high_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_poly.status = STARTED
                    cpdm_loop_instr_corr_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_poly is active this frame...
                if cpdm_loop_instr_corr_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_high_poly* updates
                
                # if cpdm_loop_instr_right_high_poly is starting this frame...
                if cpdm_loop_instr_right_high_poly.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_high_poly.status = STARTED
                    cpdm_loop_instr_right_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_high_poly is active this frame...
                if cpdm_loop_instr_right_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_left_low_poly* updates
                
                # if cpdm_loop_instr_left_low_poly is starting this frame...
                if cpdm_loop_instr_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_left_low_poly.status = STARTED
                    cpdm_loop_instr_left_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_left_low_poly is active this frame...
                if cpdm_loop_instr_left_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_low_poly* updates
                
                # if cpdm_loop_instr_right_low_poly is starting this frame...
                if cpdm_loop_instr_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_low_poly.status = STARTED
                    cpdm_loop_instr_right_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_low_poly is active this frame...
                if cpdm_loop_instr_right_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_txt* updates
                
                # if cpdm_loop_instr_corr_high_txt is starting this frame...
                if cpdm_loop_instr_corr_high_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_txt.status = STARTED
                    cpdm_loop_instr_corr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_txt is active this frame...
                if cpdm_loop_instr_corr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_high_txt* updates
                
                # if cpdm_loop_instr_incorr_high_txt is starting this frame...
                if cpdm_loop_instr_incorr_high_txt.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_high_txt.status = STARTED
                    cpdm_loop_instr_incorr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_high_txt is active this frame...
                if cpdm_loop_instr_incorr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_low_txt* updates
                
                # if cpdm_loop_instr_corr_low_txt is starting this frame...
                if cpdm_loop_instr_corr_low_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_low_txt.status = STARTED
                    cpdm_loop_instr_corr_low_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_low_txt is active this frame...
                if cpdm_loop_instr_corr_low_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_low* updates
                
                # if cpdm_loop_instr_incorr_low is starting this frame...
                if cpdm_loop_instr_incorr_low.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_low.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_low.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_low.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_low, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_low.status = STARTED
                    cpdm_loop_instr_incorr_low.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_low is active this frame...
                if cpdm_loop_instr_incorr_low.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_space_txt* updates
                
                # if cpdm_loop_instr_space_txt is starting this frame...
                if cpdm_loop_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_space_txt.status = STARTED
                    cpdm_loop_instr_space_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_space_txt is active this frame...
                if cpdm_loop_instr_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_resp* updates
                waitOnFlip = False
                
                # if cpdm_loop_instr_resp is starting this frame...
                if cpdm_loop_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_resp.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_loop_instr_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_loop_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_loop_instr_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_loop_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_loop_instr_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_loop_instr_resp_allKeys):
                        cpdm_loop_instr_resp.keys = _cpdm_loop_instr_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_loop_instr_resp.rt = _cpdm_loop_instr_resp_allKeys[-1].rt
                        cpdm_loop_instr_resp.duration = _cpdm_loop_instr_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_loop_instrComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_loop_instr" ---
            for thisComponent in cpdm_loop_instrComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_loop_instr.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_loop_instr_code
            run_counter += 1
            # the Routine "cpdm_loop_instr" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_init_fix" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
            # keep track of which components have finished
            cpdm_init_fixComponents = [cpdm_init_fix_poly]
            for thisComponent in cpdm_init_fixComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_init_fix" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_init_fix_poly* updates
                
                # if cpdm_init_fix_poly is starting this frame...
                if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                    cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_init_fix_poly.status = STARTED
                    cpdm_init_fix_poly.setAutoDraw(True)
                
                # if cpdm_init_fix_poly is active this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_init_fix_poly is stopping this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                        cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_init_fix_poly.status = FINISHED
                        cpdm_init_fix_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_init_fixComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_init_fix" ---
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # set up handler to look after randomisation of conditions etc
            cpdm_trials1 = data.TrialHandler(nReps=1.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=data.importConditions('cpdm/cpdm-1contrast.xlsx'),
                seed=None, name='cpdm_trials1')
            thisExp.addLoop(cpdm_trials1)  # add the loop to the experiment
            thisCpdm_trials1 = cpdm_trials1.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials1.rgb)
            if thisCpdm_trials1 != None:
                for paramName in thisCpdm_trials1:
                    globals()[paramName] = thisCpdm_trials1[paramName]
            
            for thisCpdm_trials1 in cpdm_trials1:
                currentLoop = cpdm_trials1
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials1.rgb)
                if thisCpdm_trials1 != None:
                    for paramName in thisCpdm_trials1:
                        globals()[paramName] = thisCpdm_trials1[paramName]
                
                # --- Prepare to start Routine "cpdm_trial" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trial.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trial_code
                my_loop = eval(cpdm_loop_name)
                cpdm_stop_timer = None
                cpdm_stopped_time = 0
                cpdm_trial_acc = 0
                cpdm_trial_conf = 0 
                
                #set default gray for all four response boxes
                left_high_color = [0,0,0] 
                left_low_color = [0,0,0]
                right_high_color = [0,0,0]
                right_low_color = [0,0,0]
                
                is_clockwise = False
                if cpdm_gabor_orient > 0.0: 
                    is_clockwise = True
                elif cpdm_gabor_orient == 0.0: 
                    cpdm_rand_num = random.randint(1,2)
                    if cpdm_rand_num == 1:
                        is_clockwise = True
                    else:
                        is_clockwise = False
                cpdm_trial_gabor.setContrast(cpdm_gabor_contrast)
                cpdm_trial_gabor.setOri(cpdm_gabor_orient)
                cpdm_trial_left_high_txt.setText(left_resp_txt)
                cpdm_trial_right_high_txt.setText(right_resp_txt)
                cpdm_trial_resp.keys = []
                cpdm_trial_resp.rt = []
                _cpdm_trial_resp_allKeys = []
                # keep track of which components have finished
                cpdm_trialComponents = [cpdm_trial_gabor, cpdm_trial_left_high_poly, cpdm_trial_right_high_poly, cpdm_trial_left_low_poly, cpdm_trial_right_low_poly, cpdm_trial_left_high_txt, cpdm_trial_right_high_txt, cpdm_trial_left_low_txt, cpdm_trial_right_low_txt, cpdm_trial_resp]
                for thisComponent in cpdm_trialComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trial" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 2.3:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    # Run 'Each Frame' code from cpdm_trial_code
                    #checks if resp is received for each trial and which key was pressed
                    #depending on which key is pressed, respective box color changes and
                    #correct_resp variable is updated if correct (preassigned to 0)
                    key = cpdm_trial_resp.keys
                    if len(key) == 1:
                        if stop_timer == None:
                            stop_timer = core.Clock() 
                        else:
                            stopped_time = stop_timer.getTime()
                            if stopped_time >= 0.5:
                                continueRoutine = False
                        #Left - High Confidence
                        if key == "q":
                            trial_conf = 1
                            #correct left resp
                            if is_clockwise == False: 
                                #indicates selection without performance feedback
                                left_high_color = "darkgray" 
                                #indicate correct resp for current trial
                                trial_acc = 1 
                            #incorrect left resp
                            else: 
                                left_high_color = "darkgray"
                        #Left - Low Confidence
                        elif key == "a":
                            #correct left resp
                            if is_clockwise == False: 
                                left_low_color = "darkgray"
                                trial_acc = 1
                            else:
                                left_low_color = "darkgray"
                        #Right - High Confidence
                        elif key == "p":
                            trial_conf = 1
                            #correct right resp
                            if is_clockwise == True: 
                                right_high_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_high_color = "darkgray"
                        #Right - Low Confidence
                        elif key == "l": 
                            #correct right resp
                            if is_clockwise == True: 
                                right_low_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_low_color = "darkgray"
                    
                    # *cpdm_trial_gabor* updates
                    
                    # if cpdm_trial_gabor is starting this frame...
                    if cpdm_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_gabor.frameNStart = frameN  # exact frame index
                        cpdm_trial_gabor.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.started')
                        # update status
                        cpdm_trial_gabor.status = STARTED
                        cpdm_trial_gabor.setAutoDraw(True)
                    
                    # if cpdm_trial_gabor is active this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_gabor is stopping this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_gabor.tStop = t  # not accounting for scr refresh
                            cpdm_trial_gabor.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.stopped')
                            # update status
                            cpdm_trial_gabor.status = FINISHED
                            cpdm_trial_gabor.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_poly* updates
                    
                    # if cpdm_trial_left_high_poly is starting this frame...
                    if cpdm_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_poly.status = STARTED
                        cpdm_trial_left_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_poly is active this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_high_poly.setFillColor(left_high_color, log=False)
                    
                    # if cpdm_trial_left_high_poly is stopping this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_poly.status = FINISHED
                            cpdm_trial_left_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_poly* updates
                    
                    # if cpdm_trial_right_high_poly is starting this frame...
                    if cpdm_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_poly.status = STARTED
                        cpdm_trial_right_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_poly is active this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_high_poly.setFillColor(right_high_color, log=False)
                    
                    # if cpdm_trial_right_high_poly is stopping this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_poly.status = FINISHED
                            cpdm_trial_right_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_poly* updates
                    
                    # if cpdm_trial_left_low_poly is starting this frame...
                    if cpdm_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_poly.status = STARTED
                        cpdm_trial_left_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_poly is active this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_low_poly.setFillColor(left_low_color, log=False)
                    
                    # if cpdm_trial_left_low_poly is stopping this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_poly.status = FINISHED
                            cpdm_trial_left_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_poly* updates
                    
                    # if cpdm_trial_right_low_poly is starting this frame...
                    if cpdm_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_poly.status = STARTED
                        cpdm_trial_right_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_poly is active this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_low_poly.setFillColor(right_low_color, log=False)
                    
                    # if cpdm_trial_right_low_poly is stopping this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_poly.status = FINISHED
                            cpdm_trial_right_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_txt* updates
                    
                    # if cpdm_trial_left_high_txt is starting this frame...
                    if cpdm_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_txt.status = STARTED
                        cpdm_trial_left_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_txt is active this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_high_txt is stopping this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_txt.status = FINISHED
                            cpdm_trial_left_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_txt* updates
                    
                    # if cpdm_trial_right_high_txt is starting this frame...
                    if cpdm_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_txt.status = STARTED
                        cpdm_trial_right_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_txt is active this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_high_txt is stopping this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_txt.status = FINISHED
                            cpdm_trial_right_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_txt* updates
                    
                    # if cpdm_trial_left_low_txt is starting this frame...
                    if cpdm_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_txt.status = STARTED
                        cpdm_trial_left_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_txt is active this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_low_txt is stopping this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_txt.status = FINISHED
                            cpdm_trial_left_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_txt* updates
                    
                    # if cpdm_trial_right_low_txt is starting this frame...
                    if cpdm_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_txt.status = STARTED
                        cpdm_trial_right_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_txt is active this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_low_txt is stopping this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_txt.status = FINISHED
                            cpdm_trial_right_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_resp* updates
                    waitOnFlip = False
                    
                    # if cpdm_trial_resp is starting this frame...
                    if cpdm_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_resp.frameNStart = frameN  # exact frame index
                        cpdm_trial_resp.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_resp, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(cpdm_trial_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(cpdm_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    
                    # if cpdm_trial_resp is stopping this frame...
                    if cpdm_trial_resp.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_resp.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_resp.tStop = t  # not accounting for scr refresh
                            cpdm_trial_resp.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_resp.status = FINISHED
                            cpdm_trial_resp.status = FINISHED
                    if cpdm_trial_resp.status == STARTED and not waitOnFlip:
                        theseKeys = cpdm_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                        _cpdm_trial_resp_allKeys.extend(theseKeys)
                        if len(_cpdm_trial_resp_allKeys):
                            cpdm_trial_resp.keys = _cpdm_trial_resp_allKeys[0].name  # just the first key pressed
                            cpdm_trial_resp.rt = _cpdm_trial_resp_allKeys[0].rt
                            cpdm_trial_resp.duration = _cpdm_trial_resp_allKeys[0].duration
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trialComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trial" ---
                for thisComponent in cpdm_trialComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trial.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trial_code
                #binary accuracy & confidence
                my_loop.addData("cpdm_acc", trial_acc)
                my_loop.addData("cpdm_conf", trial_conf)
                my_loop.addData("cpdm_trial_type", "task")
                key = cpdm_trial_resp.keys
                if key in ["q", "a", "p", "l"]:
                    run_resps.append(key)
                
                if type(cpdm_trial_resp.rt) is list or cpdm_trial_resp.rt >= 2 - 0.5:
                    delta_time = 0
                else:
                    delta_time = max(0, 2 - (cpdm_trial_resp.rt + stopped_time))
                
                #low risk possible payouts
                if "low_risk" in cpdm_run_dimension: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0: 
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False: 
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #LEFT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                #high risk possible payouts
                else: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #Left - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                # check responses
                if cpdm_trial_resp.keys in ['', [], None]:  # No response was made
                    cpdm_trial_resp.keys = None
                cpdm_trials1.addData('cpdm_trial_resp.keys',cpdm_trial_resp.keys)
                if cpdm_trial_resp.keys != None:  # we had a response
                    cpdm_trials1.addData('cpdm_trial_resp.rt', cpdm_trial_resp.rt)
                    cpdm_trials1.addData('cpdm_trial_resp.duration', cpdm_trial_resp.duration)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-2.300000)
                
                # --- Prepare to start Routine "cpdm_trial_iti1" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trial_iti1.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trials_iti1_code
                #variable ITI for non-practice trials
                cpdm_iti_time = cpdm_iti_list[my_loop.thisIndex] + cpdm_delta_time
                #200 CPDM trials per run
                if cpdm_trials1.thisTrialN == 199:
                    continueRoutine = False
                # keep track of which components have finished
                cpdm_trial_iti1Components = [cpdm_trials_iti1_poly]
                for thisComponent in cpdm_trial_iti1Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trial_iti1" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *cpdm_trials_iti1_poly* updates
                    
                    # if cpdm_trials_iti1_poly is starting this frame...
                    if cpdm_trials_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trials_iti1_poly.frameNStart = frameN  # exact frame index
                        cpdm_trials_iti1_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trials_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trials_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trials_iti1_poly.started')
                        # update status
                        cpdm_trials_iti1_poly.status = STARTED
                        cpdm_trials_iti1_poly.setAutoDraw(True)
                    
                    # if cpdm_trials_iti1_poly is active this frame...
                    if cpdm_trials_iti1_poly.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trials_iti1_poly is stopping this frame...
                    if cpdm_trials_iti1_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trials_iti1_poly.tStartRefresh + cpdm_iti_time-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trials_iti1_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trials_iti1_poly.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trials_iti1_poly.stopped')
                            # update status
                            cpdm_trials_iti1_poly.status = FINISHED
                            cpdm_trials_iti1_poly.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trial_iti1Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trial_iti1" ---
                for thisComponent in cpdm_trial_iti1Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trial_iti1.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trials_iti1_code
                #record delta time
                my_loop.addData("cpdm_delta_time", cpdm_delta_time) 
                #record iti time
                my_loop.addData("cpdm_iti_time", cpdm_iti_time) 
                # the Routine "cpdm_trial_iti1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 1.0 repeats of 'cpdm_trials1'
            
            
            # --- Prepare to start Routine "cpdm_run_break1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_break1.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_break1_code
            cpdm_unique_resps = []
            cpdm_unique_count = 0
            for i in run_resps:
                if i not in cpdm_unique_resps:
                    cpdm_unique_count += 1
                    cpdm_unique_resps.append(i)
            
            cpdm_run_break_text = ""
            cpdm_space_text = ""
            #filter for nonresponses
            if len(run_resps) < 190: #95% = 190 trials per block
                cpdm_run_break_text = "You failed to respond to " + str(200-len(run_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject1", "< 95% resp rate")
                my_loop.addData("cpdm_subReject1_nonresps", 200-len(run_resps))
            #filter for single-button responses
            elif cpdm_unique_count < 2: #same for each exp
                cpdm_run_break_text = "You provided the same response to all " + str(len(run_resps)) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject2", "1key response")
                my_loop.addData("cpdm_subReject2_key", run_resps[0])
            #filter for poor performance on CPDM catch trials for low volatility blocks (14/20 catch trial criterion -- 5.77% of random success on 14/20 trials)
            elif "low_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 14:
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject3LV", "LV catch fail")
                my_loop.addData("cpdm_subReject3LV_fails", 20-sum(cpdm_catch_trials))
            #filter for poor performance on CPDM catch trials for high volatility blocks (6/8 catch trial criterion -- 14.45% of random success on 7/8 trials)
            #elif "high_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 6:
            #    cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            #    cpdm_space_text = "Press SPACE to end."
            #    exp_proceed = False
            #    my_loop.addData("subReject3HV", "HV catch fail")
            #    my_loop.addData("subReject3HV_fails", 8-sum(cpdm_catch_trials))
            #all CPDM criterion are met -- good data
            else:
                #final run
                if condition_runs1.thisN == 1: 
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!"
                    cpdm_space_text = "Press SPACE to continue."
                #first three runs
                else: 
                    cpdm_run_break_text = "Please feel free to take a short break. \n \n As you begin Block " + str(run_counter) + ", read the possible monetary values of each option carefully as they may have changed."
                    cpdm_space_text = "Press SPACE to continue."
            cpdm_run_break1_txt.setText(cpdm_run_break_text)
            cpdm_run_break1_space_txt.setText(cpdm_space_text)
            cpdm_run_break1_resp.keys = []
            cpdm_run_break1_resp.rt = []
            _cpdm_run_break1_resp_allKeys = []
            # keep track of which components have finished
            cpdm_run_break1Components = [cpdm_run_break1_title_txt, cpdm_run_break1_txt, cpdm_run_break1_space_txt, cpdm_run_break1_resp]
            for thisComponent in cpdm_run_break1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_break1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_run_break1_title_txt* updates
                
                # if cpdm_run_break1_title_txt is starting this frame...
                if cpdm_run_break1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break1_title_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break1_title_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break1_title_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break1_title_txt.status = STARTED
                    cpdm_run_break1_title_txt.setAutoDraw(True)
                
                # if cpdm_run_break1_title_txt is active this frame...
                if cpdm_run_break1_title_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break1_txt* updates
                
                # if cpdm_run_break1_txt is starting this frame...
                if cpdm_run_break1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break1_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break1_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break1_txt.status = STARTED
                    cpdm_run_break1_txt.setAutoDraw(True)
                
                # if cpdm_run_break1_txt is active this frame...
                if cpdm_run_break1_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break1_space_txt* updates
                
                # if cpdm_run_break1_space_txt is starting this frame...
                if cpdm_run_break1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break1_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break1_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break1_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break1_space_txt.status = STARTED
                    cpdm_run_break1_space_txt.setAutoDraw(True)
                
                # if cpdm_run_break1_space_txt is active this frame...
                if cpdm_run_break1_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break1_resp* updates
                waitOnFlip = False
                
                # if cpdm_run_break1_resp is starting this frame...
                if cpdm_run_break1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break1_resp.frameNStart = frameN  # exact frame index
                    cpdm_run_break1_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break1_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break1_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_run_break1_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_run_break1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_run_break1_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_run_break1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_run_break1_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_run_break1_resp_allKeys):
                        cpdm_run_break1_resp.keys = _cpdm_run_break1_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_run_break1_resp.rt = _cpdm_run_break1_resp_allKeys[-1].rt
                        cpdm_run_break1_resp.duration = _cpdm_run_break1_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_break1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_break1" ---
            for thisComponent in cpdm_run_break1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_break1.stopped', globalClock.getTime())
            # the Routine "cpdm_run_break1" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "idm_term_check" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('idm_term_check.started', globalClock.getTime())
            # Run 'Begin Routine' code from idm_term_check_code
            if exp_proceed == False:
                core.quit()
            # keep track of which components have finished
            idm_term_checkComponents = []
            for thisComponent in idm_term_checkComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "idm_term_check" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in idm_term_checkComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "idm_term_check" ---
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('idm_term_check.stopped', globalClock.getTime())
            # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'condition_runs1'
        
    # completed loop1 repeats of 'should_run1'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run2 = data.TrialHandler(nReps=loop2, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run2')
    thisExp.addLoop(should_run2)  # add the loop to the experiment
    thisShould_run2 = should_run2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run2.rgb)
    if thisShould_run2 != None:
        for paramName in thisShould_run2:
            globals()[paramName] = thisShould_run2[paramName]
    
    for thisShould_run2 in should_run2:
        currentLoop = should_run2
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run2.rgb)
        if thisShould_run2 != None:
            for paramName in thisShould_run2:
                globals()[paramName] = thisShould_run2[paramName]
        
        # --- Prepare to start Routine "crdm_namer1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_namer1.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_namer_code
        #provides specific loop names for each of two interations of CRDM
        #to provide flexibility of crdm_pract_trial and crdm_trial routines
        crdm_practice_loop1_name = "crdm_pract1_trials1"
        crdm_questplus_loop_name = "crdm_qp_trials1"
        crdm_practice_loop2_name = "crdm_pract2_trials1"
        crdm_loop_name = "crdm_trials1"
        # keep track of which components have finished
        crdm_namer1Components = []
        for thisComponent in crdm_namer1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_namer1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_namer1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_namer1" ---
        for thisComponent in crdm_namer1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_namer1.stopped', globalClock.getTime())
        # the Routine "crdm_namer1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr1.started', globalClock.getTime())
        crdm_instr1_resp.keys = []
        crdm_instr1_resp.rt = []
        _crdm_instr1_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr1Components = [crdm_instr1_title_txt, crdm_instr1_txt, crdm_instr1_space_txt, crdm_instr1_resp]
        for thisComponent in crdm_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr1_title_txt* updates
            
            # if crdm_instr1_title_txt is starting this frame...
            if crdm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_title_txt.status = STARTED
                crdm_instr1_title_txt.setAutoDraw(True)
            
            # if crdm_instr1_title_txt is active this frame...
            if crdm_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_txt* updates
            
            # if crdm_instr1_txt is starting this frame...
            if crdm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_txt.status = STARTED
                crdm_instr1_txt.setAutoDraw(True)
            
            # if crdm_instr1_txt is active this frame...
            if crdm_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_space_txt* updates
            
            # if crdm_instr1_space_txt is starting this frame...
            if crdm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_space_txt.status = STARTED
                crdm_instr1_space_txt.setAutoDraw(True)
            
            # if crdm_instr1_space_txt is active this frame...
            if crdm_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_resp* updates
            waitOnFlip = False
            
            # if crdm_instr1_resp is starting this frame...
            if crdm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_resp.frameNStart = frameN  # exact frame index
                crdm_instr1_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr1_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr1_resp_allKeys):
                    crdm_instr1_resp.keys = _crdm_instr1_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr1_resp.rt = _crdm_instr1_resp_allKeys[-1].rt
                    crdm_instr1_resp.duration = _crdm_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr1" ---
        for thisComponent in crdm_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr1.stopped', globalClock.getTime())
        # the Routine "crdm_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr2.started', globalClock.getTime())
        crdm_instr2_resp.keys = []
        crdm_instr2_resp.rt = []
        _crdm_instr2_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr2Components = [crdm_instr2_lottname_txt, crdm_instr2_txt, crdm_instr2_img, crdm_instr2_lott0_txt, crdm_instr2_lott20_txt, crdm_instr2_space_txt, crdm_instr2_resp]
        for thisComponent in crdm_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr2_lottname_txt* updates
            
            # if crdm_instr2_lottname_txt is starting this frame...
            if crdm_instr2_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lottname_txt.status = STARTED
                crdm_instr2_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr2_lottname_txt is active this frame...
            if crdm_instr2_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_txt* updates
            
            # if crdm_instr2_txt is starting this frame...
            if crdm_instr2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_txt.status = STARTED
                crdm_instr2_txt.setAutoDraw(True)
            
            # if crdm_instr2_txt is active this frame...
            if crdm_instr2_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_img* updates
            
            # if crdm_instr2_img is starting this frame...
            if crdm_instr2_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_img.frameNStart = frameN  # exact frame index
                crdm_instr2_img.tStart = t  # local t and not account for scr refresh
                crdm_instr2_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_img.status = STARTED
                crdm_instr2_img.setAutoDraw(True)
            
            # if crdm_instr2_img is active this frame...
            if crdm_instr2_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_lott0_txt* updates
            
            # if crdm_instr2_lott0_txt is starting this frame...
            if crdm_instr2_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lott0_txt.status = STARTED
                crdm_instr2_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr2_lott0_txt is active this frame...
            if crdm_instr2_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_lott20_txt* updates
            
            # if crdm_instr2_lott20_txt is starting this frame...
            if crdm_instr2_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lott20_txt.status = STARTED
                crdm_instr2_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr2_lott20_txt is active this frame...
            if crdm_instr2_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_space_txt* updates
            
            # if crdm_instr2_space_txt is starting this frame...
            if crdm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_space_txt.status = STARTED
                crdm_instr2_space_txt.setAutoDraw(True)
            
            # if crdm_instr2_space_txt is active this frame...
            if crdm_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_resp* updates
            waitOnFlip = False
            
            # if crdm_instr2_resp is starting this frame...
            if crdm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_resp.frameNStart = frameN  # exact frame index
                crdm_instr2_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr2_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr2_resp_allKeys):
                    crdm_instr2_resp.keys = _crdm_instr2_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr2_resp.rt = _crdm_instr2_resp_allKeys[-1].rt
                    crdm_instr2_resp.duration = _crdm_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr2" ---
        for thisComponent in crdm_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr2.stopped', globalClock.getTime())
        # the Routine "crdm_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr3.started', globalClock.getTime())
        crdm_instr3_resp.keys = []
        crdm_instr3_resp.rt = []
        _crdm_instr3_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr3Components = [crdm_instr3_lottname_txt, crdm_instr3_txt, crdm_instr3_img, crdm_instr3_lott0_txt, crdm_instr3_lott20_txt, crdm_instr3_space_txt, crdm_instr3_resp]
        for thisComponent in crdm_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr3_lottname_txt* updates
            
            # if crdm_instr3_lottname_txt is starting this frame...
            if crdm_instr3_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lottname_txt.status = STARTED
                crdm_instr3_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr3_lottname_txt is active this frame...
            if crdm_instr3_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_txt* updates
            
            # if crdm_instr3_txt is starting this frame...
            if crdm_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_txt.status = STARTED
                crdm_instr3_txt.setAutoDraw(True)
            
            # if crdm_instr3_txt is active this frame...
            if crdm_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_img* updates
            
            # if crdm_instr3_img is starting this frame...
            if crdm_instr3_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_img.frameNStart = frameN  # exact frame index
                crdm_instr3_img.tStart = t  # local t and not account for scr refresh
                crdm_instr3_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_img.status = STARTED
                crdm_instr3_img.setAutoDraw(True)
            
            # if crdm_instr3_img is active this frame...
            if crdm_instr3_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_lott0_txt* updates
            
            # if crdm_instr3_lott0_txt is starting this frame...
            if crdm_instr3_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lott0_txt.status = STARTED
                crdm_instr3_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr3_lott0_txt is active this frame...
            if crdm_instr3_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_lott20_txt* updates
            
            # if crdm_instr3_lott20_txt is starting this frame...
            if crdm_instr3_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lott20_txt.status = STARTED
                crdm_instr3_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr3_lott20_txt is active this frame...
            if crdm_instr3_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_space_txt* updates
            
            # if crdm_instr3_space_txt is starting this frame...
            if crdm_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_space_txt.status = STARTED
                crdm_instr3_space_txt.setAutoDraw(True)
            
            # if crdm_instr3_space_txt is active this frame...
            if crdm_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_resp* updates
            waitOnFlip = False
            
            # if crdm_instr3_resp is starting this frame...
            if crdm_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_resp.frameNStart = frameN  # exact frame index
                crdm_instr3_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr3_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr3_resp_allKeys):
                    crdm_instr3_resp.keys = _crdm_instr3_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr3_resp.rt = _crdm_instr3_resp_allKeys[-1].rt
                    crdm_instr3_resp.duration = _crdm_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr3" ---
        for thisComponent in crdm_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr3.stopped', globalClock.getTime())
        # the Routine "crdm_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr4.started', globalClock.getTime())
        crdm_instr4_resp.keys = []
        crdm_instr4_resp.rt = []
        _crdm_instr4_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr4Components = [crdm_instr4_lottname_txt, crdm_instr4_txt, crdm_instr4_img, crdm_instr4_lott0_txt, crdm_instr4_lott20_txt, crdm_instr4_space_txt, crdm_instr4_resp]
        for thisComponent in crdm_instr4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr4_lottname_txt* updates
            
            # if crdm_instr4_lottname_txt is starting this frame...
            if crdm_instr4_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lottname_txt.status = STARTED
                crdm_instr4_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr4_lottname_txt is active this frame...
            if crdm_instr4_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_txt* updates
            
            # if crdm_instr4_txt is starting this frame...
            if crdm_instr4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_txt.status = STARTED
                crdm_instr4_txt.setAutoDraw(True)
            
            # if crdm_instr4_txt is active this frame...
            if crdm_instr4_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_img* updates
            
            # if crdm_instr4_img is starting this frame...
            if crdm_instr4_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_img.frameNStart = frameN  # exact frame index
                crdm_instr4_img.tStart = t  # local t and not account for scr refresh
                crdm_instr4_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_img.status = STARTED
                crdm_instr4_img.setAutoDraw(True)
            
            # if crdm_instr4_img is active this frame...
            if crdm_instr4_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_lott0_txt* updates
            
            # if crdm_instr4_lott0_txt is starting this frame...
            if crdm_instr4_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lott0_txt.status = STARTED
                crdm_instr4_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr4_lott0_txt is active this frame...
            if crdm_instr4_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_lott20_txt* updates
            
            # if crdm_instr4_lott20_txt is starting this frame...
            if crdm_instr4_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lott20_txt.status = STARTED
                crdm_instr4_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr4_lott20_txt is active this frame...
            if crdm_instr4_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_space_txt* updates
            
            # if crdm_instr4_space_txt is starting this frame...
            if crdm_instr4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_space_txt.status = STARTED
                crdm_instr4_space_txt.setAutoDraw(True)
            
            # if crdm_instr4_space_txt is active this frame...
            if crdm_instr4_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_resp* updates
            waitOnFlip = False
            
            # if crdm_instr4_resp is starting this frame...
            if crdm_instr4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_resp.frameNStart = frameN  # exact frame index
                crdm_instr4_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr4_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr4_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr4_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr4_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr4_resp_allKeys):
                    crdm_instr4_resp.keys = _crdm_instr4_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr4_resp.rt = _crdm_instr4_resp_allKeys[-1].rt
                    crdm_instr4_resp.duration = _crdm_instr4_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr4" ---
        for thisComponent in crdm_instr4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr4.stopped', globalClock.getTime())
        # the Routine "crdm_instr4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr5" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr5.started', globalClock.getTime())
        crdm_instr5_resp.keys = []
        crdm_instr5_resp.rt = []
        _crdm_instr5_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr5Components = [crdm_instr5_txt, crdm_instr5_img, crdm_instr5_lott_top_txt, crdm_instr5_lott_bot_txt, crdm_instr5_sure_txt, crdm_instr5_space_txt, crdm_instr5_resp]
        for thisComponent in crdm_instr5Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr5" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr5_txt* updates
            
            # if crdm_instr5_txt is starting this frame...
            if crdm_instr5_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_txt.status = STARTED
                crdm_instr5_txt.setAutoDraw(True)
            
            # if crdm_instr5_txt is active this frame...
            if crdm_instr5_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_img* updates
            
            # if crdm_instr5_img is starting this frame...
            if crdm_instr5_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_img.frameNStart = frameN  # exact frame index
                crdm_instr5_img.tStart = t  # local t and not account for scr refresh
                crdm_instr5_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_img.status = STARTED
                crdm_instr5_img.setAutoDraw(True)
            
            # if crdm_instr5_img is active this frame...
            if crdm_instr5_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_lott_top_txt* updates
            
            # if crdm_instr5_lott_top_txt is starting this frame...
            if crdm_instr5_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_lott_top_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_lott_top_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_lott_top_txt.status = STARTED
                crdm_instr5_lott_top_txt.setAutoDraw(True)
            
            # if crdm_instr5_lott_top_txt is active this frame...
            if crdm_instr5_lott_top_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_lott_bot_txt* updates
            
            # if crdm_instr5_lott_bot_txt is starting this frame...
            if crdm_instr5_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_lott_bot_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_lott_bot_txt.status = STARTED
                crdm_instr5_lott_bot_txt.setAutoDraw(True)
            
            # if crdm_instr5_lott_bot_txt is active this frame...
            if crdm_instr5_lott_bot_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_sure_txt* updates
            
            # if crdm_instr5_sure_txt is starting this frame...
            if crdm_instr5_sure_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_sure_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_sure_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_sure_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_sure_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_sure_txt.status = STARTED
                crdm_instr5_sure_txt.setAutoDraw(True)
            
            # if crdm_instr5_sure_txt is active this frame...
            if crdm_instr5_sure_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_space_txt* updates
            
            # if crdm_instr5_space_txt is starting this frame...
            if crdm_instr5_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_space_txt.status = STARTED
                crdm_instr5_space_txt.setAutoDraw(True)
            
            # if crdm_instr5_space_txt is active this frame...
            if crdm_instr5_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_resp* updates
            waitOnFlip = False
            
            # if crdm_instr5_resp is starting this frame...
            if crdm_instr5_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_resp.frameNStart = frameN  # exact frame index
                crdm_instr5_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr5_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr5_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr5_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr5_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr5_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr5_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr5_resp_allKeys):
                    crdm_instr5_resp.keys = _crdm_instr5_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr5_resp.rt = _crdm_instr5_resp_allKeys[-1].rt
                    crdm_instr5_resp.duration = _crdm_instr5_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr5Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr5" ---
        for thisComponent in crdm_instr5Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr5.stopped', globalClock.getTime())
        # the Routine "crdm_instr5" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr6" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr6.started', globalClock.getTime())
        crdm_instr6_resp.keys = []
        crdm_instr6_resp.rt = []
        _crdm_instr6_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr6Components = [crdm_instr6_title_txt, crdm_instr6_txt, crdm_instr6_img, crdm_instr6_space_txt, crdm_instr6_resp]
        for thisComponent in crdm_instr6Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr6" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr6_title_txt* updates
            
            # if crdm_instr6_title_txt is starting this frame...
            if crdm_instr6_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_title_txt.status = STARTED
                crdm_instr6_title_txt.setAutoDraw(True)
            
            # if crdm_instr6_title_txt is active this frame...
            if crdm_instr6_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_txt* updates
            
            # if crdm_instr6_txt is starting this frame...
            if crdm_instr6_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_txt.status = STARTED
                crdm_instr6_txt.setAutoDraw(True)
            
            # if crdm_instr6_txt is active this frame...
            if crdm_instr6_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_img* updates
            
            # if crdm_instr6_img is starting this frame...
            if crdm_instr6_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_img.frameNStart = frameN  # exact frame index
                crdm_instr6_img.tStart = t  # local t and not account for scr refresh
                crdm_instr6_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_img.status = STARTED
                crdm_instr6_img.setAutoDraw(True)
            
            # if crdm_instr6_img is active this frame...
            if crdm_instr6_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_space_txt* updates
            
            # if crdm_instr6_space_txt is starting this frame...
            if crdm_instr6_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_space_txt.status = STARTED
                crdm_instr6_space_txt.setAutoDraw(True)
            
            # if crdm_instr6_space_txt is active this frame...
            if crdm_instr6_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_resp* updates
            waitOnFlip = False
            
            # if crdm_instr6_resp is starting this frame...
            if crdm_instr6_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_resp.frameNStart = frameN  # exact frame index
                crdm_instr6_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr6_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr6_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr6_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr6_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr6_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr6_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr6_resp_allKeys):
                    crdm_instr6_resp.keys = _crdm_instr6_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr6_resp.rt = _crdm_instr6_resp_allKeys[-1].rt
                    crdm_instr6_resp.duration = _crdm_instr6_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr6Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr6" ---
        for thisComponent in crdm_instr6Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr6.stopped', globalClock.getTime())
        # the Routine "crdm_instr6" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr7" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr7.started', globalClock.getTime())
        crdm_instr7_resp.keys = []
        crdm_instr7_resp.rt = []
        _crdm_instr7_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr7Components = [crdm_instr7_title_txt, crdm_instr7_txt, crdm_instr7_img, crdm_instr7_space_txt, crdm_instr7_resp]
        for thisComponent in crdm_instr7Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr7" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr7_title_txt* updates
            
            # if crdm_instr7_title_txt is starting this frame...
            if crdm_instr7_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_title_txt.status = STARTED
                crdm_instr7_title_txt.setAutoDraw(True)
            
            # if crdm_instr7_title_txt is active this frame...
            if crdm_instr7_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_txt* updates
            
            # if crdm_instr7_txt is starting this frame...
            if crdm_instr7_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_txt.status = STARTED
                crdm_instr7_txt.setAutoDraw(True)
            
            # if crdm_instr7_txt is active this frame...
            if crdm_instr7_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_img* updates
            
            # if crdm_instr7_img is starting this frame...
            if crdm_instr7_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_img.frameNStart = frameN  # exact frame index
                crdm_instr7_img.tStart = t  # local t and not account for scr refresh
                crdm_instr7_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_img.status = STARTED
                crdm_instr7_img.setAutoDraw(True)
            
            # if crdm_instr7_img is active this frame...
            if crdm_instr7_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_space_txt* updates
            
            # if crdm_instr7_space_txt is starting this frame...
            if crdm_instr7_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_space_txt.status = STARTED
                crdm_instr7_space_txt.setAutoDraw(True)
            
            # if crdm_instr7_space_txt is active this frame...
            if crdm_instr7_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_resp* updates
            waitOnFlip = False
            
            # if crdm_instr7_resp is starting this frame...
            if crdm_instr7_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_resp.frameNStart = frameN  # exact frame index
                crdm_instr7_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr7_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr7_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr7_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr7_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr7_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr7_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr7_resp_allKeys):
                    crdm_instr7_resp.keys = _crdm_instr7_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr7_resp.rt = _crdm_instr7_resp_allKeys[-1].rt
                    crdm_instr7_resp.duration = _crdm_instr7_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr7Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr7" ---
        for thisComponent in crdm_instr7Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr7.stopped', globalClock.getTime())
        # the Routine "crdm_instr7" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_warn.started', globalClock.getTime())
        crdm_warn1_resp.keys = []
        crdm_warn1_resp.rt = []
        _crdm_warn1_resp_allKeys = []
        # keep track of which components have finished
        crdm_warnComponents = [crdm_warn1_title_txt, crdm_warn1_txt, crdm_warn1_space_txt, crdm_warn1_resp]
        for thisComponent in crdm_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_warn1_title_txt* updates
            
            # if crdm_warn1_title_txt is starting this frame...
            if crdm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_title_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_title_txt.status = STARTED
                crdm_warn1_title_txt.setAutoDraw(True)
            
            # if crdm_warn1_title_txt is active this frame...
            if crdm_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_txt* updates
            
            # if crdm_warn1_txt is starting this frame...
            if crdm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_txt.status = STARTED
                crdm_warn1_txt.setAutoDraw(True)
            
            # if crdm_warn1_txt is active this frame...
            if crdm_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_space_txt* updates
            
            # if crdm_warn1_space_txt is starting this frame...
            if crdm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_space_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_space_txt.status = STARTED
                crdm_warn1_space_txt.setAutoDraw(True)
            
            # if crdm_warn1_space_txt is active this frame...
            if crdm_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_resp* updates
            waitOnFlip = False
            
            # if crdm_warn1_resp is starting this frame...
            if crdm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_resp.frameNStart = frameN  # exact frame index
                crdm_warn1_resp.tStart = t  # local t and not account for scr refresh
                crdm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_warn1_resp_allKeys.extend(theseKeys)
                if len(_crdm_warn1_resp_allKeys):
                    crdm_warn1_resp.keys = _crdm_warn1_resp_allKeys[-1].name  # just the last key pressed
                    crdm_warn1_resp.rt = _crdm_warn1_resp_allKeys[-1].rt
                    crdm_warn1_resp.duration = _crdm_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_warn" ---
        for thisComponent in crdm_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_warn.stopped', globalClock.getTime())
        # the Routine "crdm_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_pract1_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_pract1_instr.started', globalClock.getTime())
        crdm_pract1_instr_key.keys = []
        crdm_pract1_instr_key.rt = []
        _crdm_pract1_instr_key_allKeys = []
        # keep track of which components have finished
        crdm_pract1_instrComponents = [crdm_pract1_instr_name_txt, crdm_pract1_instr_txt, crdm_pract1_instr_space_txt, crdm_pract1_instr_key]
        for thisComponent in crdm_pract1_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_pract1_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_pract1_instr_name_txt* updates
            
            # if crdm_pract1_instr_name_txt is starting this frame...
            if crdm_pract1_instr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_name_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_name_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_name_txt.status = STARTED
                crdm_pract1_instr_name_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_name_txt is active this frame...
            if crdm_pract1_instr_name_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_txt* updates
            
            # if crdm_pract1_instr_txt is starting this frame...
            if crdm_pract1_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_txt.status = STARTED
                crdm_pract1_instr_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_txt is active this frame...
            if crdm_pract1_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_space_txt* updates
            
            # if crdm_pract1_instr_space_txt is starting this frame...
            if crdm_pract1_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_space_txt.status = STARTED
                crdm_pract1_instr_space_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_space_txt is active this frame...
            if crdm_pract1_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_key* updates
            waitOnFlip = False
            
            # if crdm_pract1_instr_key is starting this frame...
            if crdm_pract1_instr_key.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_key.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_key.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_key.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_key, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_key.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_pract1_instr_key.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_pract1_instr_key.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_pract1_instr_key.status == STARTED and not waitOnFlip:
                theseKeys = crdm_pract1_instr_key.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_pract1_instr_key_allKeys.extend(theseKeys)
                if len(_crdm_pract1_instr_key_allKeys):
                    crdm_pract1_instr_key.keys = _crdm_pract1_instr_key_allKeys[-1].name  # just the last key pressed
                    crdm_pract1_instr_key.rt = _crdm_pract1_instr_key_allKeys[-1].rt
                    crdm_pract1_instr_key.duration = _crdm_pract1_instr_key_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_pract1_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_pract1_instr" ---
        for thisComponent in crdm_pract1_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_pract1_instr.stopped', globalClock.getTime())
        # the Routine "crdm_pract1_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_pract1_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_practice1.csv'),
            seed=None, name='crdm_pract1_trials1')
        thisExp.addLoop(crdm_pract1_trials1)  # add the loop to the experiment
        thisCrdm_pract1_trials1 = crdm_pract1_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract1_trials1.rgb)
        if thisCrdm_pract1_trials1 != None:
            for paramName in thisCrdm_pract1_trials1:
                globals()[paramName] = thisCrdm_pract1_trials1[paramName]
        
        for thisCrdm_pract1_trials1 in crdm_pract1_trials1:
            currentLoop = crdm_pract1_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract1_trials1.rgb)
            if thisCrdm_pract1_trials1 != None:
                for paramName in thisCrdm_pract1_trials1:
                    globals()[paramName] = thisCrdm_pract1_trials1[paramName]
            
            # --- Prepare to start Routine "crdm_pract1_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract1_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract1_trial_code
            my_loop = eval(crdm_practice_loop1_name)
            
            #random index for certain outcome position and response
            crdm_idx1 = random.randint(0,1) 
            crdm_sure_pos1 = crdm_pos1[crdm_idx1] 
            crdm_sure_resp1 = crdm_resp1[crdm_idx1]
            crdm_pract1_trial_img.setImage("crdm/" + crdm_img1)
            crdm_pract1_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top1))))
            crdm_pract1_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot1))))
            crdm_pract1_trial_sure_amt_txt.setPos(crdm_sure_pos1)
            crdm_pract1_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt1)))
            )
            crdm_pract1_trial_resp.keys = []
            crdm_pract1_trial_resp.rt = []
            _crdm_pract1_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract1_trialComponents = [crdm_pract1_trial_img, crdm_pract1_trial_lott_top_txt, crdm_pract1_trial_lott_bot_txt, crdm_pract1_trial_sure_amt_txt, GRFX_fix4, crdm_pract1_trial_cue, crdm_pract1_trial_resp]
            for thisComponent in crdm_pract1_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract1_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract1_trial_img* updates
                
                # if crdm_pract1_trial_img is starting this frame...
                if crdm_pract1_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_img.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_img.status = STARTED
                    crdm_pract1_trial_img.setAutoDraw(True)
                
                # if crdm_pract1_trial_img is active this frame...
                if crdm_pract1_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_img is stopping this frame...
                if crdm_pract1_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_img.status = FINISHED
                        crdm_pract1_trial_img.setAutoDraw(False)
                
                # *crdm_pract1_trial_lott_top_txt* updates
                
                # if crdm_pract1_trial_lott_top_txt is starting this frame...
                if crdm_pract1_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_lott_top_txt.status = STARTED
                    crdm_pract1_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_lott_top_txt is active this frame...
                if crdm_pract1_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_lott_top_txt is stopping this frame...
                if crdm_pract1_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_lott_top_txt.status = FINISHED
                        crdm_pract1_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_pract1_trial_lott_bot_txt* updates
                
                # if crdm_pract1_trial_lott_bot_txt is starting this frame...
                if crdm_pract1_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_lott_bot_txt.status = STARTED
                    crdm_pract1_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_lott_bot_txt is active this frame...
                if crdm_pract1_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_lott_bot_txt is stopping this frame...
                if crdm_pract1_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_lott_bot_txt.status = FINISHED
                        crdm_pract1_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_pract1_trial_sure_amt_txt* updates
                
                # if crdm_pract1_trial_sure_amt_txt is starting this frame...
                if crdm_pract1_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_sure_amt_txt.status = STARTED
                    crdm_pract1_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_sure_amt_txt is active this frame...
                if crdm_pract1_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_sure_amt_txt is stopping this frame...
                if crdm_pract1_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_sure_amt_txt.status = FINISHED
                        crdm_pract1_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix4* updates
                
                # if GRFX_fix4 is starting this frame...
                if GRFX_fix4.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix4.frameNStart = frameN  # exact frame index
                    GRFX_fix4.tStart = t  # local t and not account for scr refresh
                    GRFX_fix4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix4.status = STARTED
                    GRFX_fix4.setAutoDraw(True)
                
                # if GRFX_fix4 is active this frame...
                if GRFX_fix4.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix4 is stopping this frame...
                if GRFX_fix4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix4.tStop = t  # not accounting for scr refresh
                        GRFX_fix4.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix4.status = FINISHED
                        GRFX_fix4.setAutoDraw(False)
                
                # *crdm_pract1_trial_cue* updates
                
                # if crdm_pract1_trial_cue is starting this frame...
                if crdm_pract1_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_cue.status = STARTED
                    crdm_pract1_trial_cue.setAutoDraw(True)
                
                # if crdm_pract1_trial_cue is active this frame...
                if crdm_pract1_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_cue is stopping this frame...
                if crdm_pract1_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_cue.status = FINISHED
                        crdm_pract1_trial_cue.setAutoDraw(False)
                
                # *crdm_pract1_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_pract1_trial_resp is starting this frame...
                if crdm_pract1_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract1_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract1_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract1_trial_resp is stopping this frame...
                if crdm_pract1_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_resp.status = FINISHED
                        crdm_pract1_trial_resp.status = FINISHED
                if crdm_pract1_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract1_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract1_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract1_trial_resp_allKeys):
                        crdm_pract1_trial_resp.keys = _crdm_pract1_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_pract1_trial_resp.rt = _crdm_pract1_trial_resp_allKeys[0].rt
                        crdm_pract1_trial_resp.duration = _crdm_pract1_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_pract1_trial_resp.keys == str(crdm_sure_resp1)) or (crdm_pract1_trial_resp.keys == crdm_sure_resp1):
                            crdm_pract1_trial_resp.corr = 1
                        else:
                            crdm_pract1_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract1_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract1_trial" ---
            for thisComponent in crdm_pract1_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract1_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_pract1_trial_code
            crdm_pract1_key = crdm_pract1_trial_resp.keys
            crdm_pract1_sure_key = crdm_pract1_trial_resp.corr
            
            my_loop.addData("crdm_trial_type", "practice1")
            # check responses
            if crdm_pract1_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_pract1_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp1).lower() == 'none':
                   crdm_pract1_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_pract1_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_pract1_trials1 (TrialHandler)
            crdm_pract1_trials1.addData('crdm_pract1_trial_resp.keys',crdm_pract1_trial_resp.keys)
            crdm_pract1_trials1.addData('crdm_pract1_trial_resp.corr', crdm_pract1_trial_resp.corr)
            if crdm_pract1_trial_resp.keys != None:  # we had a response
                crdm_pract1_trials1.addData('crdm_pract1_trial_resp.rt', crdm_pract1_trial_resp.rt)
                crdm_pract1_trials1.addData('crdm_pract1_trial_resp.duration', crdm_pract1_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_pract1_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract1_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract1_feedback_code
            if len(crdm_pract1_key) == 0: #Ss did not respond
                crdm_msg1 = "NO RESPONSE"
            elif crdm_pract1_sure_key: #Ss chose sure amt
                crdm_msg1 = "CERTAIN $" + str(format(crdm_sure_amt1))
            else: #Ss chose lottery
                crdm_msg1 = "LOTTERY"
            crdm_pract1_feedback_txt.setText(crdm_msg1)
            # keep track of which components have finished
            crdm_pract1_feedbackComponents = [crdm_pract1_feedback_txt]
            for thisComponent in crdm_pract1_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract1_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract1_feedback_txt* updates
                
                # if crdm_pract1_feedback_txt is starting this frame...
                if crdm_pract1_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_feedback_txt.status = STARTED
                    crdm_pract1_feedback_txt.setAutoDraw(True)
                
                # if crdm_pract1_feedback_txt is active this frame...
                if crdm_pract1_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_feedback_txt is stopping this frame...
                if crdm_pract1_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_feedback_txt.status = FINISHED
                        crdm_pract1_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract1_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract1_feedback" ---
            for thisComponent in crdm_pract1_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract1_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_pract1_trials1'
        
        
        # --- Prepare to start Routine "crdm_qp_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_qp_instr.started', globalClock.getTime())
        crdm_qp_instr_resp.keys = []
        crdm_qp_instr_resp.rt = []
        _crdm_qp_instr_resp_allKeys = []
        # keep track of which components have finished
        crdm_qp_instrComponents = [crdm_qp_instr_title_txt, crdm_qp_instr_txt, crdm_qp_instr_space_txt, crdm_qp_instr_resp]
        for thisComponent in crdm_qp_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_qp_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_qp_instr_title_txt* updates
            
            # if crdm_qp_instr_title_txt is starting this frame...
            if crdm_qp_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_title_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_title_txt.status = STARTED
                crdm_qp_instr_title_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_title_txt is active this frame...
            if crdm_qp_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_txt* updates
            
            # if crdm_qp_instr_txt is starting this frame...
            if crdm_qp_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_txt.status = STARTED
                crdm_qp_instr_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_txt is active this frame...
            if crdm_qp_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_space_txt* updates
            
            # if crdm_qp_instr_space_txt is starting this frame...
            if crdm_qp_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_space_txt.status = STARTED
                crdm_qp_instr_space_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_space_txt is active this frame...
            if crdm_qp_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_resp* updates
            waitOnFlip = False
            
            # if crdm_qp_instr_resp is starting this frame...
            if crdm_qp_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_resp.frameNStart = frameN  # exact frame index
                crdm_qp_instr_resp.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_qp_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_qp_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_qp_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_qp_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_qp_instr_resp_allKeys.extend(theseKeys)
                if len(_crdm_qp_instr_resp_allKeys):
                    crdm_qp_instr_resp.keys = _crdm_qp_instr_resp_allKeys[-1].name  # just the last key pressed
                    crdm_qp_instr_resp.rt = _crdm_qp_instr_resp_allKeys[-1].rt
                    crdm_qp_instr_resp.duration = _crdm_qp_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_qp_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_qp_instr" ---
        for thisComponent in crdm_qp_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_qp_instr.stopped', globalClock.getTime())
        # the Routine "crdm_qp_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        crdm_qp_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_questplus_trials.csv'),
            seed=None, name='crdm_qp_trials1')
        thisExp.addLoop(crdm_qp_trials1)  # add the loop to the experiment
        thisCrdm_qp_trials1 = crdm_qp_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_qp_trials1.rgb)
        if thisCrdm_qp_trials1 != None:
            for paramName in thisCrdm_qp_trials1:
                globals()[paramName] = thisCrdm_qp_trials1[paramName]
        
        for thisCrdm_qp_trials1 in crdm_qp_trials1:
            currentLoop = crdm_qp_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_qp_trials1.rgb)
            if thisCrdm_qp_trials1 != None:
                for paramName in thisCrdm_qp_trials1:
                    globals()[paramName] = thisCrdm_qp_trials1[paramName]
            
            # --- Prepare to start Routine "crdm_questplus" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_questplus.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_questplus_JS
            my_loop = eval("questplus_trials")
            crdm_questplus_img.setImage("crdm/" + crdm_img_qp)
            crdm_questplus_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top_qp))))
            crdm_questplus_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot_qp))))
            crdm_questplus_trial_sure_amt_txt.setPos(crdm_sure_pos_qp)
            crdm_questplus_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt_qp)))
            )
            crdm_questplus_trial_resp.keys = []
            crdm_questplus_trial_resp.rt = []
            _crdm_questplus_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_questplusComponents = [crdm_questplus_img, crdm_questplus_trial_lott_top_txt, crdm_questplus_trial_lott_bot_txt, crdm_questplus_trial_sure_amt_txt, GRFX_fix3, crdm_questplus_trial_cue, crdm_questplus_trial_resp]
            for thisComponent in crdm_questplusComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_questplus" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_questplus_img* updates
                
                # if crdm_questplus_img is starting this frame...
                if crdm_questplus_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_img.frameNStart = frameN  # exact frame index
                    crdm_questplus_img.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_img.status = STARTED
                    crdm_questplus_img.setAutoDraw(True)
                
                # if crdm_questplus_img is active this frame...
                if crdm_questplus_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_img is stopping this frame...
                if crdm_questplus_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_img.tStop = t  # not accounting for scr refresh
                        crdm_questplus_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_img.status = FINISHED
                        crdm_questplus_img.setAutoDraw(False)
                
                # *crdm_questplus_trial_lott_top_txt* updates
                
                # if crdm_questplus_trial_lott_top_txt is starting this frame...
                if crdm_questplus_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_lott_top_txt.status = STARTED
                    crdm_questplus_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_lott_top_txt is active this frame...
                if crdm_questplus_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_lott_top_txt is stopping this frame...
                if crdm_questplus_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_lott_top_txt.status = FINISHED
                        crdm_questplus_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_questplus_trial_lott_bot_txt* updates
                
                # if crdm_questplus_trial_lott_bot_txt is starting this frame...
                if crdm_questplus_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_lott_bot_txt.status = STARTED
                    crdm_questplus_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_lott_bot_txt is active this frame...
                if crdm_questplus_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_lott_bot_txt is stopping this frame...
                if crdm_questplus_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_lott_bot_txt.status = FINISHED
                        crdm_questplus_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_questplus_trial_sure_amt_txt* updates
                
                # if crdm_questplus_trial_sure_amt_txt is starting this frame...
                if crdm_questplus_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_sure_amt_txt.status = STARTED
                    crdm_questplus_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_sure_amt_txt is active this frame...
                if crdm_questplus_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_sure_amt_txt is stopping this frame...
                if crdm_questplus_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_sure_amt_txt.status = FINISHED
                        crdm_questplus_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix3* updates
                
                # if GRFX_fix3 is starting this frame...
                if GRFX_fix3.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix3.frameNStart = frameN  # exact frame index
                    GRFX_fix3.tStart = t  # local t and not account for scr refresh
                    GRFX_fix3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix3.status = STARTED
                    GRFX_fix3.setAutoDraw(True)
                
                # if GRFX_fix3 is active this frame...
                if GRFX_fix3.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix3 is stopping this frame...
                if GRFX_fix3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix3.tStop = t  # not accounting for scr refresh
                        GRFX_fix3.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix3.status = FINISHED
                        GRFX_fix3.setAutoDraw(False)
                
                # *crdm_questplus_trial_cue* updates
                
                # if crdm_questplus_trial_cue is starting this frame...
                if crdm_questplus_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_cue.status = STARTED
                    crdm_questplus_trial_cue.setAutoDraw(True)
                
                # if crdm_questplus_trial_cue is active this frame...
                if crdm_questplus_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_cue is stopping this frame...
                if crdm_questplus_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_cue.status = FINISHED
                        crdm_questplus_trial_cue.setAutoDraw(False)
                
                # *crdm_questplus_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_questplus_trial_resp is starting this frame...
                if crdm_questplus_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_questplus_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_questplus_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_questplus_trial_resp is stopping this frame...
                if crdm_questplus_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_resp.status = FINISHED
                        crdm_questplus_trial_resp.status = FINISHED
                if crdm_questplus_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_questplus_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_questplus_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_questplus_trial_resp_allKeys):
                        crdm_questplus_trial_resp.keys = _crdm_questplus_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_questplus_trial_resp.rt = _crdm_questplus_trial_resp_allKeys[0].rt
                        crdm_questplus_trial_resp.duration = _crdm_questplus_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_questplus_trial_resp.keys == str(crdm_sure_resp_qp)) or (crdm_questplus_trial_resp.keys == crdm_sure_resp_qp):
                            crdm_questplus_trial_resp.corr = 1
                        else:
                            crdm_questplus_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_questplusComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_questplus" ---
            for thisComponent in crdm_questplusComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_questplus.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_questplus_JS
            qp_key = crdm_questplus_trial_resp.keys
            qp_sure_key = crdm_questplus_trial_resp.corr
            my_loop.addData("crdm_trial_type", "questplus")
            
            
            
            
            my_loop.addData("response", cur_response)
            my_loop.addData('mean_alpha', post_mean[0])
            my_loop.addData('mean_beta', post_mean[1])
            my_loop.addData('mean_gamma', post_mean[2])
            my_loop.addData('sd_alpha', post_sd[0])
            my_loop.addData('sd_beta', post_sd[1])
            my_loop.addData('sd_gamma', post_sd[2])
            my_loop.addData("lott_reward", cur_design["value_reward"])
            my_loop.addData("lott_prob", int(cur_design["p_reward"]*100))
            my_loop.addData("ambig_level", int(cur_design["amb_level"]*100))
            # check responses
            if crdm_questplus_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_questplus_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp_qp).lower() == 'none':
                   crdm_questplus_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_questplus_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_qp_trials1 (TrialHandler)
            crdm_qp_trials1.addData('crdm_questplus_trial_resp.keys',crdm_questplus_trial_resp.keys)
            crdm_qp_trials1.addData('crdm_questplus_trial_resp.corr', crdm_questplus_trial_resp.corr)
            if crdm_questplus_trial_resp.keys != None:  # we had a response
                crdm_qp_trials1.addData('crdm_questplus_trial_resp.rt', crdm_questplus_trial_resp.rt)
                crdm_qp_trials1.addData('crdm_questplus_trial_resp.duration', crdm_questplus_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_qp_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_qp_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_qp_feedback_code
            if len(crdm_qp_key) == 0: #Ss did not respond
                crdm_msg_qp  = "NO RESPONSE"
            elif crdm_qp_sure_key: #Ss chose sure amt
                crdm_msg_qp  = "CERTAIN $" + str(format(cur_design["value_null"]))
            else: #Ss chose lottery
                crdm_msg_qp  = "LOTTERY"
            crdm_qp_feedback_txt.setText(crdm_msg_qp)
            # keep track of which components have finished
            crdm_qp_feedbackComponents = [crdm_qp_feedback_txt]
            for thisComponent in crdm_qp_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_qp_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_qp_feedback_txt* updates
                
                # if crdm_qp_feedback_txt is starting this frame...
                if crdm_qp_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_qp_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_qp_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_qp_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_qp_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_qp_feedback_txt.status = STARTED
                    crdm_qp_feedback_txt.setAutoDraw(True)
                
                # if crdm_qp_feedback_txt is active this frame...
                if crdm_qp_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_qp_feedback_txt is stopping this frame...
                if crdm_qp_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_qp_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_qp_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_qp_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_qp_feedback_txt.status = FINISHED
                        crdm_qp_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_qp_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_qp_feedback" ---
            for thisComponent in crdm_qp_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_qp_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_qp_trials1'
        
        
        # --- Prepare to start Routine "crdm_schedule_gen" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_schedule_gen.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_schedule_genComponents = []
        for thisComponent in crdm_schedule_genComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_schedule_gen" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_schedule_genComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_schedule_gen" ---
        for thisComponent in crdm_schedule_genComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_schedule_gen.stopped', globalClock.getTime())
        # the Routine "crdm_schedule_gen" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_pract2_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_pract2_instr.started', globalClock.getTime())
        crdm_pract2_instr_key.keys = []
        crdm_pract2_instr_key.rt = []
        _crdm_pract2_instr_key_allKeys = []
        # keep track of which components have finished
        crdm_pract2_instrComponents = [crdm_pract2_instr_name_txt, crdm_pract2_instr_txt, crdm_pract2_instr_space_txt, crdm_pract2_instr_key]
        for thisComponent in crdm_pract2_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_pract2_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_pract2_instr_name_txt* updates
            
            # if crdm_pract2_instr_name_txt is starting this frame...
            if crdm_pract2_instr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_name_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_name_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_name_txt.status = STARTED
                crdm_pract2_instr_name_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_name_txt is active this frame...
            if crdm_pract2_instr_name_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_txt* updates
            
            # if crdm_pract2_instr_txt is starting this frame...
            if crdm_pract2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_txt.status = STARTED
                crdm_pract2_instr_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_txt is active this frame...
            if crdm_pract2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_space_txt* updates
            
            # if crdm_pract2_instr_space_txt is starting this frame...
            if crdm_pract2_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_space_txt.status = STARTED
                crdm_pract2_instr_space_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_space_txt is active this frame...
            if crdm_pract2_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_key* updates
            waitOnFlip = False
            
            # if crdm_pract2_instr_key is starting this frame...
            if crdm_pract2_instr_key.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_key.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_key.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_key.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_key, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_key.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_pract2_instr_key.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_pract2_instr_key.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_pract2_instr_key.status == STARTED and not waitOnFlip:
                theseKeys = crdm_pract2_instr_key.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_pract2_instr_key_allKeys.extend(theseKeys)
                if len(_crdm_pract2_instr_key_allKeys):
                    crdm_pract2_instr_key.keys = _crdm_pract2_instr_key_allKeys[-1].name  # just the last key pressed
                    crdm_pract2_instr_key.rt = _crdm_pract2_instr_key_allKeys[-1].rt
                    crdm_pract2_instr_key.duration = _crdm_pract2_instr_key_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_pract2_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_pract2_instr" ---
        for thisComponent in crdm_pract2_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_pract2_instr.stopped', globalClock.getTime())
        # the Routine "crdm_pract2_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_pract2_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_practice2.csv'),
            seed=None, name='crdm_pract2_trials1')
        thisExp.addLoop(crdm_pract2_trials1)  # add the loop to the experiment
        thisCrdm_pract2_trials1 = crdm_pract2_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract2_trials1.rgb)
        if thisCrdm_pract2_trials1 != None:
            for paramName in thisCrdm_pract2_trials1:
                globals()[paramName] = thisCrdm_pract2_trials1[paramName]
        
        for thisCrdm_pract2_trials1 in crdm_pract2_trials1:
            currentLoop = crdm_pract2_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract2_trials1.rgb)
            if thisCrdm_pract2_trials1 != None:
                for paramName in thisCrdm_pract2_trials1:
                    globals()[paramName] = thisCrdm_pract2_trials1[paramName]
            
            # --- Prepare to start Routine "crdm_pract2_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_trial_code
            my_loop = eval(crdm_practice_loop2_name)
            
            #random index for certain outcome position and response
            crdm_idx2 = random.randint(0,1) 
            crdm_sure_pos2 = crdm_pos2[crdm_idx2] 
            crdm_sure_resp2 = crdm_resp2[crdm_idx2]
            crdm_pract2_trial_img.setImage("crdm/" + crdm_img2)
            crdm_pract2_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top2))))
            crdm_pract2_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot2))))
            crdm_pract2_trial_sure_amt_txt.setPos(crdm_sure_pos2)
            crdm_pract2_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt2)))
            )
            crdm_pract2_trial_resp.keys = []
            crdm_pract2_trial_resp.rt = []
            _crdm_pract2_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract2_trialComponents = [crdm_pract2_trial_img, crdm_pract2_trial_lott_top_txt, crdm_pract2_trial_lott_bot_txt, crdm_pract2_trial_sure_amt_txt, GRFX_fix2, crdm_pract2_trial_cue, crdm_pract2_trial_resp]
            for thisComponent in crdm_pract2_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_trial_img* updates
                
                # if crdm_pract2_trial_img is starting this frame...
                if crdm_pract2_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_img.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_img.status = STARTED
                    crdm_pract2_trial_img.setAutoDraw(True)
                
                # if crdm_pract2_trial_img is active this frame...
                if crdm_pract2_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_img is stopping this frame...
                if crdm_pract2_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_img.status = FINISHED
                        crdm_pract2_trial_img.setAutoDraw(False)
                
                # *crdm_pract2_trial_lott_top_txt* updates
                
                # if crdm_pract2_trial_lott_top_txt is starting this frame...
                if crdm_pract2_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_lott_top_txt.status = STARTED
                    crdm_pract2_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_lott_top_txt is active this frame...
                if crdm_pract2_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_lott_top_txt is stopping this frame...
                if crdm_pract2_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_lott_top_txt.status = FINISHED
                        crdm_pract2_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_pract2_trial_lott_bot_txt* updates
                
                # if crdm_pract2_trial_lott_bot_txt is starting this frame...
                if crdm_pract2_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_lott_bot_txt.status = STARTED
                    crdm_pract2_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_lott_bot_txt is active this frame...
                if crdm_pract2_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_lott_bot_txt is stopping this frame...
                if crdm_pract2_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_lott_bot_txt.status = FINISHED
                        crdm_pract2_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_pract2_trial_sure_amt_txt* updates
                
                # if crdm_pract2_trial_sure_amt_txt is starting this frame...
                if crdm_pract2_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_sure_amt_txt.status = STARTED
                    crdm_pract2_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_sure_amt_txt is active this frame...
                if crdm_pract2_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_sure_amt_txt is stopping this frame...
                if crdm_pract2_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_sure_amt_txt.status = FINISHED
                        crdm_pract2_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix2* updates
                
                # if GRFX_fix2 is starting this frame...
                if GRFX_fix2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix2.frameNStart = frameN  # exact frame index
                    GRFX_fix2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix2.status = STARTED
                    GRFX_fix2.setAutoDraw(True)
                
                # if GRFX_fix2 is active this frame...
                if GRFX_fix2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix2 is stopping this frame...
                if GRFX_fix2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix2.tStop = t  # not accounting for scr refresh
                        GRFX_fix2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix2.status = FINISHED
                        GRFX_fix2.setAutoDraw(False)
                
                # *crdm_pract2_trial_cue* updates
                
                # if crdm_pract2_trial_cue is starting this frame...
                if crdm_pract2_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_cue.status = STARTED
                    crdm_pract2_trial_cue.setAutoDraw(True)
                
                # if crdm_pract2_trial_cue is active this frame...
                if crdm_pract2_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_cue is stopping this frame...
                if crdm_pract2_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_cue.status = FINISHED
                        crdm_pract2_trial_cue.setAutoDraw(False)
                
                # *crdm_pract2_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_pract2_trial_resp is starting this frame...
                if crdm_pract2_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract2_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract2_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract2_trial_resp is stopping this frame...
                if crdm_pract2_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_resp.status = FINISHED
                        crdm_pract2_trial_resp.status = FINISHED
                if crdm_pract2_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract2_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract2_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract2_trial_resp_allKeys):
                        crdm_pract2_trial_resp.keys = _crdm_pract2_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_pract2_trial_resp.rt = _crdm_pract2_trial_resp_allKeys[0].rt
                        crdm_pract2_trial_resp.duration = _crdm_pract2_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_pract2_trial_resp.keys == str(crdm_sure_resp2)) or (crdm_pract2_trial_resp.keys == crdm_sure_resp2):
                            crdm_pract2_trial_resp.corr = 1
                        else:
                            crdm_pract2_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_trial" ---
            for thisComponent in crdm_pract2_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_pract2_trial_code
            crdm_pract2_key = crdm_pract2_trial_resp.keys
            crdm_pract2_sure_key = crdm_pract2_trial_resp.corr
            
            my_loop.addData("crdm_trial_type", "practice2")
            # check responses
            if crdm_pract2_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_pract2_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp2).lower() == 'none':
                   crdm_pract2_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_pract2_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_pract2_trials1 (TrialHandler)
            crdm_pract2_trials1.addData('crdm_pract2_trial_resp.keys',crdm_pract2_trial_resp.keys)
            crdm_pract2_trials1.addData('crdm_pract2_trial_resp.corr', crdm_pract2_trial_resp.corr)
            if crdm_pract2_trial_resp.keys != None:  # we had a response
                crdm_pract2_trials1.addData('crdm_pract2_trial_resp.rt', crdm_pract2_trial_resp.rt)
                crdm_pract2_trials1.addData('crdm_pract2_trial_resp.duration', crdm_pract2_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_pract2_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_feedback_code
            if len(crdm_pract2_key) == 0: #Ss did not respond
                crdm_msg2 = "NO RESPONSE"
            elif crdm_pract2_sure_key: #Ss chose sure amt
                crdm_msg2 = "CERTAIN $" + str(format(crdm_sure_amt2))
            else: #Ss chose lottery
                crdm_msg2 = "LOTTERY"
            crdm_pract2_feedback_txt.setText(crdm_msg2)
            # keep track of which components have finished
            crdm_pract2_feedbackComponents = [crdm_pract2_feedback_txt]
            for thisComponent in crdm_pract2_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_feedback_txt* updates
                
                # if crdm_pract2_feedback_txt is starting this frame...
                if crdm_pract2_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_feedback_txt.status = STARTED
                    crdm_pract2_feedback_txt.setAutoDraw(True)
                
                # if crdm_pract2_feedback_txt is active this frame...
                if crdm_pract2_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_feedback_txt is stopping this frame...
                if crdm_pract2_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_feedback_txt.status = FINISHED
                        crdm_pract2_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_feedback" ---
            for thisComponent in crdm_pract2_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "crdm_pract2_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_conf_code
            #Ss did not respond
            if len(crdm_pract2_key) == 0: 
                continueRoutine = False
            
            #set default gray for all four response boxes
            conf1_color = [0, 0, 0] 
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            crdm_pract2_conf_resp.keys = []
            crdm_pract2_conf_resp.rt = []
            _crdm_pract2_conf_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract2_confComponents = [crdm_pract2_conf_txt, crdm_pract2_conf1, crdm_pract2_conf1_txt, crdm_pract2_conf2, crdm_pract2_conf2_txt, crdm_pract2_conf3, crdm_pract2_conf3_txt, crdm_pract2_conf4, crdm_pract2_conf4_txt, crdm_pract2_conf_resp]
            for thisComponent in crdm_pract2_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_pract2_conf_code
                #resp is received
                crdm_pract_conf_key = crdm_pract2_conf_resp.keys
                if len(crdm_pract_conf_key) == 1:
                    #not at all confident
                    if crdm_pract_conf_key == "1":
                        #change box color to indicate selection
                        conf1_color = "darkgray" 
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    #less confident
                    elif crdm_pract_conf_key == "2": 
                        conf1_color = [0,0,0]
                        conf2_color = "darkgray"
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    #somewhat confident
                    elif crdm_pract_conf_key == "3": 
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = "darkgray"
                        conf4_color = [0,0,0]
                    #very confident
                    elif crdm_pract_conf_key == "4": 
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = "darkgray"
                
                # *crdm_pract2_conf_txt* updates
                
                # if crdm_pract2_conf_txt is starting this frame...
                if crdm_pract2_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf_txt.status = STARTED
                    crdm_pract2_conf_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf_txt is active this frame...
                if crdm_pract2_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf_txt is stopping this frame...
                if crdm_pract2_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf_txt.status = FINISHED
                        crdm_pract2_conf_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf1* updates
                
                # if crdm_pract2_conf1 is starting this frame...
                if crdm_pract2_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf1.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf1.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf1.status = STARTED
                    crdm_pract2_conf1.setAutoDraw(True)
                
                # if crdm_pract2_conf1 is active this frame...
                if crdm_pract2_conf1.status == STARTED:
                    # update params
                    crdm_pract2_conf1.setFillColor(conf1_color, log=False)
                
                # if crdm_pract2_conf1 is stopping this frame...
                if crdm_pract2_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf1.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf1.status = FINISHED
                        crdm_pract2_conf1.setAutoDraw(False)
                
                # *crdm_pract2_conf1_txt* updates
                
                # if crdm_pract2_conf1_txt is starting this frame...
                if crdm_pract2_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf1_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf1_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf1_txt.status = STARTED
                    crdm_pract2_conf1_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf1_txt is active this frame...
                if crdm_pract2_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf1_txt is stopping this frame...
                if crdm_pract2_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf1_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf1_txt.status = FINISHED
                        crdm_pract2_conf1_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf2* updates
                
                # if crdm_pract2_conf2 is starting this frame...
                if crdm_pract2_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf2.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf2.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf2.status = STARTED
                    crdm_pract2_conf2.setAutoDraw(True)
                
                # if crdm_pract2_conf2 is active this frame...
                if crdm_pract2_conf2.status == STARTED:
                    # update params
                    crdm_pract2_conf2.setFillColor(conf2_color, log=False)
                
                # if crdm_pract2_conf2 is stopping this frame...
                if crdm_pract2_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf2.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf2.status = FINISHED
                        crdm_pract2_conf2.setAutoDraw(False)
                
                # *crdm_pract2_conf2_txt* updates
                
                # if crdm_pract2_conf2_txt is starting this frame...
                if crdm_pract2_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf2_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf2_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf2_txt.status = STARTED
                    crdm_pract2_conf2_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf2_txt is active this frame...
                if crdm_pract2_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf2_txt is stopping this frame...
                if crdm_pract2_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf2_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf2_txt.status = FINISHED
                        crdm_pract2_conf2_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf3* updates
                
                # if crdm_pract2_conf3 is starting this frame...
                if crdm_pract2_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf3.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf3.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf3.status = STARTED
                    crdm_pract2_conf3.setAutoDraw(True)
                
                # if crdm_pract2_conf3 is active this frame...
                if crdm_pract2_conf3.status == STARTED:
                    # update params
                    crdm_pract2_conf3.setFillColor(conf3_color, log=False)
                
                # if crdm_pract2_conf3 is stopping this frame...
                if crdm_pract2_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf3.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf3.status = FINISHED
                        crdm_pract2_conf3.setAutoDraw(False)
                
                # *crdm_pract2_conf3_txt* updates
                
                # if crdm_pract2_conf3_txt is starting this frame...
                if crdm_pract2_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf3_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf3_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf3_txt.status = STARTED
                    crdm_pract2_conf3_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf3_txt is active this frame...
                if crdm_pract2_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf3_txt is stopping this frame...
                if crdm_pract2_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf3_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf3_txt.status = FINISHED
                        crdm_pract2_conf3_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf4* updates
                
                # if crdm_pract2_conf4 is starting this frame...
                if crdm_pract2_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf4.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf4.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf4.status = STARTED
                    crdm_pract2_conf4.setAutoDraw(True)
                
                # if crdm_pract2_conf4 is active this frame...
                if crdm_pract2_conf4.status == STARTED:
                    # update params
                    crdm_pract2_conf4.setFillColor(conf4_color, log=False)
                
                # if crdm_pract2_conf4 is stopping this frame...
                if crdm_pract2_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf4.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf4.status = FINISHED
                        crdm_pract2_conf4.setAutoDraw(False)
                
                # *crdm_pract2_conf4_txt* updates
                
                # if crdm_pract2_conf4_txt is starting this frame...
                if crdm_pract2_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf4_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf4_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf4_txt.status = STARTED
                    crdm_pract2_conf4_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf4_txt is active this frame...
                if crdm_pract2_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf4_txt is stopping this frame...
                if crdm_pract2_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf4_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf4_txt.status = FINISHED
                        crdm_pract2_conf4_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf_resp* updates
                waitOnFlip = False
                
                # if crdm_pract2_conf_resp is starting this frame...
                if crdm_pract2_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf_resp.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract2_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract2_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract2_conf_resp is stopping this frame...
                if crdm_pract2_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf_resp.status = FINISHED
                        crdm_pract2_conf_resp.status = FINISHED
                if crdm_pract2_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract2_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract2_conf_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract2_conf_resp_allKeys):
                        crdm_pract2_conf_resp.keys = _crdm_pract2_conf_resp_allKeys[-1].name  # just the last key pressed
                        crdm_pract2_conf_resp.rt = _crdm_pract2_conf_resp_allKeys[-1].rt
                        crdm_pract2_conf_resp.duration = _crdm_pract2_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_conf" ---
            for thisComponent in crdm_pract2_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_conf.stopped', globalClock.getTime())
            # check responses
            if crdm_pract2_conf_resp.keys in ['', [], None]:  # No response was made
                crdm_pract2_conf_resp.keys = None
            crdm_pract2_trials1.addData('crdm_pract2_conf_resp.keys',crdm_pract2_conf_resp.keys)
            if crdm_pract2_conf_resp.keys != None:  # we had a response
                crdm_pract2_trials1.addData('crdm_pract2_conf_resp.rt', crdm_pract2_conf_resp.rt)
                crdm_pract2_trials1.addData('crdm_pract2_conf_resp.duration', crdm_pract2_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "crdm_pract2_iti1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_iti1.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_iti1_code
            #3 CRDM practice trials
            if crdm_pract2_trials1.thisTrialN == 5:
                continueRoutine = False
            # keep track of which components have finished
            crdm_pract2_iti1Components = [crdm_pract2_iti1_poly]
            for thisComponent in crdm_pract2_iti1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_iti1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_iti1_poly* updates
                
                # if crdm_pract2_iti1_poly is starting this frame...
                if crdm_pract2_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_iti1_poly.frameNStart = frameN  # exact frame index
                    crdm_pract2_iti1_poly.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_iti1_poly.status = STARTED
                    crdm_pract2_iti1_poly.setAutoDraw(True)
                
                # if crdm_pract2_iti1_poly is active this frame...
                if crdm_pract2_iti1_poly.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_iti1_poly is stopping this frame...
                if crdm_pract2_iti1_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_iti1_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_iti1_poly.tStop = t  # not accounting for scr refresh
                        crdm_pract2_iti1_poly.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_iti1_poly.status = FINISHED
                        crdm_pract2_iti1_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_iti1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_iti1" ---
            for thisComponent in crdm_pract2_iti1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_iti1.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_pract2_trials1'
        
        
        # --- Prepare to start Routine "crdm_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_trial_instr.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_trial_instr_code
        crdm_task_resps = []
        crdm_conf_resps = []
        crdm_catch_trials = []
        crdm_iti_list = [random.random() for i in range(144)] #create list of random floats (0-1) which is length of trial schedule
        crdm_s = sum(crdm_iti_list) #sum list of rnadom floats
        crdm_iti_list = [i*144/crdm_s for i in crdm_iti_list] #for each item in iti_list: multiple by list length, then divide by list sum
        crdm_trial_instr_resp.keys = []
        crdm_trial_instr_resp.rt = []
        _crdm_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        crdm_trial_instrComponents = [crdm_trial_instr_title_txt, crdm_trial_instr_txt, crdm_trial_instr_space_txt, crdm_trial_instr_resp]
        for thisComponent in crdm_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_trial_instr_title_txt* updates
            
            # if crdm_trial_instr_title_txt is starting this frame...
            if crdm_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_title_txt.status = STARTED
                crdm_trial_instr_title_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_title_txt is active this frame...
            if crdm_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_txt* updates
            
            # if crdm_trial_instr_txt is starting this frame...
            if crdm_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_txt.status = STARTED
                crdm_trial_instr_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_txt is active this frame...
            if crdm_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_space_txt* updates
            
            # if crdm_trial_instr_space_txt is starting this frame...
            if crdm_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_space_txt.status = STARTED
                crdm_trial_instr_space_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_space_txt is active this frame...
            if crdm_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_resp* updates
            waitOnFlip = False
            
            # if crdm_trial_instr_resp is starting this frame...
            if crdm_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_resp.frameNStart = frameN  # exact frame index
                crdm_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_crdm_trial_instr_resp_allKeys):
                    crdm_trial_instr_resp.keys = _crdm_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    crdm_trial_instr_resp.rt = _crdm_trial_instr_resp_allKeys[-1].rt
                    crdm_trial_instr_resp.duration = _crdm_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_trial_instr" ---
        for thisComponent in crdm_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_trial_instr.stopped', globalClock.getTime())
        # the Routine "crdm_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_gen_trials_idx.csv'),
            seed=None, name='crdm_trials1')
        thisExp.addLoop(crdm_trials1)  # add the loop to the experiment
        thisCrdm_trials1 = crdm_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_trials1.rgb)
        if thisCrdm_trials1 != None:
            for paramName in thisCrdm_trials1:
                globals()[paramName] = thisCrdm_trials1[paramName]
        
        for thisCrdm_trials1 in crdm_trials1:
            currentLoop = crdm_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_trials1.rgb)
            if thisCrdm_trials1 != None:
                for paramName in thisCrdm_trials1:
                    globals()[paramName] = thisCrdm_trials1[paramName]
            
            # --- Prepare to start Routine "crdm_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_trial_JS
            v
            crdm_trial_img.setImage("crdm/" + crdm_img)
            crdm_trial_lott_top.setText(str("$"+str(format(crdm_lott_top))))
            crdm_trial_lott_bot.setText(str("$"+str(format(crdm_lott_bot))))
            crdm_trial_sure_amt.setPos(crdm_sure_pos)
            crdm_trial_sure_amt.setText(str("$"+str(format(crdm_sure_amt))))
            crdm_trial_resp.keys = []
            crdm_trial_resp.rt = []
            _crdm_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_trialComponents = [crdm_trial_img, crdm_trial_lott_top, crdm_trial_lott_bot, crdm_trial_sure_amt, GRFX_fix, crdm_trial_cue, crdm_trial_resp]
            for thisComponent in crdm_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_trial_JS
                v
                
                # *crdm_trial_img* updates
                
                # if crdm_trial_img is starting this frame...
                if crdm_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_img.frameNStart = frameN  # exact frame index
                    crdm_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trial_img.started')
                    # update status
                    crdm_trial_img.status = STARTED
                    crdm_trial_img.setAutoDraw(True)
                
                # if crdm_trial_img is active this frame...
                if crdm_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_img is stopping this frame...
                if crdm_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_trial_img.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trial_img.stopped')
                        # update status
                        crdm_trial_img.status = FINISHED
                        crdm_trial_img.setAutoDraw(False)
                
                # *crdm_trial_lott_top* updates
                
                # if crdm_trial_lott_top is starting this frame...
                if crdm_trial_lott_top.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_lott_top.frameNStart = frameN  # exact frame index
                    crdm_trial_lott_top.tStart = t  # local t and not account for scr refresh
                    crdm_trial_lott_top.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_lott_top, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_lott_top.status = STARTED
                    crdm_trial_lott_top.setAutoDraw(True)
                
                # if crdm_trial_lott_top is active this frame...
                if crdm_trial_lott_top.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_lott_top is stopping this frame...
                if crdm_trial_lott_top.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_lott_top.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_lott_top.tStop = t  # not accounting for scr refresh
                        crdm_trial_lott_top.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_lott_top.status = FINISHED
                        crdm_trial_lott_top.setAutoDraw(False)
                
                # *crdm_trial_lott_bot* updates
                
                # if crdm_trial_lott_bot is starting this frame...
                if crdm_trial_lott_bot.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_lott_bot.frameNStart = frameN  # exact frame index
                    crdm_trial_lott_bot.tStart = t  # local t and not account for scr refresh
                    crdm_trial_lott_bot.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_lott_bot, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_lott_bot.status = STARTED
                    crdm_trial_lott_bot.setAutoDraw(True)
                
                # if crdm_trial_lott_bot is active this frame...
                if crdm_trial_lott_bot.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_lott_bot is stopping this frame...
                if crdm_trial_lott_bot.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_lott_bot.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_lott_bot.tStop = t  # not accounting for scr refresh
                        crdm_trial_lott_bot.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_lott_bot.status = FINISHED
                        crdm_trial_lott_bot.setAutoDraw(False)
                
                # *crdm_trial_sure_amt* updates
                
                # if crdm_trial_sure_amt is starting this frame...
                if crdm_trial_sure_amt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_sure_amt.frameNStart = frameN  # exact frame index
                    crdm_trial_sure_amt.tStart = t  # local t and not account for scr refresh
                    crdm_trial_sure_amt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_sure_amt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_sure_amt.status = STARTED
                    crdm_trial_sure_amt.setAutoDraw(True)
                
                # if crdm_trial_sure_amt is active this frame...
                if crdm_trial_sure_amt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_sure_amt is stopping this frame...
                if crdm_trial_sure_amt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_sure_amt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_sure_amt.tStop = t  # not accounting for scr refresh
                        crdm_trial_sure_amt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_sure_amt.status = FINISHED
                        crdm_trial_sure_amt.setAutoDraw(False)
                
                # *GRFX_fix* updates
                
                # if GRFX_fix is starting this frame...
                if GRFX_fix.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix.frameNStart = frameN  # exact frame index
                    GRFX_fix.tStart = t  # local t and not account for scr refresh
                    GRFX_fix.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix.status = STARTED
                    GRFX_fix.setAutoDraw(True)
                
                # if GRFX_fix is active this frame...
                if GRFX_fix.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix is stopping this frame...
                if GRFX_fix.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix.tStop = t  # not accounting for scr refresh
                        GRFX_fix.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix.status = FINISHED
                        GRFX_fix.setAutoDraw(False)
                
                # *crdm_trial_cue* updates
                
                # if crdm_trial_cue is starting this frame...
                if crdm_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trial_cue.started')
                    # update status
                    crdm_trial_cue.status = STARTED
                    crdm_trial_cue.setAutoDraw(True)
                
                # if crdm_trial_cue is active this frame...
                if crdm_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_cue is stopping this frame...
                if crdm_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_trial_cue.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trial_cue.stopped')
                        # update status
                        crdm_trial_cue.status = FINISHED
                        crdm_trial_cue.setAutoDraw(False)
                
                # *crdm_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_trial_resp is starting this frame...
                if crdm_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_trial_resp is stopping this frame...
                if crdm_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_resp.status = FINISHED
                        crdm_trial_resp.status = FINISHED
                if crdm_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_trial_resp_allKeys):
                        crdm_trial_resp.keys = _crdm_trial_resp_allKeys[-1].name  # just the last key pressed
                        crdm_trial_resp.rt = _crdm_trial_resp_allKeys[-1].rt
                        crdm_trial_resp.duration = _crdm_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (crdm_trial_resp.keys == str(crdm_sure_resp)) or (crdm_trial_resp.keys == crdm_sure_resp):
                            crdm_trial_resp.corr = 1
                        else:
                            crdm_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_trial" ---
            for thisComponent in crdm_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_trial.stopped', globalClock.getTime())
            # check responses
            if crdm_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp).lower() == 'none':
                   crdm_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_trials1 (TrialHandler)
            crdm_trials1.addData('crdm_trial_resp.keys',crdm_trial_resp.keys)
            crdm_trials1.addData('crdm_trial_resp.corr', crdm_trial_resp.corr)
            if crdm_trial_resp.keys != None:  # we had a response
                crdm_trials1.addData('crdm_trial_resp.rt', crdm_trial_resp.rt)
                crdm_trials1.addData('crdm_trial_resp.duration', crdm_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_feedback_code
            if len(crdm_key) == 0: #Ss did not respond
                crdm_msg = "NO RESPONSE"
            elif crdm_sure_key: #Ss chose sure $5
                crdm_msg = "CERTAIN $" + str(format(crdm_sure_amt))
            else: #Ss chose lottery
                crdm_msg = "LOTTERY"
            crdm_feedback_txt.setText(crdm_msg)
            # keep track of which components have finished
            crdm_feedbackComponents = [crdm_feedback_txt]
            for thisComponent in crdm_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_feedback_txt* updates
                
                # if crdm_feedback_txt is starting this frame...
                if crdm_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_feedback_txt.status = STARTED
                    crdm_feedback_txt.setAutoDraw(True)
                
                # if crdm_feedback_txt is active this frame...
                if crdm_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_feedback_txt is stopping this frame...
                if crdm_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_feedback_txt.status = FINISHED
                        crdm_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_feedback" ---
            for thisComponent in crdm_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "crdm_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_conf_code
            if len(crdm_key) == 0: #Ss did not respond
                continueRoutine = False #do not run conf routine
            
            #set default gray for all four response boxes
            conf1_color = [0, 0, 0] 
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            crdm_conf_resp.keys = []
            crdm_conf_resp.rt = []
            _crdm_conf_resp_allKeys = []
            # keep track of which components have finished
            crdm_confComponents = [crdm_conf_txt, crdm_conf1, crdm_conf1_txt, crdm_conf2, crdm_conf2_txt, crdm_conf3, crdm_conf3_txt, crdm_conf4, crdm_conf4_txt, crdm_conf_resp]
            for thisComponent in crdm_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_conf_code
                crdm_conf_key = crdm_conf_resp.keys
                if len(crdm_conf_key) == 1: #Ss responded
                    if crdm_conf_key == "1": #not at all confident
                        #change box color to indicate selection
                        conf1_color = "darkgray" 
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "2": #less confident
                        conf1_color = [0,0,0]
                        conf2_color = "darkgray"
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "3": #somewhat confident
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = "darkgray"
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "4": #very confident
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = "darkgray"
                
                # *crdm_conf_txt* updates
                
                # if crdm_conf_txt is starting this frame...
                if crdm_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf_txt.frameNStart = frameN  # exact frame index
                    crdm_conf_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf_txt.status = STARTED
                    crdm_conf_txt.setAutoDraw(True)
                
                # if crdm_conf_txt is active this frame...
                if crdm_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf_txt is stopping this frame...
                if crdm_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf_txt.status = FINISHED
                        crdm_conf_txt.setAutoDraw(False)
                
                # *crdm_conf1* updates
                
                # if crdm_conf1 is starting this frame...
                if crdm_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf1.frameNStart = frameN  # exact frame index
                    crdm_conf1.tStart = t  # local t and not account for scr refresh
                    crdm_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf1.status = STARTED
                    crdm_conf1.setAutoDraw(True)
                
                # if crdm_conf1 is active this frame...
                if crdm_conf1.status == STARTED:
                    # update params
                    crdm_conf1.setFillColor(conf1_color, log=False)
                
                # if crdm_conf1 is stopping this frame...
                if crdm_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf1.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf1.tStop = t  # not accounting for scr refresh
                        crdm_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf1.status = FINISHED
                        crdm_conf1.setAutoDraw(False)
                
                # *crdm_conf1_txt* updates
                
                # if crdm_conf1_txt is starting this frame...
                if crdm_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf1_txt.frameNStart = frameN  # exact frame index
                    crdm_conf1_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf1_txt.status = STARTED
                    crdm_conf1_txt.setAutoDraw(True)
                
                # if crdm_conf1_txt is active this frame...
                if crdm_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf1_txt is stopping this frame...
                if crdm_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf1_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf1_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf1_txt.status = FINISHED
                        crdm_conf1_txt.setAutoDraw(False)
                
                # *crdm_conf2* updates
                
                # if crdm_conf2 is starting this frame...
                if crdm_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf2.frameNStart = frameN  # exact frame index
                    crdm_conf2.tStart = t  # local t and not account for scr refresh
                    crdm_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf2.status = STARTED
                    crdm_conf2.setAutoDraw(True)
                
                # if crdm_conf2 is active this frame...
                if crdm_conf2.status == STARTED:
                    # update params
                    crdm_conf2.setFillColor(conf2_color, log=False)
                
                # if crdm_conf2 is stopping this frame...
                if crdm_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf2.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf2.tStop = t  # not accounting for scr refresh
                        crdm_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf2.status = FINISHED
                        crdm_conf2.setAutoDraw(False)
                
                # *crdm_conf2_txt* updates
                
                # if crdm_conf2_txt is starting this frame...
                if crdm_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf2_txt.frameNStart = frameN  # exact frame index
                    crdm_conf2_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf2_txt.status = STARTED
                    crdm_conf2_txt.setAutoDraw(True)
                
                # if crdm_conf2_txt is active this frame...
                if crdm_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf2_txt is stopping this frame...
                if crdm_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf2_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf2_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf2_txt.status = FINISHED
                        crdm_conf2_txt.setAutoDraw(False)
                
                # *crdm_conf3* updates
                
                # if crdm_conf3 is starting this frame...
                if crdm_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf3.frameNStart = frameN  # exact frame index
                    crdm_conf3.tStart = t  # local t and not account for scr refresh
                    crdm_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf3.status = STARTED
                    crdm_conf3.setAutoDraw(True)
                
                # if crdm_conf3 is active this frame...
                if crdm_conf3.status == STARTED:
                    # update params
                    crdm_conf3.setFillColor(conf3_color, log=False)
                
                # if crdm_conf3 is stopping this frame...
                if crdm_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf3.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf3.tStop = t  # not accounting for scr refresh
                        crdm_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf3.status = FINISHED
                        crdm_conf3.setAutoDraw(False)
                
                # *crdm_conf3_txt* updates
                
                # if crdm_conf3_txt is starting this frame...
                if crdm_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf3_txt.frameNStart = frameN  # exact frame index
                    crdm_conf3_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf3_txt.status = STARTED
                    crdm_conf3_txt.setAutoDraw(True)
                
                # if crdm_conf3_txt is active this frame...
                if crdm_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf3_txt is stopping this frame...
                if crdm_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf3_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf3_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf3_txt.status = FINISHED
                        crdm_conf3_txt.setAutoDraw(False)
                
                # *crdm_conf4* updates
                
                # if crdm_conf4 is starting this frame...
                if crdm_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf4.frameNStart = frameN  # exact frame index
                    crdm_conf4.tStart = t  # local t and not account for scr refresh
                    crdm_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf4.status = STARTED
                    crdm_conf4.setAutoDraw(True)
                
                # if crdm_conf4 is active this frame...
                if crdm_conf4.status == STARTED:
                    # update params
                    crdm_conf4.setFillColor(conf4_color, log=False)
                
                # if crdm_conf4 is stopping this frame...
                if crdm_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf4.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf4.tStop = t  # not accounting for scr refresh
                        crdm_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf4.status = FINISHED
                        crdm_conf4.setAutoDraw(False)
                
                # *crdm_conf4_txt* updates
                
                # if crdm_conf4_txt is starting this frame...
                if crdm_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf4_txt.frameNStart = frameN  # exact frame index
                    crdm_conf4_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf4_txt.status = STARTED
                    crdm_conf4_txt.setAutoDraw(True)
                
                # if crdm_conf4_txt is active this frame...
                if crdm_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf4_txt is stopping this frame...
                if crdm_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf4_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf4_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf4_txt.status = FINISHED
                        crdm_conf4_txt.setAutoDraw(False)
                
                # *crdm_conf_resp* updates
                waitOnFlip = False
                
                # if crdm_conf_resp is starting this frame...
                if crdm_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf_resp.frameNStart = frameN  # exact frame index
                    crdm_conf_resp.tStart = t  # local t and not account for scr refresh
                    crdm_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_conf_resp is stopping this frame...
                if crdm_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf_resp.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf_resp.tStop = t  # not accounting for scr refresh
                        crdm_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf_resp.status = FINISHED
                        crdm_conf_resp.status = FINISHED
                if crdm_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_conf_resp_allKeys.extend(theseKeys)
                    if len(_crdm_conf_resp_allKeys):
                        crdm_conf_resp.keys = _crdm_conf_resp_allKeys[-1].name  # just the last key pressed
                        crdm_conf_resp.rt = _crdm_conf_resp_allKeys[-1].rt
                        crdm_conf_resp.duration = _crdm_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_conf" ---
            for thisComponent in crdm_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_conf.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_conf_code
            my_loop.addData("crdm_conf", crdm_conf_key);
            # check responses
            if crdm_conf_resp.keys in ['', [], None]:  # No response was made
                crdm_conf_resp.keys = None
            crdm_trials1.addData('crdm_conf_resp.keys',crdm_conf_resp.keys)
            if crdm_conf_resp.keys != None:  # we had a response
                crdm_trials1.addData('crdm_conf_resp.rt', crdm_conf_resp.rt)
                crdm_trials1.addData('crdm_conf_resp.duration', crdm_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.500000)
            
            # --- Prepare to start Routine "crdm_trials_iti1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_trials_iti1.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_trials_iti1_code
            crdm_iti_time = crdm_iti_list[my_loop.thisIndex] + crdm_delta_time #variable ITI for non-practice trials
            
            if crdm_trials1.thisTrialN == 143: #final trial (number of trials - 1)
                continueRoutine = False #don't present ITI fixation
            # keep track of which components have finished
            crdm_trials_iti1Components = [crdm_trials_iti1_poly]
            for thisComponent in crdm_trials_iti1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_trials_iti1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_trials_iti1_poly* updates
                
                # if crdm_trials_iti1_poly is starting this frame...
                if crdm_trials_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trials_iti1_poly.frameNStart = frameN  # exact frame index
                    crdm_trials_iti1_poly.tStart = t  # local t and not account for scr refresh
                    crdm_trials_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trials_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trials_iti1_poly.started')
                    # update status
                    crdm_trials_iti1_poly.status = STARTED
                    crdm_trials_iti1_poly.setAutoDraw(True)
                
                # if crdm_trials_iti1_poly is active this frame...
                if crdm_trials_iti1_poly.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trials_iti1_poly is stopping this frame...
                if crdm_trials_iti1_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trials_iti1_poly.tStartRefresh + crdm_iti_time-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trials_iti1_poly.tStop = t  # not accounting for scr refresh
                        crdm_trials_iti1_poly.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trials_iti1_poly.stopped')
                        # update status
                        crdm_trials_iti1_poly.status = FINISHED
                        crdm_trials_iti1_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_trials_iti1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_trials_iti1" ---
            for thisComponent in crdm_trials_iti1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_trials_iti1.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_trials_iti1_code
            #record delta time
            my_loop.addData("crdm_delta_time", crdm_delta_time) 
            #record iti time
            my_loop.addData("crdm_iti_time", crdm_iti_time) 
            # the Routine "crdm_trials_iti1" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_trials1'
        
        
        # --- Prepare to start Routine "crdm_end" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_end.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_end_code
        crdm_unique_resps = []
        crdm_unique_count = 0
        for i in crdm_task_resps:
            if i not in crdm_unique_resps:
                crdm_unique_count += 1
                crdm_unique_resps.append(i)
        
        crdm_task_end_text = ""
        crdm_space_text = ""
        #filter for nonresponses
        if len(crdm_task_resps) < 68 or len(crdm_conf_resps) < 68: #95% of 72 CRDM trials
            if len(crdm_task_resps) < 68:
                crdm_task_end_text = "You failed to respond to " + str(72-len(crdm_task_resps)) + " task trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close."
            if len(crdm_conf_resps) < 68:
                crdm_task_end_text = "You failed to respond to both parts of " + str(72-len(crdm_conf_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close."
            crdm_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("crdm_subReject1", "< 95% resp rate")
            my_loop.addData("crdm_subReject1_nonresps-task", 72-len(crdm_task_resps))
            my_loop.addData("crdm_subReject1_nonresps-conf", 72-len(crdm_conf_resps))
        #filter for single-button responses
        elif crdm_unique_count < 2: #same for each exp
            crdm_task_end_text = "You provided the same response to all " + str(len(crdm_task_resps)) + " trials. \n \n You did not follow task instructions. \n \n The Risk & Ambiguity Task will now close."
            crdm_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("crdm_subReject2", "1key response")
            my_loop.addData("crdm_subReject2_key", crdm_task_resps[0])
        #filter for poor performance on CRDM catch trials (10/20 catch trials -- 0.097% of random success on 10 trials)
        #elif sum(crdm_catch_trials) < 10: 
            #crdm_task_end_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The Risk & Ambiguity Task will now close."
            #crdm_space_text = "Press SPACE to end."
            #exp_proceed = False
            #my_loop.addData("crdm_subReject3", "catch fail")
            #my_loop.addData("crdm_subReject3_fails", 20-sum(crdm_catch_trials))
        #all CRDM task trial criterion are met
        else:
            crdm_task_end_text = "You have completed the Risk & Ambiguity Task!"
            crdm_space_text = "Press SPACE to continue."
        crdm_end_txt_ON.setText(crdm_task_end_text)
        crdm_end_space_ON.setText(crdm_space_text)
        crdm_end_resp.keys = []
        crdm_end_resp.rt = []
        _crdm_end_resp_allKeys = []
        # keep track of which components have finished
        crdm_endComponents = [crdm_end_title_txt, crdm_end_txt_ON, crdm_end_space_ON, crdm_end_resp]
        for thisComponent in crdm_endComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_end" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_end_title_txt* updates
            
            # if crdm_end_title_txt is starting this frame...
            if crdm_end_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_title_txt.frameNStart = frameN  # exact frame index
                crdm_end_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_end_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_title_txt.status = STARTED
                crdm_end_title_txt.setAutoDraw(True)
            
            # if crdm_end_title_txt is active this frame...
            if crdm_end_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_end_txt_ON* updates
            
            # if crdm_end_txt_ON is starting this frame...
            if crdm_end_txt_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_txt_ON.frameNStart = frameN  # exact frame index
                crdm_end_txt_ON.tStart = t  # local t and not account for scr refresh
                crdm_end_txt_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_txt_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_txt_ON.status = STARTED
                crdm_end_txt_ON.setAutoDraw(True)
            
            # if crdm_end_txt_ON is active this frame...
            if crdm_end_txt_ON.status == STARTED:
                # update params
                pass
            
            # *crdm_end_space_ON* updates
            
            # if crdm_end_space_ON is starting this frame...
            if crdm_end_space_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_space_ON.frameNStart = frameN  # exact frame index
                crdm_end_space_ON.tStart = t  # local t and not account for scr refresh
                crdm_end_space_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_space_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_space_ON.status = STARTED
                crdm_end_space_ON.setAutoDraw(True)
            
            # if crdm_end_space_ON is active this frame...
            if crdm_end_space_ON.status == STARTED:
                # update params
                pass
            
            # *crdm_end_resp* updates
            waitOnFlip = False
            
            # if crdm_end_resp is starting this frame...
            if crdm_end_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_resp.frameNStart = frameN  # exact frame index
                crdm_end_resp.tStart = t  # local t and not account for scr refresh
                crdm_end_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_end_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_end_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_end_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_end_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_end_resp_allKeys.extend(theseKeys)
                if len(_crdm_end_resp_allKeys):
                    crdm_end_resp.keys = _crdm_end_resp_allKeys[-1].name  # just the last key pressed
                    crdm_end_resp.rt = _crdm_end_resp_allKeys[-1].rt
                    crdm_end_resp.duration = _crdm_end_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_endComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_end" ---
        for thisComponent in crdm_endComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_end.stopped', globalClock.getTime())
        # the Routine "crdm_end" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "idm_term_check" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_term_check.started', globalClock.getTime())
        # Run 'Begin Routine' code from idm_term_check_code
        if exp_proceed == False:
            core.quit()
        # keep track of which components have finished
        idm_term_checkComponents = []
        for thisComponent in idm_term_checkComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_term_check" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_term_check" ---
        for thisComponent in idm_term_checkComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_term_check.stopped', globalClock.getTime())
        # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
    # completed loop2 repeats of 'should_run2'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run3 = data.TrialHandler(nReps=loop3, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run3')
    thisExp.addLoop(should_run3)  # add the loop to the experiment
    thisShould_run3 = should_run3.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run3.rgb)
    if thisShould_run3 != None:
        for paramName in thisShould_run3:
            globals()[paramName] = thisShould_run3[paramName]
    
    for thisShould_run3 in should_run3:
        currentLoop = should_run3
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run3.rgb)
        if thisShould_run3 != None:
            for paramName in thisShould_run3:
                globals()[paramName] = thisShould_run3[paramName]
        
        # --- Prepare to start Routine "cdd_namer1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_namer1.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_namer1_code
        #provides specific loop names for each of two interations of DD
        #to provide flexibility of cdd_pract_trial and cdd_trial routines
        cdd_practice_loop1_name = "cdd_pract1_trials1"
        cdd_questplus_loop_name = "cdd_qp_trials1"
        cdd_practice_loop2_name = "cdd_pract2_trials1"
        cdd_loop_name = "cdd_trials1"
        # keep track of which components have finished
        cdd_namer1Components = []
        for thisComponent in cdd_namer1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_namer1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_namer1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_namer1" ---
        for thisComponent in cdd_namer1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_namer1.stopped', globalClock.getTime())
        # the Routine "cdd_namer1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr1.started', globalClock.getTime())
        cdd_instr1_resp.keys = []
        cdd_instr1_resp.rt = []
        _cdd_instr1_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr1Components = [cdd_instr1_title_txt, cdd_instr1_txt, cdd_instr1_space_txt, cdd_instr1_resp]
        for thisComponent in cdd_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr1_title_txt* updates
            
            # if cdd_instr1_title_txt is starting this frame...
            if cdd_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_title_txt.status = STARTED
                cdd_instr1_title_txt.setAutoDraw(True)
            
            # if cdd_instr1_title_txt is active this frame...
            if cdd_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_txt* updates
            
            # if cdd_instr1_txt is starting this frame...
            if cdd_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_txt.status = STARTED
                cdd_instr1_txt.setAutoDraw(True)
            
            # if cdd_instr1_txt is active this frame...
            if cdd_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_space_txt* updates
            
            # if cdd_instr1_space_txt is starting this frame...
            if cdd_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_space_txt.status = STARTED
                cdd_instr1_space_txt.setAutoDraw(True)
            
            # if cdd_instr1_space_txt is active this frame...
            if cdd_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_resp* updates
            waitOnFlip = False
            
            # if cdd_instr1_resp is starting this frame...
            if cdd_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_resp.frameNStart = frameN  # exact frame index
                cdd_instr1_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr1_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr1_resp_allKeys):
                    cdd_instr1_resp.keys = _cdd_instr1_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr1_resp.rt = _cdd_instr1_resp_allKeys[-1].rt
                    cdd_instr1_resp.duration = _cdd_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr1" ---
        for thisComponent in cdd_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr1.stopped', globalClock.getTime())
        # the Routine "cdd_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr2.started', globalClock.getTime())
        cdd_instr2_resp.keys = []
        cdd_instr2_resp.rt = []
        _cdd_instr2_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr2Components = [cdd_instr2_title_txt, cdd_instr2_txt, cdd_instr2_img, cdd_instr2_space_txt, cdd_instr2_resp]
        for thisComponent in cdd_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr2_title_txt* updates
            
            # if cdd_instr2_title_txt is starting this frame...
            if cdd_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_title_txt.status = STARTED
                cdd_instr2_title_txt.setAutoDraw(True)
            
            # if cdd_instr2_title_txt is active this frame...
            if cdd_instr2_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_txt* updates
            
            # if cdd_instr2_txt is starting this frame...
            if cdd_instr2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_txt.status = STARTED
                cdd_instr2_txt.setAutoDraw(True)
            
            # if cdd_instr2_txt is active this frame...
            if cdd_instr2_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_img* updates
            
            # if cdd_instr2_img is starting this frame...
            if cdd_instr2_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_img.frameNStart = frameN  # exact frame index
                cdd_instr2_img.tStart = t  # local t and not account for scr refresh
                cdd_instr2_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_img.status = STARTED
                cdd_instr2_img.setAutoDraw(True)
            
            # if cdd_instr2_img is active this frame...
            if cdd_instr2_img.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_space_txt* updates
            
            # if cdd_instr2_space_txt is starting this frame...
            if cdd_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_space_txt.status = STARTED
                cdd_instr2_space_txt.setAutoDraw(True)
            
            # if cdd_instr2_space_txt is active this frame...
            if cdd_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_resp* updates
            waitOnFlip = False
            
            # if cdd_instr2_resp is starting this frame...
            if cdd_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_resp.frameNStart = frameN  # exact frame index
                cdd_instr2_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr2_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr2_resp_allKeys):
                    cdd_instr2_resp.keys = _cdd_instr2_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr2_resp.rt = _cdd_instr2_resp_allKeys[-1].rt
                    cdd_instr2_resp.duration = _cdd_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr2" ---
        for thisComponent in cdd_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr2.stopped', globalClock.getTime())
        # the Routine "cdd_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr3.started', globalClock.getTime())
        cdd_instr3_resp.keys = []
        cdd_instr3_resp.rt = []
        _cdd_instr3_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr3Components = [cdd_instr3_title_txt, cdd_instr3_txt, cdd_instr3_img, cdd_instr3_space_txt, cdd_instr3_resp]
        for thisComponent in cdd_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr3_title_txt* updates
            
            # if cdd_instr3_title_txt is starting this frame...
            if cdd_instr3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_title_txt.status = STARTED
                cdd_instr3_title_txt.setAutoDraw(True)
            
            # if cdd_instr3_title_txt is active this frame...
            if cdd_instr3_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_txt* updates
            
            # if cdd_instr3_txt is starting this frame...
            if cdd_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_txt.status = STARTED
                cdd_instr3_txt.setAutoDraw(True)
            
            # if cdd_instr3_txt is active this frame...
            if cdd_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_img* updates
            
            # if cdd_instr3_img is starting this frame...
            if cdd_instr3_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_img.frameNStart = frameN  # exact frame index
                cdd_instr3_img.tStart = t  # local t and not account for scr refresh
                cdd_instr3_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_img.status = STARTED
                cdd_instr3_img.setAutoDraw(True)
            
            # if cdd_instr3_img is active this frame...
            if cdd_instr3_img.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_space_txt* updates
            
            # if cdd_instr3_space_txt is starting this frame...
            if cdd_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_space_txt.status = STARTED
                cdd_instr3_space_txt.setAutoDraw(True)
            
            # if cdd_instr3_space_txt is active this frame...
            if cdd_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_resp* updates
            waitOnFlip = False
            
            # if cdd_instr3_resp is starting this frame...
            if cdd_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_resp.frameNStart = frameN  # exact frame index
                cdd_instr3_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr3_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr3_resp_allKeys):
                    cdd_instr3_resp.keys = _cdd_instr3_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr3_resp.rt = _cdd_instr3_resp_allKeys[-1].rt
                    cdd_instr3_resp.duration = _cdd_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr3" ---
        for thisComponent in cdd_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr3.stopped', globalClock.getTime())
        # the Routine "cdd_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_warn.started', globalClock.getTime())
        cdd_warn1_resp.keys = []
        cdd_warn1_resp.rt = []
        _cdd_warn1_resp_allKeys = []
        # keep track of which components have finished
        cdd_warnComponents = [cdd_warn1_title_txt, cdd_warn1_txt, cdd_warn1_space_txt, cdd_warn1_resp]
        for thisComponent in cdd_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_warn1_title_txt* updates
            
            # if cdd_warn1_title_txt is starting this frame...
            if cdd_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_title_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_title_txt.status = STARTED
                cdd_warn1_title_txt.setAutoDraw(True)
            
            # if cdd_warn1_title_txt is active this frame...
            if cdd_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_txt* updates
            
            # if cdd_warn1_txt is starting this frame...
            if cdd_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_txt.status = STARTED
                cdd_warn1_txt.setAutoDraw(True)
            
            # if cdd_warn1_txt is active this frame...
            if cdd_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_space_txt* updates
            
            # if cdd_warn1_space_txt is starting this frame...
            if cdd_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_space_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_space_txt.status = STARTED
                cdd_warn1_space_txt.setAutoDraw(True)
            
            # if cdd_warn1_space_txt is active this frame...
            if cdd_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_resp* updates
            waitOnFlip = False
            
            # if cdd_warn1_resp is starting this frame...
            if cdd_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_resp.frameNStart = frameN  # exact frame index
                cdd_warn1_resp.tStart = t  # local t and not account for scr refresh
                cdd_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_warn1_resp_allKeys.extend(theseKeys)
                if len(_cdd_warn1_resp_allKeys):
                    cdd_warn1_resp.keys = _cdd_warn1_resp_allKeys[-1].name  # just the last key pressed
                    cdd_warn1_resp.rt = _cdd_warn1_resp_allKeys[-1].rt
                    cdd_warn1_resp.duration = _cdd_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_warn" ---
        for thisComponent in cdd_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_warn.stopped', globalClock.getTime())
        # the Routine "cdd_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_pract1_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_pract1_instr.started', globalClock.getTime())
        cdd_pract1_instr_resp.keys = []
        cdd_pract1_instr_resp.rt = []
        _cdd_pract1_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_pract1_instrComponents = [cdd_pract1_instr_left_poly, cdd_pract1_instr_right_poly, cdd_pract1_instr_txt, cdd_pract1_instr_immed_txt, cdd_pract1_instr_delay_txt, cdd_pract1_instr_or_txt, cdd_pract1_instr_space_txt, cdd_pract1_instr_resp]
        for thisComponent in cdd_pract1_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_pract1_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_pract1_instr_left_poly* updates
            
            # if cdd_pract1_instr_left_poly is starting this frame...
            if cdd_pract1_instr_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_left_poly.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_left_poly.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_left_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_left_poly.status = STARTED
                cdd_pract1_instr_left_poly.setAutoDraw(True)
            
            # if cdd_pract1_instr_left_poly is active this frame...
            if cdd_pract1_instr_left_poly.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_right_poly* updates
            
            # if cdd_pract1_instr_right_poly is starting this frame...
            if cdd_pract1_instr_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_right_poly.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_right_poly.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_right_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_right_poly.status = STARTED
                cdd_pract1_instr_right_poly.setAutoDraw(True)
            
            # if cdd_pract1_instr_right_poly is active this frame...
            if cdd_pract1_instr_right_poly.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_txt* updates
            
            # if cdd_pract1_instr_txt is starting this frame...
            if cdd_pract1_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_txt.status = STARTED
                cdd_pract1_instr_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_txt is active this frame...
            if cdd_pract1_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_immed_txt* updates
            
            # if cdd_pract1_instr_immed_txt is starting this frame...
            if cdd_pract1_instr_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_immed_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_immed_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_immed_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_immed_txt.status = STARTED
                cdd_pract1_instr_immed_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_immed_txt is active this frame...
            if cdd_pract1_instr_immed_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_delay_txt* updates
            
            # if cdd_pract1_instr_delay_txt is starting this frame...
            if cdd_pract1_instr_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_delay_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_delay_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_delay_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_delay_txt.status = STARTED
                cdd_pract1_instr_delay_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_delay_txt is active this frame...
            if cdd_pract1_instr_delay_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_or_txt* updates
            
            # if cdd_pract1_instr_or_txt is starting this frame...
            if cdd_pract1_instr_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_or_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_or_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_or_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_or_txt.status = STARTED
                cdd_pract1_instr_or_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_or_txt is active this frame...
            if cdd_pract1_instr_or_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_space_txt* updates
            
            # if cdd_pract1_instr_space_txt is starting this frame...
            if cdd_pract1_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_space_txt.status = STARTED
                cdd_pract1_instr_space_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_space_txt is active this frame...
            if cdd_pract1_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_pract1_instr_resp is starting this frame...
            if cdd_pract1_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_resp.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_pract1_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_pract1_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_pract1_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_pract1_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_pract1_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_pract1_instr_resp_allKeys):
                    cdd_pract1_instr_resp.keys = _cdd_pract1_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_pract1_instr_resp.rt = _cdd_pract1_instr_resp_allKeys[-1].rt
                    cdd_pract1_instr_resp.duration = _cdd_pract1_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_pract1_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_pract1_instr" ---
        for thisComponent in cdd_pract1_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_pract1_instr.stopped', globalClock.getTime())
        # the Routine "cdd_pract1_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_pract1_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_practice1.csv'),
            seed=None, name='cdd_pract1_trials1')
        thisExp.addLoop(cdd_pract1_trials1)  # add the loop to the experiment
        thisCdd_pract1_trials1 = cdd_pract1_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract1_trials1.rgb)
        if thisCdd_pract1_trials1 != None:
            for paramName in thisCdd_pract1_trials1:
                globals()[paramName] = thisCdd_pract1_trials1[paramName]
        
        for thisCdd_pract1_trials1 in cdd_pract1_trials1:
            currentLoop = cdd_pract1_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract1_trials1.rgb)
            if thisCdd_pract1_trials1 != None:
                for paramName in thisCdd_pract1_trials1:
                    globals()[paramName] = thisCdd_pract1_trials1[paramName]
            
            # --- Prepare to start Routine "cdd_pract1_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract1_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract1_trial_code
            my_loop = eval(cdd_practice_loop1_name) 
            cdd_idx1 = random.randint(0,1) #random selection of position and resp key
            cdd_immed_pos1 = cdd_pos1[cdd_idx1]
            cdd_immed_resp1 = cdd_resp1[cdd_idx1]
            
            if cdd_idx1 == 0: 
                #delay is right
                cdd_delay_pos1 = cdd_pos1[1] 
                #immed is right side
            else: 
                #delay is left
                cdd_delay_pos1 = cdd_pos1[0] 
            cdd_pract1_trial_immed_txt.setPos(cdd_immed_pos1)
            cdd_pract1_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt1))) + "\n" + "\n" + " TODAY")
            cdd_pract1_trial_delay_txt.setPos(cdd_delay_pos1)
            cdd_pract1_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt1))) + "\n" + "\n" + str(cdd_delay_wait1) + " DAYS")
            cdd_pract1_trial_resp.keys = []
            cdd_pract1_trial_resp.rt = []
            _cdd_pract1_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract1_trialComponents = [cdd_pract1_trial_left_poly, cdd_pract1_trial_right_poly, cdd_pract1_trial_prompt_txt, cdd_pract1_trial_immed_txt, cdd_pract1_trial_or_txt, cdd_pract1_trial_delay_txt, cdd_pract1_trial_cue, cdd_pract1_trial_resp]
            for thisComponent in cdd_pract1_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract1_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract1_trial_left_poly* updates
                
                # if cdd_pract1_trial_left_poly is starting this frame...
                if cdd_pract1_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_left_poly.status = STARTED
                    cdd_pract1_trial_left_poly.setAutoDraw(True)
                
                # if cdd_pract1_trial_left_poly is active this frame...
                if cdd_pract1_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_left_poly is stopping this frame...
                if cdd_pract1_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_left_poly.status = FINISHED
                        cdd_pract1_trial_left_poly.setAutoDraw(False)
                
                # *cdd_pract1_trial_right_poly* updates
                
                # if cdd_pract1_trial_right_poly is starting this frame...
                if cdd_pract1_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_right_poly.status = STARTED
                    cdd_pract1_trial_right_poly.setAutoDraw(True)
                
                # if cdd_pract1_trial_right_poly is active this frame...
                if cdd_pract1_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_right_poly is stopping this frame...
                if cdd_pract1_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_right_poly.status = FINISHED
                        cdd_pract1_trial_right_poly.setAutoDraw(False)
                
                # *cdd_pract1_trial_prompt_txt* updates
                
                # if cdd_pract1_trial_prompt_txt is starting this frame...
                if cdd_pract1_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_prompt_txt.status = STARTED
                    cdd_pract1_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_prompt_txt is active this frame...
                if cdd_pract1_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_prompt_txt is stopping this frame...
                if cdd_pract1_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_prompt_txt.status = FINISHED
                        cdd_pract1_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_immed_txt* updates
                
                # if cdd_pract1_trial_immed_txt is starting this frame...
                if cdd_pract1_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_immed_txt.status = STARTED
                    cdd_pract1_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_immed_txt is active this frame...
                if cdd_pract1_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_immed_txt is stopping this frame...
                if cdd_pract1_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_immed_txt.status = FINISHED
                        cdd_pract1_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_or_txt* updates
                
                # if cdd_pract1_trial_or_txt is starting this frame...
                if cdd_pract1_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_or_txt.status = STARTED
                    cdd_pract1_trial_or_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_or_txt is active this frame...
                if cdd_pract1_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_or_txt is stopping this frame...
                if cdd_pract1_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_or_txt.status = FINISHED
                        cdd_pract1_trial_or_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_delay_txt* updates
                
                # if cdd_pract1_trial_delay_txt is starting this frame...
                if cdd_pract1_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_delay_txt.status = STARTED
                    cdd_pract1_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_delay_txt is active this frame...
                if cdd_pract1_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_delay_txt is stopping this frame...
                if cdd_pract1_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_delay_txt.status = FINISHED
                        cdd_pract1_trial_delay_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_cue* updates
                
                # if cdd_pract1_trial_cue is starting this frame...
                if cdd_pract1_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_cue.status = STARTED
                    cdd_pract1_trial_cue.setAutoDraw(True)
                
                # if cdd_pract1_trial_cue is active this frame...
                if cdd_pract1_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_cue is stopping this frame...
                if cdd_pract1_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_cue.status = FINISHED
                        cdd_pract1_trial_cue.setAutoDraw(False)
                
                # *cdd_pract1_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_pract1_trial_resp is starting this frame...
                if cdd_pract1_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract1_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract1_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract1_trial_resp is stopping this frame...
                if cdd_pract1_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_resp.status = FINISHED
                        cdd_pract1_trial_resp.status = FINISHED
                if cdd_pract1_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract1_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract1_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract1_trial_resp_allKeys):
                        cdd_pract1_trial_resp.keys = _cdd_pract1_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract1_trial_resp.rt = _cdd_pract1_trial_resp_allKeys[-1].rt
                        cdd_pract1_trial_resp.duration = _cdd_pract1_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_pract1_trial_resp.keys == str(cdd_immed_resp1)) or (cdd_pract1_trial_resp.keys == cdd_immed_resp1):
                            cdd_pract1_trial_resp.corr = 1
                        else:
                            cdd_pract1_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract1_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract1_trial" ---
            for thisComponent in cdd_pract1_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract1_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_pract1_trial_code
            cdd_pract1_key = cdd_pract1_trial_resp.keys #Ss response key
            cdd_pract1_immed_key = cdd_pract1_trial_resp.corr #1 when immediate amt is chosen
            my_loop.addData("cdd_trial_type", "practice1")
            # check responses
            if cdd_pract1_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_pract1_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp1).lower() == 'none':
                   cdd_pract1_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_pract1_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_pract1_trials1 (TrialHandler)
            cdd_pract1_trials1.addData('cdd_pract1_trial_resp.keys',cdd_pract1_trial_resp.keys)
            cdd_pract1_trials1.addData('cdd_pract1_trial_resp.corr', cdd_pract1_trial_resp.corr)
            if cdd_pract1_trial_resp.keys != None:  # we had a response
                cdd_pract1_trials1.addData('cdd_pract1_trial_resp.rt', cdd_pract1_trial_resp.rt)
                cdd_pract1_trials1.addData('cdd_pract1_trial_resp.duration', cdd_pract1_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_pract1_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract1_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract1_feedback_py
            if len(cdd_pract1_key) == 0: #Ss did not respond 
                cdd_msg1 = "NO RESPONSE"
            elif cdd_pract1_immed_key: #Ss chose smaller, immediate option
                cdd_msg1 = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg1 = "$ LATER"
            cdd_pract1_feedback_txt.setText(cdd_msg1)
            # keep track of which components have finished
            cdd_pract1_feedbackComponents = [cdd_pract1_feedback_txt]
            for thisComponent in cdd_pract1_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract1_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract1_feedback_txt* updates
                
                # if cdd_pract1_feedback_txt is starting this frame...
                if cdd_pract1_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_feedback_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_feedback_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_feedback_txt.status = STARTED
                    cdd_pract1_feedback_txt.setAutoDraw(True)
                
                # if cdd_pract1_feedback_txt is active this frame...
                if cdd_pract1_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_feedback_txt is stopping this frame...
                if cdd_pract1_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_feedback_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_feedback_txt.status = FINISHED
                        cdd_pract1_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract1_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract1_feedback" ---
            for thisComponent in cdd_pract1_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract1_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_pract1_trials1'
        
        
        # --- Prepare to start Routine "cdd_qp_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_qp_instr.started', globalClock.getTime())
        cdd_qp_instr_resp.keys = []
        cdd_qp_instr_resp.rt = []
        _cdd_qp_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_qp_instrComponents = [cdd_qp_instr_title_txt, cdd_qp_instr_txt, cdd_qp_instr_space_txt, cdd_qp_instr_resp]
        for thisComponent in cdd_qp_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_qp_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_qp_instr_title_txt* updates
            
            # if cdd_qp_instr_title_txt is starting this frame...
            if cdd_qp_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_title_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_title_txt.status = STARTED
                cdd_qp_instr_title_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_title_txt is active this frame...
            if cdd_qp_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_txt* updates
            
            # if cdd_qp_instr_txt is starting this frame...
            if cdd_qp_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_txt.status = STARTED
                cdd_qp_instr_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_txt is active this frame...
            if cdd_qp_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_space_txt* updates
            
            # if cdd_qp_instr_space_txt is starting this frame...
            if cdd_qp_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_space_txt.status = STARTED
                cdd_qp_instr_space_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_space_txt is active this frame...
            if cdd_qp_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_qp_instr_resp is starting this frame...
            if cdd_qp_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_resp.frameNStart = frameN  # exact frame index
                cdd_qp_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_qp_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_qp_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_qp_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_qp_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_qp_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_qp_instr_resp_allKeys):
                    cdd_qp_instr_resp.keys = _cdd_qp_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_qp_instr_resp.rt = _cdd_qp_instr_resp_allKeys[-1].rt
                    cdd_qp_instr_resp.duration = _cdd_qp_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_qp_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_qp_instr" ---
        for thisComponent in cdd_qp_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_qp_instr.stopped', globalClock.getTime())
        # the Routine "cdd_qp_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        cdd_qp_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_qp_trials.csv'),
            seed=None, name='cdd_qp_trials1')
        thisExp.addLoop(cdd_qp_trials1)  # add the loop to the experiment
        thisCdd_qp_trials1 = cdd_qp_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_qp_trials1.rgb)
        if thisCdd_qp_trials1 != None:
            for paramName in thisCdd_qp_trials1:
                globals()[paramName] = thisCdd_qp_trials1[paramName]
        
        for thisCdd_qp_trials1 in cdd_qp_trials1:
            currentLoop = cdd_qp_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_qp_trials1.rgb)
            if thisCdd_qp_trials1 != None:
                for paramName in thisCdd_qp_trials1:
                    globals()[paramName] = thisCdd_qp_trials1[paramName]
            
            # --- Prepare to start Routine "cdd_questplus" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_questplus.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_questplus_JS
            my_loop = eval(cdd_practice_loop_name);
            cdd_idx_qp = random.randint(0, 1);
            cdd_immed_pos_qp = cdd_pos_qp[cdd_idx_qp];
            cdd_immed_resp_qp = cdd_resp_qp[cdd_idx_qp];
            cdd_questplus_trial_immed_txt.setPos(cdd_immed_pos_qp)
            cdd_questplus_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt_qp))) + "\n" + "\n" + " TODAY")
            cdd_questplus_trial_delay_txt.setPos(cdd_delay_pos_qp)
            cdd_questplus_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt_qp))) + "\n" + "\n" + str(cdd_delay_wait_qp) + " DAYS")
            cdd_questplus_trial_resp.keys = []
            cdd_questplus_trial_resp.rt = []
            _cdd_questplus_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_questplusComponents = [cdd_questplus_trial_left_poly, cdd_questplus_trial_right_poly, cdd_questplus_trial_prompt_txt, cdd_questplus_trial_immed_txt, cdd_questplus_trial_or_txt, cdd_questplus_trial_delay_txt, GRFX_fix2_2, cdd_questplus_trial_cue, cdd_questplus_trial_resp]
            for thisComponent in cdd_questplusComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_questplus" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_questplus_trial_left_poly* updates
                
                # if cdd_questplus_trial_left_poly is starting this frame...
                if cdd_questplus_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_left_poly.status = STARTED
                    cdd_questplus_trial_left_poly.setAutoDraw(True)
                
                # if cdd_questplus_trial_left_poly is active this frame...
                if cdd_questplus_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_left_poly is stopping this frame...
                if cdd_questplus_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_left_poly.status = FINISHED
                        cdd_questplus_trial_left_poly.setAutoDraw(False)
                
                # *cdd_questplus_trial_right_poly* updates
                
                # if cdd_questplus_trial_right_poly is starting this frame...
                if cdd_questplus_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_right_poly.status = STARTED
                    cdd_questplus_trial_right_poly.setAutoDraw(True)
                
                # if cdd_questplus_trial_right_poly is active this frame...
                if cdd_questplus_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_right_poly is stopping this frame...
                if cdd_questplus_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_right_poly.status = FINISHED
                        cdd_questplus_trial_right_poly.setAutoDraw(False)
                
                # *cdd_questplus_trial_prompt_txt* updates
                
                # if cdd_questplus_trial_prompt_txt is starting this frame...
                if cdd_questplus_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_prompt_txt.status = STARTED
                    cdd_questplus_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_prompt_txt is active this frame...
                if cdd_questplus_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_prompt_txt is stopping this frame...
                if cdd_questplus_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_prompt_txt.status = FINISHED
                        cdd_questplus_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_immed_txt* updates
                
                # if cdd_questplus_trial_immed_txt is starting this frame...
                if cdd_questplus_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_immed_txt.status = STARTED
                    cdd_questplus_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_immed_txt is active this frame...
                if cdd_questplus_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_immed_txt is stopping this frame...
                if cdd_questplus_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_immed_txt.status = FINISHED
                        cdd_questplus_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_or_txt* updates
                
                # if cdd_questplus_trial_or_txt is starting this frame...
                if cdd_questplus_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_or_txt.status = STARTED
                    cdd_questplus_trial_or_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_or_txt is active this frame...
                if cdd_questplus_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_or_txt is stopping this frame...
                if cdd_questplus_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_or_txt.status = FINISHED
                        cdd_questplus_trial_or_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_delay_txt* updates
                
                # if cdd_questplus_trial_delay_txt is starting this frame...
                if cdd_questplus_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_delay_txt.status = STARTED
                    cdd_questplus_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_delay_txt is active this frame...
                if cdd_questplus_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_delay_txt is stopping this frame...
                if cdd_questplus_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_delay_txt.status = FINISHED
                        cdd_questplus_trial_delay_txt.setAutoDraw(False)
                
                # *GRFX_fix2_2* updates
                
                # if GRFX_fix2_2 is starting this frame...
                if GRFX_fix2_2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix2_2.frameNStart = frameN  # exact frame index
                    GRFX_fix2_2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix2_2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix2_2.status = STARTED
                    GRFX_fix2_2.setAutoDraw(True)
                
                # if GRFX_fix2_2 is active this frame...
                if GRFX_fix2_2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix2_2 is stopping this frame...
                if GRFX_fix2_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix2_2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix2_2.tStop = t  # not accounting for scr refresh
                        GRFX_fix2_2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix2_2.status = FINISHED
                        GRFX_fix2_2.setAutoDraw(False)
                
                # *cdd_questplus_trial_cue* updates
                
                # if cdd_questplus_trial_cue is starting this frame...
                if cdd_questplus_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_cue.status = STARTED
                    cdd_questplus_trial_cue.setAutoDraw(True)
                
                # if cdd_questplus_trial_cue is active this frame...
                if cdd_questplus_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_cue is stopping this frame...
                if cdd_questplus_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_cue.status = FINISHED
                        cdd_questplus_trial_cue.setAutoDraw(False)
                
                # *cdd_questplus_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_questplus_trial_resp is starting this frame...
                if cdd_questplus_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_questplus_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_questplus_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_questplus_trial_resp is stopping this frame...
                if cdd_questplus_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_resp.status = FINISHED
                        cdd_questplus_trial_resp.status = FINISHED
                if cdd_questplus_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_questplus_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_questplus_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_questplus_trial_resp_allKeys):
                        cdd_questplus_trial_resp.keys = _cdd_questplus_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_questplus_trial_resp.rt = _cdd_questplus_trial_resp_allKeys[-1].rt
                        cdd_questplus_trial_resp.duration = _cdd_questplus_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_questplus_trial_resp.keys == str(cdd_immed_resp_qp)) or (cdd_questplus_trial_resp.keys == cdd_immed_resp_qp):
                            cdd_questplus_trial_resp.corr = 1
                        else:
                            cdd_questplus_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_questplusComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_questplus" ---
            for thisComponent in cdd_questplusComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_questplus.stopped', globalClock.getTime())
            # check responses
            if cdd_questplus_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_questplus_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp_qp).lower() == 'none':
                   cdd_questplus_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_questplus_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_qp_trials1 (TrialHandler)
            cdd_qp_trials1.addData('cdd_questplus_trial_resp.keys',cdd_questplus_trial_resp.keys)
            cdd_qp_trials1.addData('cdd_questplus_trial_resp.corr', cdd_questplus_trial_resp.corr)
            if cdd_questplus_trial_resp.keys != None:  # we had a response
                cdd_qp_trials1.addData('cdd_questplus_trial_resp.rt', cdd_questplus_trial_resp.rt)
                cdd_qp_trials1.addData('cdd_questplus_trial_resp.duration', cdd_questplus_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_questplus_fb" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_questplus_fb.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_questplus_fb_code
            if len(cdd_qp_key) == 0: #Ss did not respond
                cdd_msg_qp = "NO RESPONSE"
            elif cdd_qp_immed_key: #Ss chose smaller, immediate option
                cdd_msg_qp = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg_qp = "$ LATER"
            cdd_qp_fb_txt.setText(cdd_msg_qp)
            # keep track of which components have finished
            cdd_questplus_fbComponents = [cdd_qp_fb_txt]
            for thisComponent in cdd_questplus_fbComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_questplus_fb" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_qp_fb_txt* updates
                
                # if cdd_qp_fb_txt is starting this frame...
                if cdd_qp_fb_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_qp_fb_txt.frameNStart = frameN  # exact frame index
                    cdd_qp_fb_txt.tStart = t  # local t and not account for scr refresh
                    cdd_qp_fb_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_qp_fb_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_qp_fb_txt.status = STARTED
                    cdd_qp_fb_txt.setAutoDraw(True)
                
                # if cdd_qp_fb_txt is active this frame...
                if cdd_qp_fb_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_qp_fb_txt is stopping this frame...
                if cdd_qp_fb_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_qp_fb_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_qp_fb_txt.tStop = t  # not accounting for scr refresh
                        cdd_qp_fb_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_qp_fb_txt.status = FINISHED
                        cdd_qp_fb_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_questplus_fbComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_questplus_fb" ---
            for thisComponent in cdd_questplus_fbComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_questplus_fb.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_qp_trials1'
        
        
        # --- Prepare to start Routine "cdd_schedule_gen" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_schedule_gen.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_schedule_genComponents = []
        for thisComponent in cdd_schedule_genComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_schedule_gen" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_schedule_genComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_schedule_gen" ---
        for thisComponent in cdd_schedule_genComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_schedule_gen.stopped', globalClock.getTime())
        # the Routine "cdd_schedule_gen" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_pract2_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_pract2_instr.started', globalClock.getTime())
        cdd_pract_instr_resp_2.keys = []
        cdd_pract_instr_resp_2.rt = []
        _cdd_pract_instr_resp_2_allKeys = []
        # keep track of which components have finished
        cdd_pract2_instrComponents = [cdd_pract2_intr_name_txt, cdd_pract2_instr_txt, cdd_pract_instr_space_txt_2, cdd_pract_instr_resp_2]
        for thisComponent in cdd_pract2_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_pract2_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_pract2_intr_name_txt* updates
            
            # if cdd_pract2_intr_name_txt is starting this frame...
            if cdd_pract2_intr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract2_intr_name_txt.frameNStart = frameN  # exact frame index
                cdd_pract2_intr_name_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract2_intr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract2_intr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract2_intr_name_txt.status = STARTED
                cdd_pract2_intr_name_txt.setAutoDraw(True)
            
            # if cdd_pract2_intr_name_txt is active this frame...
            if cdd_pract2_intr_name_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract2_instr_txt* updates
            
            # if cdd_pract2_instr_txt is starting this frame...
            if cdd_pract2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract2_instr_txt.frameNStart = frameN  # exact frame index
                cdd_pract2_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract2_instr_txt.status = STARTED
                cdd_pract2_instr_txt.setAutoDraw(True)
            
            # if cdd_pract2_instr_txt is active this frame...
            if cdd_pract2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract_instr_space_txt_2* updates
            
            # if cdd_pract_instr_space_txt_2 is starting this frame...
            if cdd_pract_instr_space_txt_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract_instr_space_txt_2.frameNStart = frameN  # exact frame index
                cdd_pract_instr_space_txt_2.tStart = t  # local t and not account for scr refresh
                cdd_pract_instr_space_txt_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract_instr_space_txt_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract_instr_space_txt_2.status = STARTED
                cdd_pract_instr_space_txt_2.setAutoDraw(True)
            
            # if cdd_pract_instr_space_txt_2 is active this frame...
            if cdd_pract_instr_space_txt_2.status == STARTED:
                # update params
                pass
            
            # *cdd_pract_instr_resp_2* updates
            waitOnFlip = False
            
            # if cdd_pract_instr_resp_2 is starting this frame...
            if cdd_pract_instr_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract_instr_resp_2.frameNStart = frameN  # exact frame index
                cdd_pract_instr_resp_2.tStart = t  # local t and not account for scr refresh
                cdd_pract_instr_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract_instr_resp_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract_instr_resp_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_pract_instr_resp_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_pract_instr_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_pract_instr_resp_2.status == STARTED and not waitOnFlip:
                theseKeys = cdd_pract_instr_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_pract_instr_resp_2_allKeys.extend(theseKeys)
                if len(_cdd_pract_instr_resp_2_allKeys):
                    cdd_pract_instr_resp_2.keys = _cdd_pract_instr_resp_2_allKeys[-1].name  # just the last key pressed
                    cdd_pract_instr_resp_2.rt = _cdd_pract_instr_resp_2_allKeys[-1].rt
                    cdd_pract_instr_resp_2.duration = _cdd_pract_instr_resp_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_pract2_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_pract2_instr" ---
        for thisComponent in cdd_pract2_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_pract2_instr.stopped', globalClock.getTime())
        # the Routine "cdd_pract2_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_pract2_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_practice2.csv'),
            seed=None, name='cdd_pract2_trials1')
        thisExp.addLoop(cdd_pract2_trials1)  # add the loop to the experiment
        thisCdd_pract2_trials1 = cdd_pract2_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract2_trials1.rgb)
        if thisCdd_pract2_trials1 != None:
            for paramName in thisCdd_pract2_trials1:
                globals()[paramName] = thisCdd_pract2_trials1[paramName]
        
        for thisCdd_pract2_trials1 in cdd_pract2_trials1:
            currentLoop = cdd_pract2_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract2_trials1.rgb)
            if thisCdd_pract2_trials1 != None:
                for paramName in thisCdd_pract2_trials1:
                    globals()[paramName] = thisCdd_pract2_trials1[paramName]
            
            # --- Prepare to start Routine "cdd_pract2_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_trial_code
            my_loop = eval(cdd_practice_loop2_name) 
            cdd_idx2 = random.randint(0,1) #random selection of position and resp key
            cdd_immed_pos2 = cdd_pos2[cdd_idx2]
            cdd_immed_resp2 = cdd_resp1[cdd_idx2]
            cdd_pract2_trial_immed_txt.setPos(cdd_immed_pos2)
            cdd_pract2_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt2))) + "\n" + "\n" + " TODAY")
            cdd_pract2_trial_delay_txt.setPos(cdd_delay_pos2)
            cdd_pract2_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt2))) + "\n" + "\n" + str(cdd_delay_wait2) + " DAYS")
            cdd_pract2_trial_resp.keys = []
            cdd_pract2_trial_resp.rt = []
            _cdd_pract2_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract2_trialComponents = [cdd_pract2_trial_left_poly, cdd_pract2_trial_right_poly, cdd_pract2_trial_prompt_txt, cdd_pract2_trial_immed_txt, cdd_pract2_trial_or_txt, cdd_pract2_trial_delay_txt, GRFX_fix3_2, cdd_pract2_trial_cue, cdd_pract2_trial_resp]
            for thisComponent in cdd_pract2_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_trial_left_poly* updates
                
                # if cdd_pract2_trial_left_poly is starting this frame...
                if cdd_pract2_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_left_poly.status = STARTED
                    cdd_pract2_trial_left_poly.setAutoDraw(True)
                
                # if cdd_pract2_trial_left_poly is active this frame...
                if cdd_pract2_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_left_poly is stopping this frame...
                if cdd_pract2_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_left_poly.status = FINISHED
                        cdd_pract2_trial_left_poly.setAutoDraw(False)
                
                # *cdd_pract2_trial_right_poly* updates
                
                # if cdd_pract2_trial_right_poly is starting this frame...
                if cdd_pract2_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_right_poly.status = STARTED
                    cdd_pract2_trial_right_poly.setAutoDraw(True)
                
                # if cdd_pract2_trial_right_poly is active this frame...
                if cdd_pract2_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_right_poly is stopping this frame...
                if cdd_pract2_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_right_poly.status = FINISHED
                        cdd_pract2_trial_right_poly.setAutoDraw(False)
                
                # *cdd_pract2_trial_prompt_txt* updates
                
                # if cdd_pract2_trial_prompt_txt is starting this frame...
                if cdd_pract2_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_prompt_txt.status = STARTED
                    cdd_pract2_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_prompt_txt is active this frame...
                if cdd_pract2_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_prompt_txt is stopping this frame...
                if cdd_pract2_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_prompt_txt.status = FINISHED
                        cdd_pract2_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_immed_txt* updates
                
                # if cdd_pract2_trial_immed_txt is starting this frame...
                if cdd_pract2_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_immed_txt.status = STARTED
                    cdd_pract2_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_immed_txt is active this frame...
                if cdd_pract2_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_immed_txt is stopping this frame...
                if cdd_pract2_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_immed_txt.status = FINISHED
                        cdd_pract2_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_or_txt* updates
                
                # if cdd_pract2_trial_or_txt is starting this frame...
                if cdd_pract2_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_or_txt.status = STARTED
                    cdd_pract2_trial_or_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_or_txt is active this frame...
                if cdd_pract2_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_or_txt is stopping this frame...
                if cdd_pract2_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_or_txt.status = FINISHED
                        cdd_pract2_trial_or_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_delay_txt* updates
                
                # if cdd_pract2_trial_delay_txt is starting this frame...
                if cdd_pract2_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_delay_txt.status = STARTED
                    cdd_pract2_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_delay_txt is active this frame...
                if cdd_pract2_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_delay_txt is stopping this frame...
                if cdd_pract2_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_delay_txt.status = FINISHED
                        cdd_pract2_trial_delay_txt.setAutoDraw(False)
                
                # *GRFX_fix3_2* updates
                
                # if GRFX_fix3_2 is starting this frame...
                if GRFX_fix3_2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix3_2.frameNStart = frameN  # exact frame index
                    GRFX_fix3_2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix3_2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix3_2.status = STARTED
                    GRFX_fix3_2.setAutoDraw(True)
                
                # if GRFX_fix3_2 is active this frame...
                if GRFX_fix3_2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix3_2 is stopping this frame...
                if GRFX_fix3_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix3_2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix3_2.tStop = t  # not accounting for scr refresh
                        GRFX_fix3_2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix3_2.status = FINISHED
                        GRFX_fix3_2.setAutoDraw(False)
                
                # *cdd_pract2_trial_cue* updates
                
                # if cdd_pract2_trial_cue is starting this frame...
                if cdd_pract2_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_cue.status = STARTED
                    cdd_pract2_trial_cue.setAutoDraw(True)
                
                # if cdd_pract2_trial_cue is active this frame...
                if cdd_pract2_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_cue is stopping this frame...
                if cdd_pract2_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_cue.status = FINISHED
                        cdd_pract2_trial_cue.setAutoDraw(False)
                
                # *cdd_pract2_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_pract2_trial_resp is starting this frame...
                if cdd_pract2_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract2_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract2_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract2_trial_resp is stopping this frame...
                if cdd_pract2_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_resp.status = FINISHED
                        cdd_pract2_trial_resp.status = FINISHED
                if cdd_pract2_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract2_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract2_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract2_trial_resp_allKeys):
                        cdd_pract2_trial_resp.keys = _cdd_pract2_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract2_trial_resp.rt = _cdd_pract2_trial_resp_allKeys[-1].rt
                        cdd_pract2_trial_resp.duration = _cdd_pract2_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_pract2_trial_resp.keys == str(cdd_immed_resp2)) or (cdd_pract2_trial_resp.keys == cdd_immed_resp2):
                            cdd_pract2_trial_resp.corr = 1
                        else:
                            cdd_pract2_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_trial" ---
            for thisComponent in cdd_pract2_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_pract2_trial_code
            cdd_pract2_key = cdd_pract2_trial_resp.keys #Ss response key
            cdd_pract2_immed_key = cdd_pract2_trial_resp.corr #1 when immediate amt is chosen
            my_loop.addData("cdd_trial_type", "practice2")
            # check responses
            if cdd_pract2_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_pract2_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp2).lower() == 'none':
                   cdd_pract2_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_pract2_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_pract2_trials1 (TrialHandler)
            cdd_pract2_trials1.addData('cdd_pract2_trial_resp.keys',cdd_pract2_trial_resp.keys)
            cdd_pract2_trials1.addData('cdd_pract2_trial_resp.corr', cdd_pract2_trial_resp.corr)
            if cdd_pract2_trial_resp.keys != None:  # we had a response
                cdd_pract2_trials1.addData('cdd_pract2_trial_resp.rt', cdd_pract2_trial_resp.rt)
                cdd_pract2_trials1.addData('cdd_pract2_trial_resp.duration', cdd_pract2_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_pract2_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_fb_py
            if len(cdd_pract2_key) == 0: #Ss did not respond
                cdd_msg2 = "NO RESPONSE"
            elif cdd_pract2_immed_key: #Ss chose smaller, immediate option
                cdd_msg2 = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg2 = "$ LATER"
            cdd_pract2_fb_txt.setText(cdd_msg2)
            # keep track of which components have finished
            cdd_pract2_feedbackComponents = [cdd_pract2_fb_txt]
            for thisComponent in cdd_pract2_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_fb_txt* updates
                
                # if cdd_pract2_fb_txt is starting this frame...
                if cdd_pract2_fb_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_fb_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_fb_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_fb_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_fb_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_fb_txt.status = STARTED
                    cdd_pract2_fb_txt.setAutoDraw(True)
                
                # if cdd_pract2_fb_txt is active this frame...
                if cdd_pract2_fb_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_fb_txt is stopping this frame...
                if cdd_pract2_fb_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_fb_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_fb_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_fb_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_fb_txt.status = FINISHED
                        cdd_pract2_fb_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_feedback" ---
            for thisComponent in cdd_pract2_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "cdd_pract2_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_conf_py
            if len(cdd_pract2_key) == 0: #Ss did not respond to choice trial
                continueRoutine = False
            
            #set all 4 boxes as gray by default
            conf1_color = [0, 0, 0]
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            cdd_pract2_conf_resp.keys = []
            cdd_pract2_conf_resp.rt = []
            _cdd_pract2_conf_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract2_confComponents = [cdd_pract2_conf_txt, cdd_pract2_conf1, cdd_pract2_conf1_txt, cdd_pract2_conf2, cdd_pract2_conf2_txt, cdd_pract2_conf3, cdd_pract2_conf3_txt, cdd_pract2_conf4, cdd_pract2_conf4_txt, cdd_pract2_conf_resp]
            for thisComponent in cdd_pract2_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cdd_pract2_conf_py
                cdd_pract_conf_key = cdd_pract_conf_resp.keys
                #confidence rating received
                if len(cdd_pract_conf_key) == 1:
                    #not at all confident
                    if cdd_pract_conf_key == "1":
                        conf1_color = "darkgray"
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #less confident
                    elif cdd_pract_conf_key == "2":
                        conf1_color = [0, 0, 0]
                        conf2_color = "darkgray"
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #somewhat confident
                    elif cdd_pract_conf_key == "3":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = "darkgray"
                        conf4_color = [0, 0, 0]
                    #very confident
                    elif cdd_pract_conf_key == "4":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = "darkgray"
                
                # *cdd_pract2_conf_txt* updates
                
                # if cdd_pract2_conf_txt is starting this frame...
                if cdd_pract2_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf_txt.status = STARTED
                    cdd_pract2_conf_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf_txt is active this frame...
                if cdd_pract2_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf_txt is stopping this frame...
                if cdd_pract2_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf_txt.status = FINISHED
                        cdd_pract2_conf_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf1* updates
                
                # if cdd_pract2_conf1 is starting this frame...
                if cdd_pract2_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf1.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf1.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf1.status = STARTED
                    cdd_pract2_conf1.setAutoDraw(True)
                
                # if cdd_pract2_conf1 is active this frame...
                if cdd_pract2_conf1.status == STARTED:
                    # update params
                    cdd_pract2_conf1.setFillColor(conf1_color, log=False)
                
                # if cdd_pract2_conf1 is stopping this frame...
                if cdd_pract2_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf1.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf1.status = FINISHED
                        cdd_pract2_conf1.setAutoDraw(False)
                
                # *cdd_pract2_conf1_txt* updates
                
                # if cdd_pract2_conf1_txt is starting this frame...
                if cdd_pract2_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf1_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf1_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf1_txt.status = STARTED
                    cdd_pract2_conf1_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf1_txt is active this frame...
                if cdd_pract2_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf1_txt is stopping this frame...
                if cdd_pract2_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf1_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf1_txt.status = FINISHED
                        cdd_pract2_conf1_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf2* updates
                
                # if cdd_pract2_conf2 is starting this frame...
                if cdd_pract2_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf2.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf2.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf2.status = STARTED
                    cdd_pract2_conf2.setAutoDraw(True)
                
                # if cdd_pract2_conf2 is active this frame...
                if cdd_pract2_conf2.status == STARTED:
                    # update params
                    cdd_pract2_conf2.setFillColor(conf2_color, log=False)
                
                # if cdd_pract2_conf2 is stopping this frame...
                if cdd_pract2_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf2.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf2.status = FINISHED
                        cdd_pract2_conf2.setAutoDraw(False)
                
                # *cdd_pract2_conf2_txt* updates
                
                # if cdd_pract2_conf2_txt is starting this frame...
                if cdd_pract2_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf2_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf2_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf2_txt.status = STARTED
                    cdd_pract2_conf2_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf2_txt is active this frame...
                if cdd_pract2_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf2_txt is stopping this frame...
                if cdd_pract2_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf2_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf2_txt.status = FINISHED
                        cdd_pract2_conf2_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf3* updates
                
                # if cdd_pract2_conf3 is starting this frame...
                if cdd_pract2_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf3.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf3.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf3.status = STARTED
                    cdd_pract2_conf3.setAutoDraw(True)
                
                # if cdd_pract2_conf3 is active this frame...
                if cdd_pract2_conf3.status == STARTED:
                    # update params
                    cdd_pract2_conf3.setFillColor(conf3_color, log=False)
                
                # if cdd_pract2_conf3 is stopping this frame...
                if cdd_pract2_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf3.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf3.status = FINISHED
                        cdd_pract2_conf3.setAutoDraw(False)
                
                # *cdd_pract2_conf3_txt* updates
                
                # if cdd_pract2_conf3_txt is starting this frame...
                if cdd_pract2_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf3_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf3_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf3_txt.status = STARTED
                    cdd_pract2_conf3_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf3_txt is active this frame...
                if cdd_pract2_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf3_txt is stopping this frame...
                if cdd_pract2_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf3_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf3_txt.status = FINISHED
                        cdd_pract2_conf3_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf4* updates
                
                # if cdd_pract2_conf4 is starting this frame...
                if cdd_pract2_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf4.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf4.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf4.status = STARTED
                    cdd_pract2_conf4.setAutoDraw(True)
                
                # if cdd_pract2_conf4 is active this frame...
                if cdd_pract2_conf4.status == STARTED:
                    # update params
                    cdd_pract2_conf4.setFillColor(conf4_color, log=False)
                
                # if cdd_pract2_conf4 is stopping this frame...
                if cdd_pract2_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf4.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf4.status = FINISHED
                        cdd_pract2_conf4.setAutoDraw(False)
                
                # *cdd_pract2_conf4_txt* updates
                
                # if cdd_pract2_conf4_txt is starting this frame...
                if cdd_pract2_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf4_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf4_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf4_txt.status = STARTED
                    cdd_pract2_conf4_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf4_txt is active this frame...
                if cdd_pract2_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf4_txt is stopping this frame...
                if cdd_pract2_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf4_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf4_txt.status = FINISHED
                        cdd_pract2_conf4_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf_resp* updates
                waitOnFlip = False
                
                # if cdd_pract2_conf_resp is starting this frame...
                if cdd_pract2_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf_resp.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract2_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract2_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract2_conf_resp is stopping this frame...
                if cdd_pract2_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf_resp.status = FINISHED
                        cdd_pract2_conf_resp.status = FINISHED
                if cdd_pract2_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract2_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract2_conf_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract2_conf_resp_allKeys):
                        cdd_pract2_conf_resp.keys = _cdd_pract2_conf_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract2_conf_resp.rt = _cdd_pract2_conf_resp_allKeys[-1].rt
                        cdd_pract2_conf_resp.duration = _cdd_pract2_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_conf" ---
            for thisComponent in cdd_pract2_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_conf.stopped', globalClock.getTime())
            # check responses
            if cdd_pract2_conf_resp.keys in ['', [], None]:  # No response was made
                cdd_pract2_conf_resp.keys = None
            cdd_pract2_trials1.addData('cdd_pract2_conf_resp.keys',cdd_pract2_conf_resp.keys)
            if cdd_pract2_conf_resp.keys != None:  # we had a response
                cdd_pract2_trials1.addData('cdd_pract2_conf_resp.rt', cdd_pract2_conf_resp.rt)
                cdd_pract2_trials1.addData('cdd_pract2_conf_resp.duration', cdd_pract2_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "cdd_pract2_iti1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_iti1.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_iti1_code
            #3 CDD practice trials
            if cdd_pract2_trials.thisTrialN == 2: #after the last practice trial
                continueRoutine = False #do not run ITI fixation
            # keep track of which components have finished
            cdd_pract2_iti1Components = [cdd_pract2_iti1_poly]
            for thisComponent in cdd_pract2_iti1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_iti1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_iti1_poly* updates
                
                # if cdd_pract2_iti1_poly is starting this frame...
                if cdd_pract2_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_iti1_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_iti1_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_iti1_poly.status = STARTED
                    cdd_pract2_iti1_poly.setAutoDraw(True)
                
                # if cdd_pract2_iti1_poly is active this frame...
                if cdd_pract2_iti1_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_iti1_poly is stopping this frame...
                if cdd_pract2_iti1_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_iti1_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_iti1_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_iti1_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_iti1_poly.status = FINISHED
                        cdd_pract2_iti1_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_iti1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_iti1" ---
            for thisComponent in cdd_pract2_iti1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_iti1.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_pract2_trials1'
        
        
        # --- Prepare to start Routine "cdd_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_trial_instr.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_trial_instr_code
        #QC check
        cdd_task_resps = []
        cdd_conf_resps = []
        cdd_catch_trials = []
        
        #variable ITI list creation
        cdd_iti_list = [random.random() for i in range(100)]
        cdd_s = sum(cdd_iti_list)
        cdd_iti_list = [i*100/cdd_s for i in cdd_iti_list]
        cdd_trial_instr_resp.keys = []
        cdd_trial_instr_resp.rt = []
        _cdd_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_trial_instrComponents = [cdd_trial_instr_title_txt, cdd_trial_instr_txt, cdd_trial_instr_space_txt, cdd_trial_instr_resp]
        for thisComponent in cdd_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_trial_instr_title_txt* updates
            
            # if cdd_trial_instr_title_txt is starting this frame...
            if cdd_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_title_txt.status = STARTED
                cdd_trial_instr_title_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_title_txt is active this frame...
            if cdd_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_txt* updates
            
            # if cdd_trial_instr_txt is starting this frame...
            if cdd_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_txt.status = STARTED
                cdd_trial_instr_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_txt is active this frame...
            if cdd_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_space_txt* updates
            
            # if cdd_trial_instr_space_txt is starting this frame...
            if cdd_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_space_txt.status = STARTED
                cdd_trial_instr_space_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_space_txt is active this frame...
            if cdd_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_trial_instr_resp is starting this frame...
            if cdd_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_resp.frameNStart = frameN  # exact frame index
                cdd_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_trial_instr_resp_allKeys):
                    cdd_trial_instr_resp.keys = _cdd_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_trial_instr_resp.rt = _cdd_trial_instr_resp_allKeys[-1].rt
                    cdd_trial_instr_resp.duration = _cdd_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_trial_instr" ---
        for thisComponent in cdd_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_trial_instr.stopped', globalClock.getTime())
        # the Routine "cdd_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_trials1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_gen_trials_idx.csv'),
            seed=None, name='cdd_trials1')
        thisExp.addLoop(cdd_trials1)  # add the loop to the experiment
        thisCdd_trials1 = cdd_trials1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_trials1.rgb)
        if thisCdd_trials1 != None:
            for paramName in thisCdd_trials1:
                globals()[paramName] = thisCdd_trials1[paramName]
        
        for thisCdd_trials1 in cdd_trials1:
            currentLoop = cdd_trials1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_trials1.rgb)
            if thisCdd_trials1 != None:
                for paramName in thisCdd_trials1:
                    globals()[paramName] = thisCdd_trials1[paramName]
            
            # --- Prepare to start Routine "cdd_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_trial.started', globalClock.getTime())
            cdd_trial_immed_txt.setPos(cdd_immed_pos)
            cdd_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt))) + "\n" + "\n" + " TODAY")
            cdd_trial_delay_txt.setPos(cdd_delay_pos)
            cdd_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt))) + "\n" + "\n" + str(cdd_delay_wait) + " DAYS")
            cdd_trial_resp.keys = []
            cdd_trial_resp.rt = []
            _cdd_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_trialComponents = [cdd_trial_left_poly, cdd_trial_right_poly, cdd_trial_prompt_txt, cdd_trial_immed_txt, cdd_trial_or_txt, cdd_trial_delay_txt, cdd_trial_cue, cdd_trial_resp]
            for thisComponent in cdd_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_trial_left_poly* updates
                
                # if cdd_trial_left_poly is starting this frame...
                if cdd_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_left_poly.status = STARTED
                    cdd_trial_left_poly.setAutoDraw(True)
                
                # if cdd_trial_left_poly is active this frame...
                if cdd_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_left_poly is stopping this frame...
                if cdd_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_left_poly.status = FINISHED
                        cdd_trial_left_poly.setAutoDraw(False)
                
                # *cdd_trial_right_poly* updates
                
                # if cdd_trial_right_poly is starting this frame...
                if cdd_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_right_poly.status = STARTED
                    cdd_trial_right_poly.setAutoDraw(True)
                
                # if cdd_trial_right_poly is active this frame...
                if cdd_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_right_poly is stopping this frame...
                if cdd_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_right_poly.status = FINISHED
                        cdd_trial_right_poly.setAutoDraw(False)
                
                # *cdd_trial_prompt_txt* updates
                
                # if cdd_trial_prompt_txt is starting this frame...
                if cdd_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_prompt_txt.status = STARTED
                    cdd_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_trial_prompt_txt is active this frame...
                if cdd_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_prompt_txt is stopping this frame...
                if cdd_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_prompt_txt.status = FINISHED
                        cdd_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_trial_immed_txt* updates
                
                # if cdd_trial_immed_txt is starting this frame...
                if cdd_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_immed_txt.status = STARTED
                    cdd_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_trial_immed_txt is active this frame...
                if cdd_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_immed_txt is stopping this frame...
                if cdd_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_immed_txt.status = FINISHED
                        cdd_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_trial_or_txt* updates
                
                # if cdd_trial_or_txt is starting this frame...
                if cdd_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_or_txt.status = STARTED
                    cdd_trial_or_txt.setAutoDraw(True)
                
                # if cdd_trial_or_txt is active this frame...
                if cdd_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_or_txt is stopping this frame...
                if cdd_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_or_txt.status = FINISHED
                        cdd_trial_or_txt.setAutoDraw(False)
                
                # *cdd_trial_delay_txt* updates
                
                # if cdd_trial_delay_txt is starting this frame...
                if cdd_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_delay_txt.status = STARTED
                    cdd_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_trial_delay_txt is active this frame...
                if cdd_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_delay_txt is stopping this frame...
                if cdd_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_delay_txt.status = FINISHED
                        cdd_trial_delay_txt.setAutoDraw(False)
                
                # *cdd_trial_cue* updates
                
                # if cdd_trial_cue is starting this frame...
                if cdd_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'cdd_trial_cue.started')
                    # update status
                    cdd_trial_cue.status = STARTED
                    cdd_trial_cue.setAutoDraw(True)
                
                # if cdd_trial_cue is active this frame...
                if cdd_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_cue is stopping this frame...
                if cdd_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_trial_cue.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cdd_trial_cue.stopped')
                        # update status
                        cdd_trial_cue.status = FINISHED
                        cdd_trial_cue.setAutoDraw(False)
                
                # *cdd_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_trial_resp is starting this frame...
                if cdd_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_trial_resp is stopping this frame...
                if cdd_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_resp.status = FINISHED
                        cdd_trial_resp.status = FINISHED
                if cdd_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_trial_resp_allKeys):
                        cdd_trial_resp.keys = _cdd_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_trial_resp.rt = _cdd_trial_resp_allKeys[-1].rt
                        cdd_trial_resp.duration = _cdd_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_trial_resp.keys == str(cdd_immed_resp)) or (cdd_trial_resp.keys == cdd_immed_resp):
                            cdd_trial_resp.corr = 1
                        else:
                            cdd_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_trial" ---
            for thisComponent in cdd_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_trial.stopped', globalClock.getTime())
            # check responses
            if cdd_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp).lower() == 'none':
                   cdd_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_trials1 (TrialHandler)
            cdd_trials1.addData('cdd_trial_resp.keys',cdd_trial_resp.keys)
            cdd_trials1.addData('cdd_trial_resp.corr', cdd_trial_resp.corr)
            if cdd_trial_resp.keys != None:  # we had a response
                cdd_trials1.addData('cdd_trial_resp.rt', cdd_trial_resp.rt)
                cdd_trials1.addData('cdd_trial_resp.duration', cdd_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_feedback_code
            if len(cdd_key) == 0: #Ss did not respond
                cdd_msg = "NO RESPONSE"
            elif cdd_immed_key: #Ss chose smaller, immediate option
                cdd_msg = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg = "$ LATER"
            cdd_feedback_txt.setText(cdd_msg)
            # keep track of which components have finished
            cdd_feedbackComponents = [cdd_feedback_txt]
            for thisComponent in cdd_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_feedback_txt* updates
                
                # if cdd_feedback_txt is starting this frame...
                if cdd_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_feedback_txt.frameNStart = frameN  # exact frame index
                    cdd_feedback_txt.tStart = t  # local t and not account for scr refresh
                    cdd_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_feedback_txt.status = STARTED
                    cdd_feedback_txt.setAutoDraw(True)
                
                # if cdd_feedback_txt is active this frame...
                if cdd_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_feedback_txt is stopping this frame...
                if cdd_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_feedback_txt.tStop = t  # not accounting for scr refresh
                        cdd_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_feedback_txt.status = FINISHED
                        cdd_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_feedback" ---
            for thisComponent in cdd_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "cdd_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_conf_code
            #Ss did not respond to choice trial
            if len(cdd_key) == 0:
                continueRoutine = False
            
            #set all 4 boxes as gray by default
            conf1_color = [0, 0, 0]
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            cdd_conf_resp.keys = []
            cdd_conf_resp.rt = []
            _cdd_conf_resp_allKeys = []
            # keep track of which components have finished
            cdd_confComponents = [cdd_conf_txt, cdd_conf1, cdd_conf1_txt, cdd_conf2, cdd_conf2_txt, cdd_conf3, cdd_conf3_txt, cdd_conf4, cdd_conf4_txt, cdd_conf_resp]
            for thisComponent in cdd_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cdd_conf_code
                cdd_conf_key = cdd_conf_resp.keys
                #confidence rating received
                if len(cdd_conf_key) == 1:
                    #not at all confident
                    if cdd_conf_key == "1":
                        conf1_color = "darkgray"
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #less confident
                    elif cdd_conf_key == "2":
                        conf1_color = [0, 0, 0]
                        conf2_color = "darkgray"
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #somewhat confident
                    elif cdd_conf_key == "3":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = "darkgray"
                        conf4_color = [0, 0, 0]
                    #very confident
                    elif cdd_conf_key == "4":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = "darkgray"
                
                # *cdd_conf_txt* updates
                
                # if cdd_conf_txt is starting this frame...
                if cdd_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf_txt.frameNStart = frameN  # exact frame index
                    cdd_conf_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf_txt.status = STARTED
                    cdd_conf_txt.setAutoDraw(True)
                
                # if cdd_conf_txt is active this frame...
                if cdd_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf_txt is stopping this frame...
                if cdd_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf_txt.status = FINISHED
                        cdd_conf_txt.setAutoDraw(False)
                
                # *cdd_conf1* updates
                
                # if cdd_conf1 is starting this frame...
                if cdd_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf1.frameNStart = frameN  # exact frame index
                    cdd_conf1.tStart = t  # local t and not account for scr refresh
                    cdd_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf1.status = STARTED
                    cdd_conf1.setAutoDraw(True)
                
                # if cdd_conf1 is active this frame...
                if cdd_conf1.status == STARTED:
                    # update params
                    cdd_conf1.setFillColor(conf1_color, log=False)
                
                # if cdd_conf1 is stopping this frame...
                if cdd_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf1.tStop = t  # not accounting for scr refresh
                        cdd_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf1.status = FINISHED
                        cdd_conf1.setAutoDraw(False)
                
                # *cdd_conf1_txt* updates
                
                # if cdd_conf1_txt is starting this frame...
                if cdd_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf1_txt.frameNStart = frameN  # exact frame index
                    cdd_conf1_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf1_txt.status = STARTED
                    cdd_conf1_txt.setAutoDraw(True)
                
                # if cdd_conf1_txt is active this frame...
                if cdd_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf1_txt is stopping this frame...
                if cdd_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf1_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf1_txt.status = FINISHED
                        cdd_conf1_txt.setAutoDraw(False)
                
                # *cdd_conf2* updates
                
                # if cdd_conf2 is starting this frame...
                if cdd_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf2.frameNStart = frameN  # exact frame index
                    cdd_conf2.tStart = t  # local t and not account for scr refresh
                    cdd_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf2.status = STARTED
                    cdd_conf2.setAutoDraw(True)
                
                # if cdd_conf2 is active this frame...
                if cdd_conf2.status == STARTED:
                    # update params
                    cdd_conf2.setFillColor(conf2_color, log=False)
                
                # if cdd_conf2 is stopping this frame...
                if cdd_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf2.tStop = t  # not accounting for scr refresh
                        cdd_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf2.status = FINISHED
                        cdd_conf2.setAutoDraw(False)
                
                # *cdd_conf2_txt* updates
                
                # if cdd_conf2_txt is starting this frame...
                if cdd_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf2_txt.frameNStart = frameN  # exact frame index
                    cdd_conf2_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf2_txt.status = STARTED
                    cdd_conf2_txt.setAutoDraw(True)
                
                # if cdd_conf2_txt is active this frame...
                if cdd_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf2_txt is stopping this frame...
                if cdd_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf2_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf2_txt.status = FINISHED
                        cdd_conf2_txt.setAutoDraw(False)
                
                # *cdd_conf3* updates
                
                # if cdd_conf3 is starting this frame...
                if cdd_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf3.frameNStart = frameN  # exact frame index
                    cdd_conf3.tStart = t  # local t and not account for scr refresh
                    cdd_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf3.status = STARTED
                    cdd_conf3.setAutoDraw(True)
                
                # if cdd_conf3 is active this frame...
                if cdd_conf3.status == STARTED:
                    # update params
                    cdd_conf3.setFillColor(conf3_color, log=False)
                
                # if cdd_conf3 is stopping this frame...
                if cdd_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf3.tStop = t  # not accounting for scr refresh
                        cdd_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf3.status = FINISHED
                        cdd_conf3.setAutoDraw(False)
                
                # *cdd_conf3_txt* updates
                
                # if cdd_conf3_txt is starting this frame...
                if cdd_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf3_txt.frameNStart = frameN  # exact frame index
                    cdd_conf3_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf3_txt.status = STARTED
                    cdd_conf3_txt.setAutoDraw(True)
                
                # if cdd_conf3_txt is active this frame...
                if cdd_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf3_txt is stopping this frame...
                if cdd_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf3_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf3_txt.status = FINISHED
                        cdd_conf3_txt.setAutoDraw(False)
                
                # *cdd_conf4* updates
                
                # if cdd_conf4 is starting this frame...
                if cdd_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf4.frameNStart = frameN  # exact frame index
                    cdd_conf4.tStart = t  # local t and not account for scr refresh
                    cdd_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf4.status = STARTED
                    cdd_conf4.setAutoDraw(True)
                
                # if cdd_conf4 is active this frame...
                if cdd_conf4.status == STARTED:
                    # update params
                    cdd_conf4.setFillColor(conf4_color, log=False)
                
                # if cdd_conf4 is stopping this frame...
                if cdd_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf4.tStop = t  # not accounting for scr refresh
                        cdd_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf4.status = FINISHED
                        cdd_conf4.setAutoDraw(False)
                
                # *cdd_conf4_txt* updates
                
                # if cdd_conf4_txt is starting this frame...
                if cdd_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf4_txt.frameNStart = frameN  # exact frame index
                    cdd_conf4_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf4_txt.status = STARTED
                    cdd_conf4_txt.setAutoDraw(True)
                
                # if cdd_conf4_txt is active this frame...
                if cdd_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf4_txt is stopping this frame...
                if cdd_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf4_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf4_txt.status = FINISHED
                        cdd_conf4_txt.setAutoDraw(False)
                
                # *cdd_conf_resp* updates
                waitOnFlip = False
                
                # if cdd_conf_resp is starting this frame...
                if cdd_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf_resp.frameNStart = frameN  # exact frame index
                    cdd_conf_resp.tStart = t  # local t and not account for scr refresh
                    cdd_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_conf_resp is stopping this frame...
                if cdd_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf_resp.tStop = t  # not accounting for scr refresh
                        cdd_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf_resp.status = FINISHED
                        cdd_conf_resp.status = FINISHED
                if cdd_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_conf_resp_allKeys.extend(theseKeys)
                    if len(_cdd_conf_resp_allKeys):
                        cdd_conf_resp.keys = _cdd_conf_resp_allKeys[-1].name  # just the last key pressed
                        cdd_conf_resp.rt = _cdd_conf_resp_allKeys[-1].rt
                        cdd_conf_resp.duration = _cdd_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_conf" ---
            for thisComponent in cdd_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_conf.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_conf_code
            my_loop.addData("cdd_conf", cdd_conf_key)
            
            if len(cdd_conf_key) == 1:
                if type(cdd_conf_key) == list:
                    if cdd_conf_key[-1] in ["1", "2", "3", "4"]:
                        cdd_conf_resps.append(cdd_conf_key)
                else:
                    if cdd_conf_key in ["1", "2", "3", "4"]:
                        cdd_conf_resps.append(cdd_conf_key)
            # check responses
            if cdd_conf_resp.keys in ['', [], None]:  # No response was made
                cdd_conf_resp.keys = None
            cdd_trials1.addData('cdd_conf_resp.keys',cdd_conf_resp.keys)
            if cdd_conf_resp.keys != None:  # we had a response
                cdd_trials1.addData('cdd_conf_resp.rt', cdd_conf_resp.rt)
                cdd_trials1.addData('cdd_conf_resp.duration', cdd_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "cdd_trial_iti1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_trial_iti1.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_trial_iti1_code
            cdd_iti_time = cdd_iti_list[my_loop.thisIndex] + cdd_delta_time #variable ITI for non-practice trials
            #96 trials in CDD task
            if cdd_trials1.thisTrialN == 95: #after the final task trial
                continueRoutine = False #do not show ITI fixation
            # keep track of which components have finished
            cdd_trial_iti1Components = [cdd_trial_iti1_poly]
            for thisComponent in cdd_trial_iti1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_trial_iti1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_trial_iti1_poly* updates
                
                # if cdd_trial_iti1_poly is starting this frame...
                if cdd_trial_iti1_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_iti1_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_iti1_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_iti1_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_iti1_poly, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'cdd_trial_iti1_poly.started')
                    # update status
                    cdd_trial_iti1_poly.status = STARTED
                    cdd_trial_iti1_poly.setAutoDraw(True)
                
                # if cdd_trial_iti1_poly is active this frame...
                if cdd_trial_iti1_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_iti1_poly is stopping this frame...
                if cdd_trial_iti1_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_iti1_poly.tStartRefresh + cdd_iti_time-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_iti1_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_iti1_poly.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cdd_trial_iti1_poly.stopped')
                        # update status
                        cdd_trial_iti1_poly.status = FINISHED
                        cdd_trial_iti1_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_trial_iti1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_trial_iti1" ---
            for thisComponent in cdd_trial_iti1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_trial_iti1.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_trial_iti1_code
            my_loop.addData("cdd_delta_time", delta_time)
            my_loop.addData("cdd_iti_time", iti_time)
            # the Routine "cdd_trial_iti1" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_trials1'
        
        
        # --- Prepare to start Routine "cdd_end" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_end.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_end_code
        cdd_unique_resps = []
        cdd_unique_count = 0
        for i in cdd_task_resps:
            if i not in cdd_unique_resps:
                cdd_unique_count += 1
                cdd_unique_resps.append(i)
        
        cdd_task_end_text = ""
        cdd_space_text = ""
        #filter for nonresponses
        if len(cdd_task_resps) < 95 or len(cdd_conf_resps) < 95: #95% of 100 CDD trials
            if len(cdd_task_resps) < 95:
                cdd_task_end_text = "You failed to respond to " + str(100-len(cdd_task_resps)) + " task trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            if len(cdd_conf_resps) < 95:
                cdd_task_end_text = "You failed to respond to both parts of " + str(100-len(cdd_conf_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            cdd_space_text = "Press SPACE to end."
            my_loop.addData("cdd_subReject1", "< 95% resp rate")
            my_loop.addData("cdd_subReject1_nonresps-task", 100-len(cdd_task_resps))
            my_loop.addData("cdd_subReject1_nonresps-conf", 100-len(cdd_conf_resps))
            exp_proceed = False
        #filter for single-button responses
        elif cdd_unique_count < 2: #same for each exp
            cdd_task_end_text = "You provided the same response to all " + str(len(cdd_task_resps)) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            cdd_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("cdd_subReject2", "1key response")
            my_loop.addData("cdd_subReject2_key", cdd_task_resps[0])
        #filter for poor performance on CDD catch trials (5/6 catch trials -- 3.125% of random success on 5 trials)
        #elif sum(cdd_catch_trials) < 5: 
        #    cdd_task_end_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
        #    cdd_space_text = "Press SPACE to end."
        #    exp_proceed = False
        #    my_loop.addData("cdd_subReject3", "catch fail")
        #    my_loop.addData("cdd_subReject3_fails", 6-sum(cdd_catch_trials))
        #all CDD task trial criterion are met
        else:
            cdd_task_end_text = "You have completed the Delay Discounting Task!"
            cdd_space_text = "Press SPACE to continue."
        cdd_end_txt_ON.setText(cdd_task_end_text)
        cdd_end_space_ON.setText(cdd_space_text)
        cdd_end_resp.keys = []
        cdd_end_resp.rt = []
        _cdd_end_resp_allKeys = []
        # keep track of which components have finished
        cdd_endComponents = [cdd_end_title_txt, cdd_end_txt_ON, cdd_end_space_ON, cdd_end_resp]
        for thisComponent in cdd_endComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_end" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_end_title_txt* updates
            
            # if cdd_end_title_txt is starting this frame...
            if cdd_end_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_title_txt.frameNStart = frameN  # exact frame index
                cdd_end_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_end_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_title_txt.status = STARTED
                cdd_end_title_txt.setAutoDraw(True)
            
            # if cdd_end_title_txt is active this frame...
            if cdd_end_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_end_txt_ON* updates
            
            # if cdd_end_txt_ON is starting this frame...
            if cdd_end_txt_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_txt_ON.frameNStart = frameN  # exact frame index
                cdd_end_txt_ON.tStart = t  # local t and not account for scr refresh
                cdd_end_txt_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_txt_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_txt_ON.status = STARTED
                cdd_end_txt_ON.setAutoDraw(True)
            
            # if cdd_end_txt_ON is active this frame...
            if cdd_end_txt_ON.status == STARTED:
                # update params
                pass
            
            # *cdd_end_space_ON* updates
            
            # if cdd_end_space_ON is starting this frame...
            if cdd_end_space_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_space_ON.frameNStart = frameN  # exact frame index
                cdd_end_space_ON.tStart = t  # local t and not account for scr refresh
                cdd_end_space_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_space_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_space_ON.status = STARTED
                cdd_end_space_ON.setAutoDraw(True)
            
            # if cdd_end_space_ON is active this frame...
            if cdd_end_space_ON.status == STARTED:
                # update params
                pass
            
            # *cdd_end_resp* updates
            waitOnFlip = False
            
            # if cdd_end_resp is starting this frame...
            if cdd_end_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_resp.frameNStart = frameN  # exact frame index
                cdd_end_resp.tStart = t  # local t and not account for scr refresh
                cdd_end_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_end_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_end_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_end_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_end_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_end_resp_allKeys.extend(theseKeys)
                if len(_cdd_end_resp_allKeys):
                    cdd_end_resp.keys = _cdd_end_resp_allKeys[-1].name  # just the last key pressed
                    cdd_end_resp.rt = _cdd_end_resp_allKeys[-1].rt
                    cdd_end_resp.duration = _cdd_end_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_endComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_end" ---
        for thisComponent in cdd_endComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_end.stopped', globalClock.getTime())
        # the Routine "cdd_end" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "idm_term_check" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_term_check.started', globalClock.getTime())
        # Run 'Begin Routine' code from idm_term_check_code
        if exp_proceed == False:
            core.quit()
        # keep track of which components have finished
        idm_term_checkComponents = []
        for thisComponent in idm_term_checkComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_term_check" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_term_check" ---
        for thisComponent in idm_term_checkComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_term_check.stopped', globalClock.getTime())
        # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
    # completed loop3 repeats of 'should_run3'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run4 = data.TrialHandler(nReps=loop4, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run4')
    thisExp.addLoop(should_run4)  # add the loop to the experiment
    thisShould_run4 = should_run4.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run4.rgb)
    if thisShould_run4 != None:
        for paramName in thisShould_run4:
            globals()[paramName] = thisShould_run4[paramName]
    
    for thisShould_run4 in should_run4:
        currentLoop = should_run4
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run4.rgb)
        if thisShould_run4 != None:
            for paramName in thisShould_run4:
                globals()[paramName] = thisShould_run4[paramName]
        
        # --- Prepare to start Routine "cpdm_namer2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_namer2.started', globalClock.getTime())
        # Run 'Begin Routine' code from cpdm_namer2_code
        cpdm_practice_loop_name = "cpdm_pract_trials2"
        cpdm_loop_name = "cpdm_trials2"
        # keep track of which components have finished
        cpdm_namer2Components = []
        for thisComponent in cpdm_namer2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_namer2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_namer2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_namer2" ---
        for thisComponent in cpdm_namer2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_namer2.stopped', globalClock.getTime())
        # the Routine "cpdm_namer2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr1.started', globalClock.getTime())
        cpdm_instr1_resp.keys = []
        cpdm_instr1_resp.rt = []
        _cpdm_instr1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr1Components = [cpdm_instr1_img, cpdm_instr1_title_txt, cpdm_instr1_txt, cpdm_instr1_Q_txt, cpdm_instr1_P_txt, cpdm_instr1_A_txt, cpdm_instr1_L_txt, cpdm_instr1_space_txt, cpdm_instr1_resp]
        for thisComponent in cpdm_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr1_img* updates
            
            # if cpdm_instr1_img is starting this frame...
            if cpdm_instr1_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_img.frameNStart = frameN  # exact frame index
                cpdm_instr1_img.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_img.status = STARTED
                cpdm_instr1_img.setAutoDraw(True)
            
            # if cpdm_instr1_img is active this frame...
            if cpdm_instr1_img.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_title_txt* updates
            
            # if cpdm_instr1_title_txt is starting this frame...
            if cpdm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_title_txt.status = STARTED
                cpdm_instr1_title_txt.setAutoDraw(True)
            
            # if cpdm_instr1_title_txt is active this frame...
            if cpdm_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_txt* updates
            
            # if cpdm_instr1_txt is starting this frame...
            if cpdm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_txt.status = STARTED
                cpdm_instr1_txt.setAutoDraw(True)
            
            # if cpdm_instr1_txt is active this frame...
            if cpdm_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_Q_txt* updates
            
            # if cpdm_instr1_Q_txt is starting this frame...
            if cpdm_instr1_Q_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_Q_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_Q_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_Q_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_Q_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_Q_txt.status = STARTED
                cpdm_instr1_Q_txt.setAutoDraw(True)
            
            # if cpdm_instr1_Q_txt is active this frame...
            if cpdm_instr1_Q_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_P_txt* updates
            
            # if cpdm_instr1_P_txt is starting this frame...
            if cpdm_instr1_P_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_P_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_P_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_P_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_P_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_P_txt.status = STARTED
                cpdm_instr1_P_txt.setAutoDraw(True)
            
            # if cpdm_instr1_P_txt is active this frame...
            if cpdm_instr1_P_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_A_txt* updates
            
            # if cpdm_instr1_A_txt is starting this frame...
            if cpdm_instr1_A_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_A_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_A_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_A_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_A_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_A_txt.status = STARTED
                cpdm_instr1_A_txt.setAutoDraw(True)
            
            # if cpdm_instr1_A_txt is active this frame...
            if cpdm_instr1_A_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_L_txt* updates
            
            # if cpdm_instr1_L_txt is starting this frame...
            if cpdm_instr1_L_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_L_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_L_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_L_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_L_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_L_txt.status = STARTED
                cpdm_instr1_L_txt.setAutoDraw(True)
            
            # if cpdm_instr1_L_txt is active this frame...
            if cpdm_instr1_L_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_space_txt* updates
            
            # if cpdm_instr1_space_txt is starting this frame...
            if cpdm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_space_txt.status = STARTED
                cpdm_instr1_space_txt.setAutoDraw(True)
            
            # if cpdm_instr1_space_txt is active this frame...
            if cpdm_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr1_resp is starting this frame...
            if cpdm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_resp.frameNStart = frameN  # exact frame index
                cpdm_instr1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr1_resp_allKeys):
                    cpdm_instr1_resp.keys = _cpdm_instr1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr1_resp.rt = _cpdm_instr1_resp_allKeys[-1].rt
                    cpdm_instr1_resp.duration = _cpdm_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr1" ---
        for thisComponent in cpdm_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr1.stopped', globalClock.getTime())
        # the Routine "cpdm_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr2.started', globalClock.getTime())
        cpdm_instr2_resp.keys = []
        cpdm_instr2_resp.rt = []
        _cpdm_instr2_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr2Components = [cpdm_instr2_title_txt, cpdm_instr2_instr_txt, cpdm_instr2_left_arrow, cpdm_instr2_left_gabor, cpdm_instr2_left_txt, cpdm_instr2_right_arrow, cpdm_instr2_right_gabor, cpdm_instr2_right_txt, cpdm_instr2_space_txt, cpdm_instr2_resp]
        for thisComponent in cpdm_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr2_title_txt* updates
            
            # if cpdm_instr2_title_txt is starting this frame...
            if cpdm_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_title_txt.status = STARTED
                cpdm_instr2_title_txt.setAutoDraw(True)
            
            # if cpdm_instr2_title_txt is active this frame...
            if cpdm_instr2_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_instr_txt* updates
            
            # if cpdm_instr2_instr_txt is starting this frame...
            if cpdm_instr2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_instr_txt.status = STARTED
                cpdm_instr2_instr_txt.setAutoDraw(True)
            
            # if cpdm_instr2_instr_txt is active this frame...
            if cpdm_instr2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_arrow* updates
            
            # if cpdm_instr2_left_arrow is starting this frame...
            if cpdm_instr2_left_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_arrow.status = STARTED
                cpdm_instr2_left_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_left_arrow is active this frame...
            if cpdm_instr2_left_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_gabor* updates
            
            # if cpdm_instr2_left_gabor is starting this frame...
            if cpdm_instr2_left_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_gabor.status = STARTED
                cpdm_instr2_left_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_left_gabor is active this frame...
            if cpdm_instr2_left_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_txt* updates
            
            # if cpdm_instr2_left_txt is starting this frame...
            if cpdm_instr2_left_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_txt.status = STARTED
                cpdm_instr2_left_txt.setAutoDraw(True)
            
            # if cpdm_instr2_left_txt is active this frame...
            if cpdm_instr2_left_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_arrow* updates
            
            # if cpdm_instr2_right_arrow is starting this frame...
            if cpdm_instr2_right_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_arrow.status = STARTED
                cpdm_instr2_right_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_right_arrow is active this frame...
            if cpdm_instr2_right_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_gabor* updates
            
            # if cpdm_instr2_right_gabor is starting this frame...
            if cpdm_instr2_right_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_gabor.status = STARTED
                cpdm_instr2_right_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_right_gabor is active this frame...
            if cpdm_instr2_right_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_txt* updates
            
            # if cpdm_instr2_right_txt is starting this frame...
            if cpdm_instr2_right_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_txt.status = STARTED
                cpdm_instr2_right_txt.setAutoDraw(True)
            
            # if cpdm_instr2_right_txt is active this frame...
            if cpdm_instr2_right_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_space_txt* updates
            
            # if cpdm_instr2_space_txt is starting this frame...
            if cpdm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_space_txt.status = STARTED
                cpdm_instr2_space_txt.setAutoDraw(True)
            
            # if cpdm_instr2_space_txt is active this frame...
            if cpdm_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr2_resp is starting this frame...
            if cpdm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_resp.frameNStart = frameN  # exact frame index
                cpdm_instr2_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr2_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr2_resp_allKeys):
                    cpdm_instr2_resp.keys = _cpdm_instr2_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr2_resp.rt = _cpdm_instr2_resp_allKeys[-1].rt
                    cpdm_instr2_resp.duration = _cpdm_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr2" ---
        for thisComponent in cpdm_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr2.stopped', globalClock.getTime())
        # the Routine "cpdm_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr3.started', globalClock.getTime())
        cpdm_instr3_resp.keys = []
        cpdm_instr3_resp.rt = []
        _cpdm_instr3_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr3Components = [cpdm_instr3_title_txt, cpdm_instr3_txt, cpdm_instr3_space_txt, cpdm_instr3_resp]
        for thisComponent in cpdm_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr3_title_txt* updates
            
            # if cpdm_instr3_title_txt is starting this frame...
            if cpdm_instr3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_title_txt.status = STARTED
                cpdm_instr3_title_txt.setAutoDraw(True)
            
            # if cpdm_instr3_title_txt is active this frame...
            if cpdm_instr3_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_txt* updates
            
            # if cpdm_instr3_txt is starting this frame...
            if cpdm_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_txt.status = STARTED
                cpdm_instr3_txt.setAutoDraw(True)
            
            # if cpdm_instr3_txt is active this frame...
            if cpdm_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_space_txt* updates
            
            # if cpdm_instr3_space_txt is starting this frame...
            if cpdm_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_space_txt.status = STARTED
                cpdm_instr3_space_txt.setAutoDraw(True)
            
            # if cpdm_instr3_space_txt is active this frame...
            if cpdm_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr3_resp is starting this frame...
            if cpdm_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_resp.frameNStart = frameN  # exact frame index
                cpdm_instr3_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr3_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr3_resp_allKeys):
                    cpdm_instr3_resp.keys = _cpdm_instr3_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr3_resp.rt = _cpdm_instr3_resp_allKeys[-1].rt
                    cpdm_instr3_resp.duration = _cpdm_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr3" ---
        for thisComponent in cpdm_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr3.stopped', globalClock.getTime())
        # the Routine "cpdm_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr4.started', globalClock.getTime())
        cpdm_instr4_resp.keys = []
        cpdm_instr4_resp.rt = []
        _cpdm_instr4_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr4Components = [cpdm_instr4_title_txt, cpdm_instr4_txt, cpdm_instr4_space_txt, cpdm_instr4_resp]
        for thisComponent in cpdm_instr4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr4_title_txt* updates
            
            # if cpdm_instr4_title_txt is starting this frame...
            if cpdm_instr4_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_title_txt.status = STARTED
                cpdm_instr4_title_txt.setAutoDraw(True)
            
            # if cpdm_instr4_title_txt is active this frame...
            if cpdm_instr4_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_txt* updates
            
            # if cpdm_instr4_txt is starting this frame...
            if cpdm_instr4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_txt.status = STARTED
                cpdm_instr4_txt.setAutoDraw(True)
            
            # if cpdm_instr4_txt is active this frame...
            if cpdm_instr4_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_space_txt* updates
            
            # if cpdm_instr4_space_txt is starting this frame...
            if cpdm_instr4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_space_txt.status = STARTED
                cpdm_instr4_space_txt.setAutoDraw(True)
            
            # if cpdm_instr4_space_txt is active this frame...
            if cpdm_instr4_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr4_resp is starting this frame...
            if cpdm_instr4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_resp.frameNStart = frameN  # exact frame index
                cpdm_instr4_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr4_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr4_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr4_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr4_resp_allKeys):
                    cpdm_instr4_resp.keys = _cpdm_instr4_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr4_resp.rt = _cpdm_instr4_resp_allKeys[-1].rt
                    cpdm_instr4_resp.duration = _cpdm_instr4_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr4" ---
        for thisComponent in cpdm_instr4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr4.stopped', globalClock.getTime())
        # the Routine "cpdm_instr4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_warn.started', globalClock.getTime())
        cpdm_warn1_resp.keys = []
        cpdm_warn1_resp.rt = []
        _cpdm_warn1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_warnComponents = [cpdm_warn1_title_txt, cpdm_warn1_txt, cpdm_warn1_space_txt, cpdm_warn1_resp]
        for thisComponent in cpdm_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_warn1_title_txt* updates
            
            # if cpdm_warn1_title_txt is starting this frame...
            if cpdm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_title_txt.status = STARTED
                cpdm_warn1_title_txt.setAutoDraw(True)
            
            # if cpdm_warn1_title_txt is active this frame...
            if cpdm_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_txt* updates
            
            # if cpdm_warn1_txt is starting this frame...
            if cpdm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_txt.status = STARTED
                cpdm_warn1_txt.setAutoDraw(True)
            
            # if cpdm_warn1_txt is active this frame...
            if cpdm_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_space_txt* updates
            
            # if cpdm_warn1_space_txt is starting this frame...
            if cpdm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_space_txt.status = STARTED
                cpdm_warn1_space_txt.setAutoDraw(True)
            
            # if cpdm_warn1_space_txt is active this frame...
            if cpdm_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_resp* updates
            waitOnFlip = False
            
            # if cpdm_warn1_resp is starting this frame...
            if cpdm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_resp.frameNStart = frameN  # exact frame index
                cpdm_warn1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_warn1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_warn1_resp_allKeys):
                    cpdm_warn1_resp.keys = _cpdm_warn1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_warn1_resp.rt = _cpdm_warn1_resp_allKeys[-1].rt
                    cpdm_warn1_resp.duration = _cpdm_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_warn" ---
        for thisComponent in cpdm_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_warn.stopped', globalClock.getTime())
        # the Routine "cpdm_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_pract_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_pract_instr.started', globalClock.getTime())
        cpdm_pract_instr_resp.keys = []
        cpdm_pract_instr_resp.rt = []
        _cpdm_pract_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_pract_instrComponents = [cpdm_pract_instr_title_txt, cpdm_pract_instr_txt, cpdm_pract_instr_space_txt, cpdm_pract_instr_resp]
        for thisComponent in cpdm_pract_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_pract_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_pract_instr_title_txt* updates
            
            # if cpdm_pract_instr_title_txt is starting this frame...
            if cpdm_pract_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_title_txt.status = STARTED
                cpdm_pract_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_title_txt is active this frame...
            if cpdm_pract_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_txt* updates
            
            # if cpdm_pract_instr_txt is starting this frame...
            if cpdm_pract_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_txt.status = STARTED
                cpdm_pract_instr_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_txt is active this frame...
            if cpdm_pract_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_space_txt* updates
            
            # if cpdm_pract_instr_space_txt is starting this frame...
            if cpdm_pract_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_space_txt.status = STARTED
                cpdm_pract_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_space_txt is active this frame...
            if cpdm_pract_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_pract_instr_resp is starting this frame...
            if cpdm_pract_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_pract_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_pract_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_pract_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_pract_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_pract_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_pract_instr_resp_allKeys):
                    cpdm_pract_instr_resp.keys = _cpdm_pract_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_pract_instr_resp.rt = _cpdm_pract_instr_resp_allKeys[-1].rt
                    cpdm_pract_instr_resp.duration = _cpdm_pract_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_pract_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_pract_instr" ---
        for thisComponent in cpdm_pract_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_pract_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_pract_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cpdm_init_fixComponents = [cpdm_init_fix_poly]
        for thisComponent in cpdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_init_fix_poly* updates
            
            # if cpdm_init_fix_poly is starting this frame...
            if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_init_fix_poly.status = STARTED
                cpdm_init_fix_poly.setAutoDraw(True)
            
            # if cpdm_init_fix_poly is active this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if cpdm_init_fix_poly is stopping this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    cpdm_init_fix_poly.status = FINISHED
                    cpdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_init_fix" ---
        for thisComponent in cpdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cpdm_pract_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_practice.xlsx'),
            seed=None, name='cpdm_pract_trials2')
        thisExp.addLoop(cpdm_pract_trials2)  # add the loop to the experiment
        thisCpdm_pract_trials2 = cpdm_pract_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials2.rgb)
        if thisCpdm_pract_trials2 != None:
            for paramName in thisCpdm_pract_trials2:
                globals()[paramName] = thisCpdm_pract_trials2[paramName]
        
        for thisCpdm_pract_trials2 in cpdm_pract_trials2:
            currentLoop = cpdm_pract_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials2.rgb)
            if thisCpdm_pract_trials2 != None:
                for paramName in thisCpdm_pract_trials2:
                    globals()[paramName] = thisCpdm_pract_trials2[paramName]
            
            # --- Prepare to start Routine "cpdm_pract_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_trial_code
            my_loop = eval(practice_loop_name)
            trial_acc = 0
            trial_conf = 0 
            
            #set default gray for all four response boxes
            left_high_color = [0,0,0] 
            left_low_color = [0,0,0]
            right_high_color = [0,0,0]
            right_low_color = [0,0,0]
            
            is_clockwise = False 
            if cpdm_gabor_orient > 0.0: 
                is_clockwise = True
            elif cpdm_gabor_orient == 0.0: 
                rand_num = random.randint(1,2)
                if rand_num == 1:
                    is_clockwise = True
                else:
                    is_clockwise = False
            cpdm_pract_trial_gabor.setContrast(cpdm_gabor_contrast)
            cpdm_pract_trial_gabor.setOri(cpdm_gabor_orient)
            cpdm_pract_trial_resp.keys = []
            cpdm_pract_trial_resp.rt = []
            _cpdm_pract_trial_resp_allKeys = []
            # keep track of which components have finished
            cpdm_pract_trialComponents = [cpdm_pract_trial_gabor, cpdm_pract_trial_left_high_poly, cpdm_pract_trial_right_high_poly, cpdm_pract_trial_left_low_poly, cpdm_pract_trial_right_low_poly, cpdm_pract_trial_left_high_txt, cpdm_pract_trial_right_high_txt, cpdm_pract_trial_left_low_txt, cpdm_pract_trial_right_low_txt, cpdm_pract_trial_resp]
            for thisComponent in cpdm_pract_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.3:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cpdm_pract_trial_code
                #each trial and resp
                #checks which key Ss pressed and changed the color of the selected box
                #depending on correctness of selection
                #also changes correct_resp variable which is recorded in End Routine
                
                #resp is received
                key = cpdm_pract_trial_resp.keys
                if len(key) == 1: 
                    #Ss selected Left-High
                    if key == "q": 
                        trial_conf = 1
                        #and correct resp is Left
                        if is_clockwise == False: 
                            #change upper-left box to green
                            left_high_color = "green" 
                            #set correct resp to 1
                            trial_acc = 1 
                        #incorrect left resp
                        else: 
                            left_high_color = "red"
                    elif key == "a":
                        #correct left resp
                        if is_clockwise == False: 
                            left_low_color = "green"
                            trial_acc = 1
                        else:
                            left_low_color = "red"
                    elif key == "p":
                        trial_conf = 1
                        #correct right resp
                        if is_clockwise == True: 
                            right_high_color = "green"
                            trial_acc = 1
                            trial_conf = 1
                        #incorrect right resp
                        else: 
                            right_high_color = "red"
                    elif key == "l":
                        #correct right resp
                        if is_clockwise == True: 
                            right_low_color = "green"
                            trial_acc = 1
                        #incorrect right resp
                        else: 
                            right_low_color = "red"
                
                # *cpdm_pract_trial_gabor* updates
                
                # if cpdm_pract_trial_gabor is starting this frame...
                if cpdm_pract_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_gabor.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_gabor.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_gabor.status = STARTED
                    cpdm_pract_trial_gabor.setAutoDraw(True)
                
                # if cpdm_pract_trial_gabor is active this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_gabor is stopping this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_gabor.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_gabor.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_gabor.status = FINISHED
                        cpdm_pract_trial_gabor.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_poly* updates
                
                # if cpdm_pract_trial_left_high_poly is starting this frame...
                if cpdm_pract_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_poly.status = STARTED
                    cpdm_pract_trial_left_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_poly is active this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_high_poly.setFillColor(left_high_color, log=False)
                
                # if cpdm_pract_trial_left_high_poly is stopping this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_poly.status = FINISHED
                        cpdm_pract_trial_left_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_poly* updates
                
                # if cpdm_pract_trial_right_high_poly is starting this frame...
                if cpdm_pract_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_poly.status = STARTED
                    cpdm_pract_trial_right_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_poly is active this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_high_poly.setFillColor(right_high_color, log=False)
                
                # if cpdm_pract_trial_right_high_poly is stopping this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_poly.status = FINISHED
                        cpdm_pract_trial_right_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_poly* updates
                
                # if cpdm_pract_trial_left_low_poly is starting this frame...
                if cpdm_pract_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_poly.status = STARTED
                    cpdm_pract_trial_left_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_poly is active this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_low_poly.setFillColor(left_low_color, log=False)
                
                # if cpdm_pract_trial_left_low_poly is stopping this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_poly.status = FINISHED
                        cpdm_pract_trial_left_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_poly* updates
                
                # if cpdm_pract_trial_right_low_poly is starting this frame...
                if cpdm_pract_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_poly.status = STARTED
                    cpdm_pract_trial_right_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_poly is active this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_low_poly.setFillColor(right_low_color, log=False)
                
                # if cpdm_pract_trial_right_low_poly is stopping this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_poly.status = FINISHED
                        cpdm_pract_trial_right_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_txt* updates
                
                # if cpdm_pract_trial_left_high_txt is starting this frame...
                if cpdm_pract_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_txt.status = STARTED
                    cpdm_pract_trial_left_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_txt is active this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_high_txt is stopping this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_txt.status = FINISHED
                        cpdm_pract_trial_left_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_txt* updates
                
                # if cpdm_pract_trial_right_high_txt is starting this frame...
                if cpdm_pract_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_txt.status = STARTED
                    cpdm_pract_trial_right_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_txt is active this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_high_txt is stopping this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_txt.status = FINISHED
                        cpdm_pract_trial_right_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_txt* updates
                
                # if cpdm_pract_trial_left_low_txt is starting this frame...
                if cpdm_pract_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_txt.status = STARTED
                    cpdm_pract_trial_left_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_txt is active this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_low_txt is stopping this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_txt.status = FINISHED
                        cpdm_pract_trial_left_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_txt* updates
                
                # if cpdm_pract_trial_right_low_txt is starting this frame...
                if cpdm_pract_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_txt.status = STARTED
                    cpdm_pract_trial_right_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_txt is active this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_low_txt is stopping this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_txt.status = FINISHED
                        cpdm_pract_trial_right_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_resp* updates
                waitOnFlip = False
                
                # if cpdm_pract_trial_resp is starting this frame...
                if cpdm_pract_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_resp.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_pract_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_pract_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cpdm_pract_trial_resp is stopping this frame...
                if cpdm_pract_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_resp.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_resp.status = FINISHED
                        cpdm_pract_trial_resp.status = FINISHED
                if cpdm_pract_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_pract_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_pract_trial_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_pract_trial_resp_allKeys):
                        cpdm_pract_trial_resp.keys = _cpdm_pract_trial_resp_allKeys[0].name  # just the first key pressed
                        cpdm_pract_trial_resp.rt = _cpdm_pract_trial_resp_allKeys[0].rt
                        cpdm_pract_trial_resp.duration = _cpdm_pract_trial_resp_allKeys[0].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_trial" ---
            for thisComponent in cpdm_pract_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_pract_trial_code
            my_loop.addData("cpdm_pract_acc", trial_acc)
            my_loop.addData("cpdm_pract_conf", trial_conf)
            my_loop.addData("cpdm_trial_type", "practice")
            
            # check responses
            if cpdm_pract_trial_resp.keys in ['', [], None]:  # No response was made
                cpdm_pract_trial_resp.keys = None
            cpdm_pract_trials2.addData('cpdm_pract_trial_resp.keys',cpdm_pract_trial_resp.keys)
            if cpdm_pract_trial_resp.keys != None:  # we had a response
                cpdm_pract_trials2.addData('cpdm_pract_trial_resp.rt', cpdm_pract_trial_resp.rt)
                cpdm_pract_trials2.addData('cpdm_pract_trial_resp.duration', cpdm_pract_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.300000)
            
            # --- Prepare to start Routine "cpdm_pract_iti2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_iti2.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_iti2_code
            #5 CPDM practice trials
            if cpdm_pract_trials2.thisTrialN == 4:
                continueRoutine = False
            # keep track of which components have finished
            cpdm_pract_iti2Components = [cpdm_pract_iti_poly_2]
            for thisComponent in cpdm_pract_iti2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_iti2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_pract_iti_poly_2* updates
                
                # if cpdm_pract_iti_poly_2 is starting this frame...
                if cpdm_pract_iti_poly_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_iti_poly_2.frameNStart = frameN  # exact frame index
                    cpdm_pract_iti_poly_2.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_iti_poly_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_iti_poly_2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_iti_poly_2.status = STARTED
                    cpdm_pract_iti_poly_2.setAutoDraw(True)
                
                # if cpdm_pract_iti_poly_2 is active this frame...
                if cpdm_pract_iti_poly_2.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_iti_poly_2 is stopping this frame...
                if cpdm_pract_iti_poly_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_iti_poly_2.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_iti_poly_2.tStop = t  # not accounting for scr refresh
                        cpdm_pract_iti_poly_2.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_iti_poly_2.status = FINISHED
                        cpdm_pract_iti_poly_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_iti2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_iti2" ---
            for thisComponent in cpdm_pract_iti2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_iti2.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cpdm_pract_trials2'
        
        
        # --- Prepare to start Routine "cpdm_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_trial_instr.started', globalClock.getTime())
        cpdm_trial_instr_resp.keys = []
        cpdm_trial_instr_resp.rt = []
        _cpdm_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_trial_instrComponents = [cpdm_trial_instr_title_txt, cpdm_trial_instr_txt, cpdm_trial_instr_space_txt, cpdm_trial_instr_resp]
        for thisComponent in cpdm_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_trial_instr_title_txt* updates
            
            # if cpdm_trial_instr_title_txt is starting this frame...
            if cpdm_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_title_txt.status = STARTED
                cpdm_trial_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_title_txt is active this frame...
            if cpdm_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_txt* updates
            
            # if cpdm_trial_instr_txt is starting this frame...
            if cpdm_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_txt.status = STARTED
                cpdm_trial_instr_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_txt is active this frame...
            if cpdm_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_space_txt* updates
            
            # if cpdm_trial_instr_space_txt is starting this frame...
            if cpdm_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_space_txt.status = STARTED
                cpdm_trial_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_space_txt is active this frame...
            if cpdm_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_trial_instr_resp is starting this frame...
            if cpdm_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_trial_instr_resp_allKeys):
                    cpdm_trial_instr_resp.keys = _cpdm_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_trial_instr_resp.rt = _cpdm_trial_instr_resp_allKeys[-1].rt
                    cpdm_trial_instr_resp.duration = _cpdm_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_trial_instr" ---
        for thisComponent in cpdm_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_trial_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        condition_runs2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_run_type.xlsx'),
            seed=None, name='condition_runs2')
        thisExp.addLoop(condition_runs2)  # add the loop to the experiment
        thisCondition_runs2 = condition_runs2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs2.rgb)
        if thisCondition_runs2 != None:
            for paramName in thisCondition_runs2:
                globals()[paramName] = thisCondition_runs2[paramName]
        
        for thisCondition_runs2 in condition_runs2:
            currentLoop = condition_runs2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs2.rgb)
            if thisCondition_runs2 != None:
                for paramName in thisCondition_runs2:
                    globals()[paramName] = thisCondition_runs2[paramName]
            
            # --- Prepare to start Routine "cpdm_run_setter" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_setter.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_setter_code
            #Block QC check variables
            run_resps = []
            cpdm_catch_trials = []
            
            #selects contrast schedule depending on run type
            #low volatility
            run_schedule = "cpdm/cpdm-1contrast.xlsx" 
            
            #flexible response text for high confidence options depending on run type
            if "low_risk" in cpdm_run_dimension:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $9 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $9 or $0"
            else:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $13 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $13 or $0"
            
            #create list of 200 random ITIs
            #iterate through list of ITIs, multiple by number of floats, divide by sum of original list
            #creates random list of ITI value for each trial which sum to 200
            cpdm_iti_list = [random.random() for i in range(200)] 
            cpdm_s = sum(cpdm_iti_list) 
            cpdm_iti_list = [i*200/cpdm_s for i in cpdm_iti_list]
            # keep track of which components have finished
            cpdm_run_setterComponents = []
            for thisComponent in cpdm_run_setterComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_setter" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_setterComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_setter" ---
            for thisComponent in cpdm_run_setterComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_setter.stopped', globalClock.getTime())
            # the Routine "cpdm_run_setter" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_loop_instr" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_loop_instr.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_loop_instr_code
            if "low_risk" in cpdm_run_dimension:
                corr_high_txt = "Correct \n High Confidence \n $9"
            else:
                corr_high_txt = "Correct \n High Confidence \n $13"
            cpdm_loop_instr_code2.setText("Block " + str(run_counter))
            cpdm_loop_instr_corr_high_txt.setText(corr_high_txt)
            cpdm_loop_instr_resp.keys = []
            cpdm_loop_instr_resp.rt = []
            _cpdm_loop_instr_resp_allKeys = []
            # keep track of which components have finished
            cpdm_loop_instrComponents = [cpdm_loop_instr_code2, cpdm_loop_instr_corr_high_poly, cpdm_loop_instr_right_high_poly, cpdm_loop_instr_left_low_poly, cpdm_loop_instr_right_low_poly, cpdm_loop_instr_corr_high_txt, cpdm_loop_instr_incorr_high_txt, cpdm_loop_instr_corr_low_txt, cpdm_loop_instr_incorr_low, cpdm_loop_instr_space_txt, cpdm_loop_instr_resp]
            for thisComponent in cpdm_loop_instrComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_loop_instr" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_loop_instr_code2* updates
                
                # if cpdm_loop_instr_code2 is starting this frame...
                if cpdm_loop_instr_code2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_code2.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_code2.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_code2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_code2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_code2.status = STARTED
                    cpdm_loop_instr_code2.setAutoDraw(True)
                
                # if cpdm_loop_instr_code2 is active this frame...
                if cpdm_loop_instr_code2.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_poly* updates
                
                # if cpdm_loop_instr_corr_high_poly is starting this frame...
                if cpdm_loop_instr_corr_high_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_poly.status = STARTED
                    cpdm_loop_instr_corr_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_poly is active this frame...
                if cpdm_loop_instr_corr_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_high_poly* updates
                
                # if cpdm_loop_instr_right_high_poly is starting this frame...
                if cpdm_loop_instr_right_high_poly.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_high_poly.status = STARTED
                    cpdm_loop_instr_right_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_high_poly is active this frame...
                if cpdm_loop_instr_right_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_left_low_poly* updates
                
                # if cpdm_loop_instr_left_low_poly is starting this frame...
                if cpdm_loop_instr_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_left_low_poly.status = STARTED
                    cpdm_loop_instr_left_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_left_low_poly is active this frame...
                if cpdm_loop_instr_left_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_low_poly* updates
                
                # if cpdm_loop_instr_right_low_poly is starting this frame...
                if cpdm_loop_instr_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_low_poly.status = STARTED
                    cpdm_loop_instr_right_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_low_poly is active this frame...
                if cpdm_loop_instr_right_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_txt* updates
                
                # if cpdm_loop_instr_corr_high_txt is starting this frame...
                if cpdm_loop_instr_corr_high_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_txt.status = STARTED
                    cpdm_loop_instr_corr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_txt is active this frame...
                if cpdm_loop_instr_corr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_high_txt* updates
                
                # if cpdm_loop_instr_incorr_high_txt is starting this frame...
                if cpdm_loop_instr_incorr_high_txt.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_high_txt.status = STARTED
                    cpdm_loop_instr_incorr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_high_txt is active this frame...
                if cpdm_loop_instr_incorr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_low_txt* updates
                
                # if cpdm_loop_instr_corr_low_txt is starting this frame...
                if cpdm_loop_instr_corr_low_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_low_txt.status = STARTED
                    cpdm_loop_instr_corr_low_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_low_txt is active this frame...
                if cpdm_loop_instr_corr_low_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_low* updates
                
                # if cpdm_loop_instr_incorr_low is starting this frame...
                if cpdm_loop_instr_incorr_low.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_low.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_low.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_low.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_low, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_low.status = STARTED
                    cpdm_loop_instr_incorr_low.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_low is active this frame...
                if cpdm_loop_instr_incorr_low.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_space_txt* updates
                
                # if cpdm_loop_instr_space_txt is starting this frame...
                if cpdm_loop_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_space_txt.status = STARTED
                    cpdm_loop_instr_space_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_space_txt is active this frame...
                if cpdm_loop_instr_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_resp* updates
                waitOnFlip = False
                
                # if cpdm_loop_instr_resp is starting this frame...
                if cpdm_loop_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_resp.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_loop_instr_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_loop_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_loop_instr_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_loop_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_loop_instr_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_loop_instr_resp_allKeys):
                        cpdm_loop_instr_resp.keys = _cpdm_loop_instr_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_loop_instr_resp.rt = _cpdm_loop_instr_resp_allKeys[-1].rt
                        cpdm_loop_instr_resp.duration = _cpdm_loop_instr_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_loop_instrComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_loop_instr" ---
            for thisComponent in cpdm_loop_instrComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_loop_instr.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_loop_instr_code
            run_counter += 1
            # the Routine "cpdm_loop_instr" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_init_fix" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
            # keep track of which components have finished
            cpdm_init_fixComponents = [cpdm_init_fix_poly]
            for thisComponent in cpdm_init_fixComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_init_fix" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_init_fix_poly* updates
                
                # if cpdm_init_fix_poly is starting this frame...
                if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                    cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_init_fix_poly.status = STARTED
                    cpdm_init_fix_poly.setAutoDraw(True)
                
                # if cpdm_init_fix_poly is active this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_init_fix_poly is stopping this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                        cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_init_fix_poly.status = FINISHED
                        cpdm_init_fix_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_init_fixComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_init_fix" ---
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # set up handler to look after randomisation of conditions etc
            cpdm_trials2 = data.TrialHandler(nReps=1.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=data.importConditions('cpdm/cpdm-1contrast.xlsx'),
                seed=None, name='cpdm_trials2')
            thisExp.addLoop(cpdm_trials2)  # add the loop to the experiment
            thisCpdm_trials2 = cpdm_trials2.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials2.rgb)
            if thisCpdm_trials2 != None:
                for paramName in thisCpdm_trials2:
                    globals()[paramName] = thisCpdm_trials2[paramName]
            
            for thisCpdm_trials2 in cpdm_trials2:
                currentLoop = cpdm_trials2
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials2.rgb)
                if thisCpdm_trials2 != None:
                    for paramName in thisCpdm_trials2:
                        globals()[paramName] = thisCpdm_trials2[paramName]
                
                # --- Prepare to start Routine "cpdm_trial" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trial.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trial_code
                my_loop = eval(cpdm_loop_name)
                cpdm_stop_timer = None
                cpdm_stopped_time = 0
                cpdm_trial_acc = 0
                cpdm_trial_conf = 0 
                
                #set default gray for all four response boxes
                left_high_color = [0,0,0] 
                left_low_color = [0,0,0]
                right_high_color = [0,0,0]
                right_low_color = [0,0,0]
                
                is_clockwise = False
                if cpdm_gabor_orient > 0.0: 
                    is_clockwise = True
                elif cpdm_gabor_orient == 0.0: 
                    cpdm_rand_num = random.randint(1,2)
                    if cpdm_rand_num == 1:
                        is_clockwise = True
                    else:
                        is_clockwise = False
                cpdm_trial_gabor.setContrast(cpdm_gabor_contrast)
                cpdm_trial_gabor.setOri(cpdm_gabor_orient)
                cpdm_trial_left_high_txt.setText(left_resp_txt)
                cpdm_trial_right_high_txt.setText(right_resp_txt)
                cpdm_trial_resp.keys = []
                cpdm_trial_resp.rt = []
                _cpdm_trial_resp_allKeys = []
                # keep track of which components have finished
                cpdm_trialComponents = [cpdm_trial_gabor, cpdm_trial_left_high_poly, cpdm_trial_right_high_poly, cpdm_trial_left_low_poly, cpdm_trial_right_low_poly, cpdm_trial_left_high_txt, cpdm_trial_right_high_txt, cpdm_trial_left_low_txt, cpdm_trial_right_low_txt, cpdm_trial_resp]
                for thisComponent in cpdm_trialComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trial" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 2.3:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    # Run 'Each Frame' code from cpdm_trial_code
                    #checks if resp is received for each trial and which key was pressed
                    #depending on which key is pressed, respective box color changes and
                    #correct_resp variable is updated if correct (preassigned to 0)
                    key = cpdm_trial_resp.keys
                    if len(key) == 1:
                        if stop_timer == None:
                            stop_timer = core.Clock() 
                        else:
                            stopped_time = stop_timer.getTime()
                            if stopped_time >= 0.5:
                                continueRoutine = False
                        #Left - High Confidence
                        if key == "q":
                            trial_conf = 1
                            #correct left resp
                            if is_clockwise == False: 
                                #indicates selection without performance feedback
                                left_high_color = "darkgray" 
                                #indicate correct resp for current trial
                                trial_acc = 1 
                            #incorrect left resp
                            else: 
                                left_high_color = "darkgray"
                        #Left - Low Confidence
                        elif key == "a":
                            #correct left resp
                            if is_clockwise == False: 
                                left_low_color = "darkgray"
                                trial_acc = 1
                            else:
                                left_low_color = "darkgray"
                        #Right - High Confidence
                        elif key == "p":
                            trial_conf = 1
                            #correct right resp
                            if is_clockwise == True: 
                                right_high_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_high_color = "darkgray"
                        #Right - Low Confidence
                        elif key == "l": 
                            #correct right resp
                            if is_clockwise == True: 
                                right_low_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_low_color = "darkgray"
                    
                    # *cpdm_trial_gabor* updates
                    
                    # if cpdm_trial_gabor is starting this frame...
                    if cpdm_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_gabor.frameNStart = frameN  # exact frame index
                        cpdm_trial_gabor.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.started')
                        # update status
                        cpdm_trial_gabor.status = STARTED
                        cpdm_trial_gabor.setAutoDraw(True)
                    
                    # if cpdm_trial_gabor is active this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_gabor is stopping this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_gabor.tStop = t  # not accounting for scr refresh
                            cpdm_trial_gabor.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.stopped')
                            # update status
                            cpdm_trial_gabor.status = FINISHED
                            cpdm_trial_gabor.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_poly* updates
                    
                    # if cpdm_trial_left_high_poly is starting this frame...
                    if cpdm_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_poly.status = STARTED
                        cpdm_trial_left_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_poly is active this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_high_poly.setFillColor(left_high_color, log=False)
                    
                    # if cpdm_trial_left_high_poly is stopping this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_poly.status = FINISHED
                            cpdm_trial_left_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_poly* updates
                    
                    # if cpdm_trial_right_high_poly is starting this frame...
                    if cpdm_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_poly.status = STARTED
                        cpdm_trial_right_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_poly is active this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_high_poly.setFillColor(right_high_color, log=False)
                    
                    # if cpdm_trial_right_high_poly is stopping this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_poly.status = FINISHED
                            cpdm_trial_right_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_poly* updates
                    
                    # if cpdm_trial_left_low_poly is starting this frame...
                    if cpdm_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_poly.status = STARTED
                        cpdm_trial_left_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_poly is active this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_low_poly.setFillColor(left_low_color, log=False)
                    
                    # if cpdm_trial_left_low_poly is stopping this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_poly.status = FINISHED
                            cpdm_trial_left_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_poly* updates
                    
                    # if cpdm_trial_right_low_poly is starting this frame...
                    if cpdm_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_poly.status = STARTED
                        cpdm_trial_right_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_poly is active this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_low_poly.setFillColor(right_low_color, log=False)
                    
                    # if cpdm_trial_right_low_poly is stopping this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_poly.status = FINISHED
                            cpdm_trial_right_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_txt* updates
                    
                    # if cpdm_trial_left_high_txt is starting this frame...
                    if cpdm_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_txt.status = STARTED
                        cpdm_trial_left_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_txt is active this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_high_txt is stopping this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_txt.status = FINISHED
                            cpdm_trial_left_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_txt* updates
                    
                    # if cpdm_trial_right_high_txt is starting this frame...
                    if cpdm_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_txt.status = STARTED
                        cpdm_trial_right_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_txt is active this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_high_txt is stopping this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_txt.status = FINISHED
                            cpdm_trial_right_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_txt* updates
                    
                    # if cpdm_trial_left_low_txt is starting this frame...
                    if cpdm_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_txt.status = STARTED
                        cpdm_trial_left_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_txt is active this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_low_txt is stopping this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_txt.status = FINISHED
                            cpdm_trial_left_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_txt* updates
                    
                    # if cpdm_trial_right_low_txt is starting this frame...
                    if cpdm_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_txt.status = STARTED
                        cpdm_trial_right_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_txt is active this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_low_txt is stopping this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_txt.status = FINISHED
                            cpdm_trial_right_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_resp* updates
                    waitOnFlip = False
                    
                    # if cpdm_trial_resp is starting this frame...
                    if cpdm_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_resp.frameNStart = frameN  # exact frame index
                        cpdm_trial_resp.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_resp, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(cpdm_trial_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(cpdm_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    
                    # if cpdm_trial_resp is stopping this frame...
                    if cpdm_trial_resp.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_resp.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_resp.tStop = t  # not accounting for scr refresh
                            cpdm_trial_resp.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_resp.status = FINISHED
                            cpdm_trial_resp.status = FINISHED
                    if cpdm_trial_resp.status == STARTED and not waitOnFlip:
                        theseKeys = cpdm_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                        _cpdm_trial_resp_allKeys.extend(theseKeys)
                        if len(_cpdm_trial_resp_allKeys):
                            cpdm_trial_resp.keys = _cpdm_trial_resp_allKeys[0].name  # just the first key pressed
                            cpdm_trial_resp.rt = _cpdm_trial_resp_allKeys[0].rt
                            cpdm_trial_resp.duration = _cpdm_trial_resp_allKeys[0].duration
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trialComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trial" ---
                for thisComponent in cpdm_trialComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trial.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trial_code
                #binary accuracy & confidence
                my_loop.addData("cpdm_acc", trial_acc)
                my_loop.addData("cpdm_conf", trial_conf)
                my_loop.addData("cpdm_trial_type", "task")
                key = cpdm_trial_resp.keys
                if key in ["q", "a", "p", "l"]:
                    run_resps.append(key)
                
                if type(cpdm_trial_resp.rt) is list or cpdm_trial_resp.rt >= 2 - 0.5:
                    delta_time = 0
                else:
                    delta_time = max(0, 2 - (cpdm_trial_resp.rt + stopped_time))
                
                #low risk possible payouts
                if "low_risk" in cpdm_run_dimension: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0: 
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False: 
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #LEFT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                #high risk possible payouts
                else: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #Left - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                # check responses
                if cpdm_trial_resp.keys in ['', [], None]:  # No response was made
                    cpdm_trial_resp.keys = None
                cpdm_trials2.addData('cpdm_trial_resp.keys',cpdm_trial_resp.keys)
                if cpdm_trial_resp.keys != None:  # we had a response
                    cpdm_trials2.addData('cpdm_trial_resp.rt', cpdm_trial_resp.rt)
                    cpdm_trials2.addData('cpdm_trial_resp.duration', cpdm_trial_resp.duration)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-2.300000)
                
                # --- Prepare to start Routine "cpdm_trials_iti2" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trials_iti2.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trials_iti2_code
                #variable ITI for non-practice trials
                iti_time = iti_list[my_loop.thisIndex] + delta_time
                #200 CPDM trials per run
                if cpdm_trials2.thisTrialN == 199:
                    continueRoutine = False
                # keep track of which components have finished
                cpdm_trials_iti2Components = [cpdm_trials_iti2_poly]
                for thisComponent in cpdm_trials_iti2Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trials_iti2" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *cpdm_trials_iti2_poly* updates
                    
                    # if cpdm_trials_iti2_poly is starting this frame...
                    if cpdm_trials_iti2_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trials_iti2_poly.frameNStart = frameN  # exact frame index
                        cpdm_trials_iti2_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trials_iti2_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trials_iti2_poly, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trials_iti2_poly.started')
                        # update status
                        cpdm_trials_iti2_poly.status = STARTED
                        cpdm_trials_iti2_poly.setAutoDraw(True)
                    
                    # if cpdm_trials_iti2_poly is active this frame...
                    if cpdm_trials_iti2_poly.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trials_iti2_poly is stopping this frame...
                    if cpdm_trials_iti2_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trials_iti2_poly.tStartRefresh + cpdm_iti_time-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trials_iti2_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trials_iti2_poly.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trials_iti2_poly.stopped')
                            # update status
                            cpdm_trials_iti2_poly.status = FINISHED
                            cpdm_trials_iti2_poly.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trials_iti2Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trials_iti2" ---
                for thisComponent in cpdm_trials_iti2Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trials_iti2.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trials_iti2_code
                #record delta time
                my_loop.addData("cpdm_delta_time", delta_time) 
                #record iti time
                my_loop.addData("cpdm_iti_time", iti_time) 
                # the Routine "cpdm_trials_iti2" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 1.0 repeats of 'cpdm_trials2'
            
            
            # --- Prepare to start Routine "cpdm_run_break2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_break2.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_break2_code
            cpdm_unique_resps = []
            cpdm_unique_count = 0
            for i in run_resps:
                if i not in cpdm_unique_resps:
                    cpdm_unique_count += 1
                    cpdm_unique_resps.append(i)
            
            cpdm_run_break_text = ""
            cpdm_space_text = ""
            #filter for nonresponses
            if len(run_resps) < 190: #95% = 190 trials per block
                cpdm_run_break_text = "You failed to respond to " + str(200-len(run_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject1", "< 95% resp rate")
                my_loop.addData("cpdm_subReject1_nonresps", 200-len(run_resps))
            #filter for single-button responses
            elif cpdm_unique_count < 2: #same for each exp
                cpdm_run_break_text = "You provided the same response to all " + str(len(run_resps)) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject2", "1key response")
                my_loop.addData("cpdm_subReject2_key", run_resps[0])
            #filter for poor performance on CPDM catch trials for low volatility blocks (14/20 catch trial criterion -- 5.77% of random success on 14/20 trials)
            elif "low_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 14:
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject3LV", "LV catch fail")
                my_loop.addData("cpdm_subReject3LV_fails", 20-sum(cpdm_catch_trials))
            #filter for poor performance on CPDM catch trials for high volatility blocks (6/8 catch trial criterion -- 14.45% of random success on 7/8 trials)
            #elif "high_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 6:
            #    cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            #    cpdm_space_text = "Press SPACE to end."
            #    exp_proceed = False
            #    my_loop.addData("subReject3HV", "HV catch fail")
            #    my_loop.addData("subReject3HV_fails", 8-sum(cpdm_catch_trials))
            #all CPDM criterion are met -- good data
            else:
                #final run
                if condition_runs2.thisN == 1: 
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!"
                    cpdm_space_text = "Press SPACE to continue."
                #first three runs
                else: 
                    cpdm_run_break_text = "Please feel free to take a short break. \n \n As you begin Block " + str(run_counter) + ", read the possible monetary values of each option carefully as they may have changed."
                    cpdm_space_text = "Press SPACE to continue."
            cpdm_run_break2_txt.setText(cpdm_run_break_text)
            cpdm_run_break2_txt.setHeight(0.05)
            cpdm_run_break2_space_txt.setText(cpdm_space_text)
            cpdm_run_break2_resp.keys = []
            cpdm_run_break2_resp.rt = []
            _cpdm_run_break2_resp_allKeys = []
            # keep track of which components have finished
            cpdm_run_break2Components = [cpdm_run_break2_title_txt, cpdm_run_break2_txt, cpdm_run_break2_space_txt, cpdm_run_break2_resp]
            for thisComponent in cpdm_run_break2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_break2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_run_break2_title_txt* updates
                
                # if cpdm_run_break2_title_txt is starting this frame...
                if cpdm_run_break2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break2_title_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break2_title_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break2_title_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break2_title_txt.status = STARTED
                    cpdm_run_break2_title_txt.setAutoDraw(True)
                
                # if cpdm_run_break2_title_txt is active this frame...
                if cpdm_run_break2_title_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break2_txt* updates
                
                # if cpdm_run_break2_txt is starting this frame...
                if cpdm_run_break2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break2_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break2_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break2_txt.status = STARTED
                    cpdm_run_break2_txt.setAutoDraw(True)
                
                # if cpdm_run_break2_txt is active this frame...
                if cpdm_run_break2_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break2_space_txt* updates
                
                # if cpdm_run_break2_space_txt is starting this frame...
                if cpdm_run_break2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break2_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break2_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break2_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break2_space_txt.status = STARTED
                    cpdm_run_break2_space_txt.setAutoDraw(True)
                
                # if cpdm_run_break2_space_txt is active this frame...
                if cpdm_run_break2_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break2_resp* updates
                waitOnFlip = False
                
                # if cpdm_run_break2_resp is starting this frame...
                if cpdm_run_break2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break2_resp.frameNStart = frameN  # exact frame index
                    cpdm_run_break2_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break2_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break2_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_run_break2_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_run_break2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_run_break2_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_run_break2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_run_break2_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_run_break2_resp_allKeys):
                        cpdm_run_break2_resp.keys = _cpdm_run_break2_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_run_break2_resp.rt = _cpdm_run_break2_resp_allKeys[-1].rt
                        cpdm_run_break2_resp.duration = _cpdm_run_break2_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_break2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_break2" ---
            for thisComponent in cpdm_run_break2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_break2.stopped', globalClock.getTime())
            # the Routine "cpdm_run_break2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "idm_term_check" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('idm_term_check.started', globalClock.getTime())
            # Run 'Begin Routine' code from idm_term_check_code
            if exp_proceed == False:
                core.quit()
            # keep track of which components have finished
            idm_term_checkComponents = []
            for thisComponent in idm_term_checkComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "idm_term_check" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in idm_term_checkComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "idm_term_check" ---
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('idm_term_check.stopped', globalClock.getTime())
            # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'condition_runs2'
        
    # completed loop4 repeats of 'should_run4'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run5 = data.TrialHandler(nReps=loop5, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run5')
    thisExp.addLoop(should_run5)  # add the loop to the experiment
    thisShould_run5 = should_run5.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run5.rgb)
    if thisShould_run5 != None:
        for paramName in thisShould_run5:
            globals()[paramName] = thisShould_run5[paramName]
    
    for thisShould_run5 in should_run5:
        currentLoop = should_run5
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run5.rgb)
        if thisShould_run5 != None:
            for paramName in thisShould_run5:
                globals()[paramName] = thisShould_run5[paramName]
        
        # --- Prepare to start Routine "crdm_namer2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_namer2.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_namer_code2
        #provides specific loop names for each of two interations of CRDM
        #to provide flexibility of crdm_pract_trial and crdm_trial routines
        practice_loop1_name = "crdm_pract1_trials2"
        questplus_loop_name = "crdm_qp_trials2"
        practice_loop2_name = "crdm_pract2_trials2"
        loop_name = "crdm_trials2"
        # keep track of which components have finished
        crdm_namer2Components = []
        for thisComponent in crdm_namer2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_namer2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_namer2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_namer2" ---
        for thisComponent in crdm_namer2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_namer2.stopped', globalClock.getTime())
        # the Routine "crdm_namer2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr1.started', globalClock.getTime())
        crdm_instr1_resp.keys = []
        crdm_instr1_resp.rt = []
        _crdm_instr1_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr1Components = [crdm_instr1_title_txt, crdm_instr1_txt, crdm_instr1_space_txt, crdm_instr1_resp]
        for thisComponent in crdm_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr1_title_txt* updates
            
            # if crdm_instr1_title_txt is starting this frame...
            if crdm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_title_txt.status = STARTED
                crdm_instr1_title_txt.setAutoDraw(True)
            
            # if crdm_instr1_title_txt is active this frame...
            if crdm_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_txt* updates
            
            # if crdm_instr1_txt is starting this frame...
            if crdm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_txt.status = STARTED
                crdm_instr1_txt.setAutoDraw(True)
            
            # if crdm_instr1_txt is active this frame...
            if crdm_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_space_txt* updates
            
            # if crdm_instr1_space_txt is starting this frame...
            if crdm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_space_txt.status = STARTED
                crdm_instr1_space_txt.setAutoDraw(True)
            
            # if crdm_instr1_space_txt is active this frame...
            if crdm_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr1_resp* updates
            waitOnFlip = False
            
            # if crdm_instr1_resp is starting this frame...
            if crdm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr1_resp.frameNStart = frameN  # exact frame index
                crdm_instr1_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr1_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr1_resp_allKeys):
                    crdm_instr1_resp.keys = _crdm_instr1_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr1_resp.rt = _crdm_instr1_resp_allKeys[-1].rt
                    crdm_instr1_resp.duration = _crdm_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr1" ---
        for thisComponent in crdm_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr1.stopped', globalClock.getTime())
        # the Routine "crdm_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr2.started', globalClock.getTime())
        crdm_instr2_resp.keys = []
        crdm_instr2_resp.rt = []
        _crdm_instr2_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr2Components = [crdm_instr2_lottname_txt, crdm_instr2_txt, crdm_instr2_img, crdm_instr2_lott0_txt, crdm_instr2_lott20_txt, crdm_instr2_space_txt, crdm_instr2_resp]
        for thisComponent in crdm_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr2_lottname_txt* updates
            
            # if crdm_instr2_lottname_txt is starting this frame...
            if crdm_instr2_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lottname_txt.status = STARTED
                crdm_instr2_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr2_lottname_txt is active this frame...
            if crdm_instr2_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_txt* updates
            
            # if crdm_instr2_txt is starting this frame...
            if crdm_instr2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_txt.status = STARTED
                crdm_instr2_txt.setAutoDraw(True)
            
            # if crdm_instr2_txt is active this frame...
            if crdm_instr2_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_img* updates
            
            # if crdm_instr2_img is starting this frame...
            if crdm_instr2_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_img.frameNStart = frameN  # exact frame index
                crdm_instr2_img.tStart = t  # local t and not account for scr refresh
                crdm_instr2_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_img.status = STARTED
                crdm_instr2_img.setAutoDraw(True)
            
            # if crdm_instr2_img is active this frame...
            if crdm_instr2_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_lott0_txt* updates
            
            # if crdm_instr2_lott0_txt is starting this frame...
            if crdm_instr2_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lott0_txt.status = STARTED
                crdm_instr2_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr2_lott0_txt is active this frame...
            if crdm_instr2_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_lott20_txt* updates
            
            # if crdm_instr2_lott20_txt is starting this frame...
            if crdm_instr2_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_lott20_txt.status = STARTED
                crdm_instr2_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr2_lott20_txt is active this frame...
            if crdm_instr2_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_space_txt* updates
            
            # if crdm_instr2_space_txt is starting this frame...
            if crdm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_space_txt.status = STARTED
                crdm_instr2_space_txt.setAutoDraw(True)
            
            # if crdm_instr2_space_txt is active this frame...
            if crdm_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr2_resp* updates
            waitOnFlip = False
            
            # if crdm_instr2_resp is starting this frame...
            if crdm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr2_resp.frameNStart = frameN  # exact frame index
                crdm_instr2_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr2_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr2_resp_allKeys):
                    crdm_instr2_resp.keys = _crdm_instr2_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr2_resp.rt = _crdm_instr2_resp_allKeys[-1].rt
                    crdm_instr2_resp.duration = _crdm_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr2" ---
        for thisComponent in crdm_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr2.stopped', globalClock.getTime())
        # the Routine "crdm_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr3.started', globalClock.getTime())
        crdm_instr3_resp.keys = []
        crdm_instr3_resp.rt = []
        _crdm_instr3_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr3Components = [crdm_instr3_lottname_txt, crdm_instr3_txt, crdm_instr3_img, crdm_instr3_lott0_txt, crdm_instr3_lott20_txt, crdm_instr3_space_txt, crdm_instr3_resp]
        for thisComponent in crdm_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr3_lottname_txt* updates
            
            # if crdm_instr3_lottname_txt is starting this frame...
            if crdm_instr3_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lottname_txt.status = STARTED
                crdm_instr3_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr3_lottname_txt is active this frame...
            if crdm_instr3_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_txt* updates
            
            # if crdm_instr3_txt is starting this frame...
            if crdm_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_txt.status = STARTED
                crdm_instr3_txt.setAutoDraw(True)
            
            # if crdm_instr3_txt is active this frame...
            if crdm_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_img* updates
            
            # if crdm_instr3_img is starting this frame...
            if crdm_instr3_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_img.frameNStart = frameN  # exact frame index
                crdm_instr3_img.tStart = t  # local t and not account for scr refresh
                crdm_instr3_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_img.status = STARTED
                crdm_instr3_img.setAutoDraw(True)
            
            # if crdm_instr3_img is active this frame...
            if crdm_instr3_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_lott0_txt* updates
            
            # if crdm_instr3_lott0_txt is starting this frame...
            if crdm_instr3_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lott0_txt.status = STARTED
                crdm_instr3_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr3_lott0_txt is active this frame...
            if crdm_instr3_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_lott20_txt* updates
            
            # if crdm_instr3_lott20_txt is starting this frame...
            if crdm_instr3_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_lott20_txt.status = STARTED
                crdm_instr3_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr3_lott20_txt is active this frame...
            if crdm_instr3_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_space_txt* updates
            
            # if crdm_instr3_space_txt is starting this frame...
            if crdm_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_space_txt.status = STARTED
                crdm_instr3_space_txt.setAutoDraw(True)
            
            # if crdm_instr3_space_txt is active this frame...
            if crdm_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr3_resp* updates
            waitOnFlip = False
            
            # if crdm_instr3_resp is starting this frame...
            if crdm_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr3_resp.frameNStart = frameN  # exact frame index
                crdm_instr3_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr3_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr3_resp_allKeys):
                    crdm_instr3_resp.keys = _crdm_instr3_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr3_resp.rt = _crdm_instr3_resp_allKeys[-1].rt
                    crdm_instr3_resp.duration = _crdm_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr3" ---
        for thisComponent in crdm_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr3.stopped', globalClock.getTime())
        # the Routine "crdm_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr4.started', globalClock.getTime())
        crdm_instr4_resp.keys = []
        crdm_instr4_resp.rt = []
        _crdm_instr4_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr4Components = [crdm_instr4_lottname_txt, crdm_instr4_txt, crdm_instr4_img, crdm_instr4_lott0_txt, crdm_instr4_lott20_txt, crdm_instr4_space_txt, crdm_instr4_resp]
        for thisComponent in crdm_instr4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr4_lottname_txt* updates
            
            # if crdm_instr4_lottname_txt is starting this frame...
            if crdm_instr4_lottname_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lottname_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lottname_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lottname_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lottname_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lottname_txt.status = STARTED
                crdm_instr4_lottname_txt.setAutoDraw(True)
            
            # if crdm_instr4_lottname_txt is active this frame...
            if crdm_instr4_lottname_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_txt* updates
            
            # if crdm_instr4_txt is starting this frame...
            if crdm_instr4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_txt.status = STARTED
                crdm_instr4_txt.setAutoDraw(True)
            
            # if crdm_instr4_txt is active this frame...
            if crdm_instr4_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_img* updates
            
            # if crdm_instr4_img is starting this frame...
            if crdm_instr4_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_img.frameNStart = frameN  # exact frame index
                crdm_instr4_img.tStart = t  # local t and not account for scr refresh
                crdm_instr4_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_img.status = STARTED
                crdm_instr4_img.setAutoDraw(True)
            
            # if crdm_instr4_img is active this frame...
            if crdm_instr4_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_lott0_txt* updates
            
            # if crdm_instr4_lott0_txt is starting this frame...
            if crdm_instr4_lott0_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lott0_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lott0_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lott0_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lott0_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lott0_txt.status = STARTED
                crdm_instr4_lott0_txt.setAutoDraw(True)
            
            # if crdm_instr4_lott0_txt is active this frame...
            if crdm_instr4_lott0_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_lott20_txt* updates
            
            # if crdm_instr4_lott20_txt is starting this frame...
            if crdm_instr4_lott20_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_lott20_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_lott20_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_lott20_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_lott20_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_lott20_txt.status = STARTED
                crdm_instr4_lott20_txt.setAutoDraw(True)
            
            # if crdm_instr4_lott20_txt is active this frame...
            if crdm_instr4_lott20_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_space_txt* updates
            
            # if crdm_instr4_space_txt is starting this frame...
            if crdm_instr4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr4_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_space_txt.status = STARTED
                crdm_instr4_space_txt.setAutoDraw(True)
            
            # if crdm_instr4_space_txt is active this frame...
            if crdm_instr4_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr4_resp* updates
            waitOnFlip = False
            
            # if crdm_instr4_resp is starting this frame...
            if crdm_instr4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr4_resp.frameNStart = frameN  # exact frame index
                crdm_instr4_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr4_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr4_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr4_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr4_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr4_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr4_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr4_resp_allKeys):
                    crdm_instr4_resp.keys = _crdm_instr4_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr4_resp.rt = _crdm_instr4_resp_allKeys[-1].rt
                    crdm_instr4_resp.duration = _crdm_instr4_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr4" ---
        for thisComponent in crdm_instr4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr4.stopped', globalClock.getTime())
        # the Routine "crdm_instr4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr5" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr5.started', globalClock.getTime())
        crdm_instr5_resp.keys = []
        crdm_instr5_resp.rt = []
        _crdm_instr5_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr5Components = [crdm_instr5_txt, crdm_instr5_img, crdm_instr5_lott_top_txt, crdm_instr5_lott_bot_txt, crdm_instr5_sure_txt, crdm_instr5_space_txt, crdm_instr5_resp]
        for thisComponent in crdm_instr5Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr5" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr5_txt* updates
            
            # if crdm_instr5_txt is starting this frame...
            if crdm_instr5_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_txt.status = STARTED
                crdm_instr5_txt.setAutoDraw(True)
            
            # if crdm_instr5_txt is active this frame...
            if crdm_instr5_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_img* updates
            
            # if crdm_instr5_img is starting this frame...
            if crdm_instr5_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_img.frameNStart = frameN  # exact frame index
                crdm_instr5_img.tStart = t  # local t and not account for scr refresh
                crdm_instr5_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_img.status = STARTED
                crdm_instr5_img.setAutoDraw(True)
            
            # if crdm_instr5_img is active this frame...
            if crdm_instr5_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_lott_top_txt* updates
            
            # if crdm_instr5_lott_top_txt is starting this frame...
            if crdm_instr5_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_lott_top_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_lott_top_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_lott_top_txt.status = STARTED
                crdm_instr5_lott_top_txt.setAutoDraw(True)
            
            # if crdm_instr5_lott_top_txt is active this frame...
            if crdm_instr5_lott_top_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_lott_bot_txt* updates
            
            # if crdm_instr5_lott_bot_txt is starting this frame...
            if crdm_instr5_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_lott_bot_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_lott_bot_txt.status = STARTED
                crdm_instr5_lott_bot_txt.setAutoDraw(True)
            
            # if crdm_instr5_lott_bot_txt is active this frame...
            if crdm_instr5_lott_bot_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_sure_txt* updates
            
            # if crdm_instr5_sure_txt is starting this frame...
            if crdm_instr5_sure_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_sure_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_sure_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_sure_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_sure_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_sure_txt.status = STARTED
                crdm_instr5_sure_txt.setAutoDraw(True)
            
            # if crdm_instr5_sure_txt is active this frame...
            if crdm_instr5_sure_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_space_txt* updates
            
            # if crdm_instr5_space_txt is starting this frame...
            if crdm_instr5_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr5_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr5_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_space_txt.status = STARTED
                crdm_instr5_space_txt.setAutoDraw(True)
            
            # if crdm_instr5_space_txt is active this frame...
            if crdm_instr5_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr5_resp* updates
            waitOnFlip = False
            
            # if crdm_instr5_resp is starting this frame...
            if crdm_instr5_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr5_resp.frameNStart = frameN  # exact frame index
                crdm_instr5_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr5_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr5_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr5_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr5_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr5_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr5_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr5_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr5_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr5_resp_allKeys):
                    crdm_instr5_resp.keys = _crdm_instr5_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr5_resp.rt = _crdm_instr5_resp_allKeys[-1].rt
                    crdm_instr5_resp.duration = _crdm_instr5_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr5Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr5" ---
        for thisComponent in crdm_instr5Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr5.stopped', globalClock.getTime())
        # the Routine "crdm_instr5" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr6" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr6.started', globalClock.getTime())
        crdm_instr6_resp.keys = []
        crdm_instr6_resp.rt = []
        _crdm_instr6_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr6Components = [crdm_instr6_title_txt, crdm_instr6_txt, crdm_instr6_img, crdm_instr6_space_txt, crdm_instr6_resp]
        for thisComponent in crdm_instr6Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr6" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr6_title_txt* updates
            
            # if crdm_instr6_title_txt is starting this frame...
            if crdm_instr6_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_title_txt.status = STARTED
                crdm_instr6_title_txt.setAutoDraw(True)
            
            # if crdm_instr6_title_txt is active this frame...
            if crdm_instr6_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_txt* updates
            
            # if crdm_instr6_txt is starting this frame...
            if crdm_instr6_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_txt.status = STARTED
                crdm_instr6_txt.setAutoDraw(True)
            
            # if crdm_instr6_txt is active this frame...
            if crdm_instr6_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_img* updates
            
            # if crdm_instr6_img is starting this frame...
            if crdm_instr6_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_img.frameNStart = frameN  # exact frame index
                crdm_instr6_img.tStart = t  # local t and not account for scr refresh
                crdm_instr6_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_img.status = STARTED
                crdm_instr6_img.setAutoDraw(True)
            
            # if crdm_instr6_img is active this frame...
            if crdm_instr6_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_space_txt* updates
            
            # if crdm_instr6_space_txt is starting this frame...
            if crdm_instr6_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr6_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr6_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_space_txt.status = STARTED
                crdm_instr6_space_txt.setAutoDraw(True)
            
            # if crdm_instr6_space_txt is active this frame...
            if crdm_instr6_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr6_resp* updates
            waitOnFlip = False
            
            # if crdm_instr6_resp is starting this frame...
            if crdm_instr6_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr6_resp.frameNStart = frameN  # exact frame index
                crdm_instr6_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr6_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr6_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr6_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr6_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr6_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr6_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr6_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr6_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr6_resp_allKeys):
                    crdm_instr6_resp.keys = _crdm_instr6_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr6_resp.rt = _crdm_instr6_resp_allKeys[-1].rt
                    crdm_instr6_resp.duration = _crdm_instr6_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr6Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr6" ---
        for thisComponent in crdm_instr6Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr6.stopped', globalClock.getTime())
        # the Routine "crdm_instr6" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_instr7" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_instr7.started', globalClock.getTime())
        crdm_instr7_resp.keys = []
        crdm_instr7_resp.rt = []
        _crdm_instr7_resp_allKeys = []
        # keep track of which components have finished
        crdm_instr7Components = [crdm_instr7_title_txt, crdm_instr7_txt, crdm_instr7_img, crdm_instr7_space_txt, crdm_instr7_resp]
        for thisComponent in crdm_instr7Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_instr7" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_instr7_title_txt* updates
            
            # if crdm_instr7_title_txt is starting this frame...
            if crdm_instr7_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_title_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_title_txt.status = STARTED
                crdm_instr7_title_txt.setAutoDraw(True)
            
            # if crdm_instr7_title_txt is active this frame...
            if crdm_instr7_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_txt* updates
            
            # if crdm_instr7_txt is starting this frame...
            if crdm_instr7_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_txt.status = STARTED
                crdm_instr7_txt.setAutoDraw(True)
            
            # if crdm_instr7_txt is active this frame...
            if crdm_instr7_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_img* updates
            
            # if crdm_instr7_img is starting this frame...
            if crdm_instr7_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_img.frameNStart = frameN  # exact frame index
                crdm_instr7_img.tStart = t  # local t and not account for scr refresh
                crdm_instr7_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_img.status = STARTED
                crdm_instr7_img.setAutoDraw(True)
            
            # if crdm_instr7_img is active this frame...
            if crdm_instr7_img.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_space_txt* updates
            
            # if crdm_instr7_space_txt is starting this frame...
            if crdm_instr7_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_space_txt.frameNStart = frameN  # exact frame index
                crdm_instr7_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_instr7_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_space_txt.status = STARTED
                crdm_instr7_space_txt.setAutoDraw(True)
            
            # if crdm_instr7_space_txt is active this frame...
            if crdm_instr7_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_instr7_resp* updates
            waitOnFlip = False
            
            # if crdm_instr7_resp is starting this frame...
            if crdm_instr7_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_instr7_resp.frameNStart = frameN  # exact frame index
                crdm_instr7_resp.tStart = t  # local t and not account for scr refresh
                crdm_instr7_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_instr7_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_instr7_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_instr7_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_instr7_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_instr7_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_instr7_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_instr7_resp_allKeys.extend(theseKeys)
                if len(_crdm_instr7_resp_allKeys):
                    crdm_instr7_resp.keys = _crdm_instr7_resp_allKeys[-1].name  # just the last key pressed
                    crdm_instr7_resp.rt = _crdm_instr7_resp_allKeys[-1].rt
                    crdm_instr7_resp.duration = _crdm_instr7_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_instr7Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_instr7" ---
        for thisComponent in crdm_instr7Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_instr7.stopped', globalClock.getTime())
        # the Routine "crdm_instr7" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_warn.started', globalClock.getTime())
        crdm_warn1_resp.keys = []
        crdm_warn1_resp.rt = []
        _crdm_warn1_resp_allKeys = []
        # keep track of which components have finished
        crdm_warnComponents = [crdm_warn1_title_txt, crdm_warn1_txt, crdm_warn1_space_txt, crdm_warn1_resp]
        for thisComponent in crdm_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_warn1_title_txt* updates
            
            # if crdm_warn1_title_txt is starting this frame...
            if crdm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_title_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_title_txt.status = STARTED
                crdm_warn1_title_txt.setAutoDraw(True)
            
            # if crdm_warn1_title_txt is active this frame...
            if crdm_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_txt* updates
            
            # if crdm_warn1_txt is starting this frame...
            if crdm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_txt.status = STARTED
                crdm_warn1_txt.setAutoDraw(True)
            
            # if crdm_warn1_txt is active this frame...
            if crdm_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_space_txt* updates
            
            # if crdm_warn1_space_txt is starting this frame...
            if crdm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_space_txt.frameNStart = frameN  # exact frame index
                crdm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_space_txt.status = STARTED
                crdm_warn1_space_txt.setAutoDraw(True)
            
            # if crdm_warn1_space_txt is active this frame...
            if crdm_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_warn1_resp* updates
            waitOnFlip = False
            
            # if crdm_warn1_resp is starting this frame...
            if crdm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_warn1_resp.frameNStart = frameN  # exact frame index
                crdm_warn1_resp.tStart = t  # local t and not account for scr refresh
                crdm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_warn1_resp_allKeys.extend(theseKeys)
                if len(_crdm_warn1_resp_allKeys):
                    crdm_warn1_resp.keys = _crdm_warn1_resp_allKeys[-1].name  # just the last key pressed
                    crdm_warn1_resp.rt = _crdm_warn1_resp_allKeys[-1].rt
                    crdm_warn1_resp.duration = _crdm_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_warn" ---
        for thisComponent in crdm_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_warn.stopped', globalClock.getTime())
        # the Routine "crdm_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_pract1_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_pract1_instr.started', globalClock.getTime())
        crdm_pract1_instr_key.keys = []
        crdm_pract1_instr_key.rt = []
        _crdm_pract1_instr_key_allKeys = []
        # keep track of which components have finished
        crdm_pract1_instrComponents = [crdm_pract1_instr_name_txt, crdm_pract1_instr_txt, crdm_pract1_instr_space_txt, crdm_pract1_instr_key]
        for thisComponent in crdm_pract1_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_pract1_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_pract1_instr_name_txt* updates
            
            # if crdm_pract1_instr_name_txt is starting this frame...
            if crdm_pract1_instr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_name_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_name_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_name_txt.status = STARTED
                crdm_pract1_instr_name_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_name_txt is active this frame...
            if crdm_pract1_instr_name_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_txt* updates
            
            # if crdm_pract1_instr_txt is starting this frame...
            if crdm_pract1_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_txt.status = STARTED
                crdm_pract1_instr_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_txt is active this frame...
            if crdm_pract1_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_space_txt* updates
            
            # if crdm_pract1_instr_space_txt is starting this frame...
            if crdm_pract1_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_space_txt.status = STARTED
                crdm_pract1_instr_space_txt.setAutoDraw(True)
            
            # if crdm_pract1_instr_space_txt is active this frame...
            if crdm_pract1_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract1_instr_key* updates
            waitOnFlip = False
            
            # if crdm_pract1_instr_key is starting this frame...
            if crdm_pract1_instr_key.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract1_instr_key.frameNStart = frameN  # exact frame index
                crdm_pract1_instr_key.tStart = t  # local t and not account for scr refresh
                crdm_pract1_instr_key.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract1_instr_key, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract1_instr_key.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_pract1_instr_key.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_pract1_instr_key.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_pract1_instr_key.status == STARTED and not waitOnFlip:
                theseKeys = crdm_pract1_instr_key.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_pract1_instr_key_allKeys.extend(theseKeys)
                if len(_crdm_pract1_instr_key_allKeys):
                    crdm_pract1_instr_key.keys = _crdm_pract1_instr_key_allKeys[-1].name  # just the last key pressed
                    crdm_pract1_instr_key.rt = _crdm_pract1_instr_key_allKeys[-1].rt
                    crdm_pract1_instr_key.duration = _crdm_pract1_instr_key_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_pract1_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_pract1_instr" ---
        for thisComponent in crdm_pract1_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_pract1_instr.stopped', globalClock.getTime())
        # the Routine "crdm_pract1_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_pract1_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_practice1.csv'),
            seed=None, name='crdm_pract1_trials2')
        thisExp.addLoop(crdm_pract1_trials2)  # add the loop to the experiment
        thisCrdm_pract1_trials2 = crdm_pract1_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract1_trials2.rgb)
        if thisCrdm_pract1_trials2 != None:
            for paramName in thisCrdm_pract1_trials2:
                globals()[paramName] = thisCrdm_pract1_trials2[paramName]
        
        for thisCrdm_pract1_trials2 in crdm_pract1_trials2:
            currentLoop = crdm_pract1_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract1_trials2.rgb)
            if thisCrdm_pract1_trials2 != None:
                for paramName in thisCrdm_pract1_trials2:
                    globals()[paramName] = thisCrdm_pract1_trials2[paramName]
            
            # --- Prepare to start Routine "crdm_pract1_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract1_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract1_trial_code
            my_loop = eval(crdm_practice_loop1_name)
            
            #random index for certain outcome position and response
            crdm_idx1 = random.randint(0,1) 
            crdm_sure_pos1 = crdm_pos1[crdm_idx1] 
            crdm_sure_resp1 = crdm_resp1[crdm_idx1]
            crdm_pract1_trial_img.setImage("crdm/" + crdm_img1)
            crdm_pract1_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top1))))
            crdm_pract1_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot1))))
            crdm_pract1_trial_sure_amt_txt.setPos(crdm_sure_pos1)
            crdm_pract1_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt1)))
            )
            crdm_pract1_trial_resp.keys = []
            crdm_pract1_trial_resp.rt = []
            _crdm_pract1_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract1_trialComponents = [crdm_pract1_trial_img, crdm_pract1_trial_lott_top_txt, crdm_pract1_trial_lott_bot_txt, crdm_pract1_trial_sure_amt_txt, GRFX_fix4, crdm_pract1_trial_cue, crdm_pract1_trial_resp]
            for thisComponent in crdm_pract1_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract1_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract1_trial_img* updates
                
                # if crdm_pract1_trial_img is starting this frame...
                if crdm_pract1_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_img.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_img.status = STARTED
                    crdm_pract1_trial_img.setAutoDraw(True)
                
                # if crdm_pract1_trial_img is active this frame...
                if crdm_pract1_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_img is stopping this frame...
                if crdm_pract1_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_img.status = FINISHED
                        crdm_pract1_trial_img.setAutoDraw(False)
                
                # *crdm_pract1_trial_lott_top_txt* updates
                
                # if crdm_pract1_trial_lott_top_txt is starting this frame...
                if crdm_pract1_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_lott_top_txt.status = STARTED
                    crdm_pract1_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_lott_top_txt is active this frame...
                if crdm_pract1_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_lott_top_txt is stopping this frame...
                if crdm_pract1_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_lott_top_txt.status = FINISHED
                        crdm_pract1_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_pract1_trial_lott_bot_txt* updates
                
                # if crdm_pract1_trial_lott_bot_txt is starting this frame...
                if crdm_pract1_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_lott_bot_txt.status = STARTED
                    crdm_pract1_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_lott_bot_txt is active this frame...
                if crdm_pract1_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_lott_bot_txt is stopping this frame...
                if crdm_pract1_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_lott_bot_txt.status = FINISHED
                        crdm_pract1_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_pract1_trial_sure_amt_txt* updates
                
                # if crdm_pract1_trial_sure_amt_txt is starting this frame...
                if crdm_pract1_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_sure_amt_txt.status = STARTED
                    crdm_pract1_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_pract1_trial_sure_amt_txt is active this frame...
                if crdm_pract1_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_sure_amt_txt is stopping this frame...
                if crdm_pract1_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_sure_amt_txt.status = FINISHED
                        crdm_pract1_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix4* updates
                
                # if GRFX_fix4 is starting this frame...
                if GRFX_fix4.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix4.frameNStart = frameN  # exact frame index
                    GRFX_fix4.tStart = t  # local t and not account for scr refresh
                    GRFX_fix4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix4.status = STARTED
                    GRFX_fix4.setAutoDraw(True)
                
                # if GRFX_fix4 is active this frame...
                if GRFX_fix4.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix4 is stopping this frame...
                if GRFX_fix4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix4.tStop = t  # not accounting for scr refresh
                        GRFX_fix4.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix4.status = FINISHED
                        GRFX_fix4.setAutoDraw(False)
                
                # *crdm_pract1_trial_cue* updates
                
                # if crdm_pract1_trial_cue is starting this frame...
                if crdm_pract1_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_cue.status = STARTED
                    crdm_pract1_trial_cue.setAutoDraw(True)
                
                # if crdm_pract1_trial_cue is active this frame...
                if crdm_pract1_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_trial_cue is stopping this frame...
                if crdm_pract1_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_cue.status = FINISHED
                        crdm_pract1_trial_cue.setAutoDraw(False)
                
                # *crdm_pract1_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_pract1_trial_resp is starting this frame...
                if crdm_pract1_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_pract1_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract1_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract1_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract1_trial_resp is stopping this frame...
                if crdm_pract1_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract1_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_trial_resp.status = FINISHED
                        crdm_pract1_trial_resp.status = FINISHED
                if crdm_pract1_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract1_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract1_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract1_trial_resp_allKeys):
                        crdm_pract1_trial_resp.keys = _crdm_pract1_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_pract1_trial_resp.rt = _crdm_pract1_trial_resp_allKeys[0].rt
                        crdm_pract1_trial_resp.duration = _crdm_pract1_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_pract1_trial_resp.keys == str(crdm_sure_resp1)) or (crdm_pract1_trial_resp.keys == crdm_sure_resp1):
                            crdm_pract1_trial_resp.corr = 1
                        else:
                            crdm_pract1_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract1_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract1_trial" ---
            for thisComponent in crdm_pract1_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract1_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_pract1_trial_code
            crdm_pract1_key = crdm_pract1_trial_resp.keys
            crdm_pract1_sure_key = crdm_pract1_trial_resp.corr
            
            my_loop.addData("crdm_trial_type", "practice1")
            # check responses
            if crdm_pract1_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_pract1_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp1).lower() == 'none':
                   crdm_pract1_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_pract1_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_pract1_trials2 (TrialHandler)
            crdm_pract1_trials2.addData('crdm_pract1_trial_resp.keys',crdm_pract1_trial_resp.keys)
            crdm_pract1_trials2.addData('crdm_pract1_trial_resp.corr', crdm_pract1_trial_resp.corr)
            if crdm_pract1_trial_resp.keys != None:  # we had a response
                crdm_pract1_trials2.addData('crdm_pract1_trial_resp.rt', crdm_pract1_trial_resp.rt)
                crdm_pract1_trials2.addData('crdm_pract1_trial_resp.duration', crdm_pract1_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_pract1_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract1_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract1_feedback_code
            if len(crdm_pract1_key) == 0: #Ss did not respond
                crdm_msg1 = "NO RESPONSE"
            elif crdm_pract1_sure_key: #Ss chose sure amt
                crdm_msg1 = "CERTAIN $" + str(format(crdm_sure_amt1))
            else: #Ss chose lottery
                crdm_msg1 = "LOTTERY"
            crdm_pract1_feedback_txt.setText(crdm_msg1)
            # keep track of which components have finished
            crdm_pract1_feedbackComponents = [crdm_pract1_feedback_txt]
            for thisComponent in crdm_pract1_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract1_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract1_feedback_txt* updates
                
                # if crdm_pract1_feedback_txt is starting this frame...
                if crdm_pract1_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract1_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_pract1_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract1_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract1_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract1_feedback_txt.status = STARTED
                    crdm_pract1_feedback_txt.setAutoDraw(True)
                
                # if crdm_pract1_feedback_txt is active this frame...
                if crdm_pract1_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract1_feedback_txt is stopping this frame...
                if crdm_pract1_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract1_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract1_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract1_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract1_feedback_txt.status = FINISHED
                        crdm_pract1_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract1_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract1_feedback" ---
            for thisComponent in crdm_pract1_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract1_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_pract1_trials2'
        
        
        # --- Prepare to start Routine "crdm_qp_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_qp_instr.started', globalClock.getTime())
        crdm_qp_instr_resp.keys = []
        crdm_qp_instr_resp.rt = []
        _crdm_qp_instr_resp_allKeys = []
        # keep track of which components have finished
        crdm_qp_instrComponents = [crdm_qp_instr_title_txt, crdm_qp_instr_txt, crdm_qp_instr_space_txt, crdm_qp_instr_resp]
        for thisComponent in crdm_qp_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_qp_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_qp_instr_title_txt* updates
            
            # if crdm_qp_instr_title_txt is starting this frame...
            if crdm_qp_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_title_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_title_txt.status = STARTED
                crdm_qp_instr_title_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_title_txt is active this frame...
            if crdm_qp_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_txt* updates
            
            # if crdm_qp_instr_txt is starting this frame...
            if crdm_qp_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_txt.status = STARTED
                crdm_qp_instr_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_txt is active this frame...
            if crdm_qp_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_space_txt* updates
            
            # if crdm_qp_instr_space_txt is starting this frame...
            if crdm_qp_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_qp_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_space_txt.status = STARTED
                crdm_qp_instr_space_txt.setAutoDraw(True)
            
            # if crdm_qp_instr_space_txt is active this frame...
            if crdm_qp_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_qp_instr_resp* updates
            waitOnFlip = False
            
            # if crdm_qp_instr_resp is starting this frame...
            if crdm_qp_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_qp_instr_resp.frameNStart = frameN  # exact frame index
                crdm_qp_instr_resp.tStart = t  # local t and not account for scr refresh
                crdm_qp_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_qp_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_qp_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_qp_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_qp_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_qp_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_qp_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_qp_instr_resp_allKeys.extend(theseKeys)
                if len(_crdm_qp_instr_resp_allKeys):
                    crdm_qp_instr_resp.keys = _crdm_qp_instr_resp_allKeys[-1].name  # just the last key pressed
                    crdm_qp_instr_resp.rt = _crdm_qp_instr_resp_allKeys[-1].rt
                    crdm_qp_instr_resp.duration = _crdm_qp_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_qp_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_qp_instr" ---
        for thisComponent in crdm_qp_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_qp_instr.stopped', globalClock.getTime())
        # the Routine "crdm_qp_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        crdm_qp_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_questplus_trials.csv'),
            seed=None, name='crdm_qp_trials2')
        thisExp.addLoop(crdm_qp_trials2)  # add the loop to the experiment
        thisCrdm_qp_trials2 = crdm_qp_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_qp_trials2.rgb)
        if thisCrdm_qp_trials2 != None:
            for paramName in thisCrdm_qp_trials2:
                globals()[paramName] = thisCrdm_qp_trials2[paramName]
        
        for thisCrdm_qp_trials2 in crdm_qp_trials2:
            currentLoop = crdm_qp_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_qp_trials2.rgb)
            if thisCrdm_qp_trials2 != None:
                for paramName in thisCrdm_qp_trials2:
                    globals()[paramName] = thisCrdm_qp_trials2[paramName]
            
            # --- Prepare to start Routine "crdm_questplus" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_questplus.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_questplus_JS
            my_loop = eval("questplus_trials")
            crdm_questplus_img.setImage("crdm/" + crdm_img_qp)
            crdm_questplus_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top_qp))))
            crdm_questplus_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot_qp))))
            crdm_questplus_trial_sure_amt_txt.setPos(crdm_sure_pos_qp)
            crdm_questplus_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt_qp)))
            )
            crdm_questplus_trial_resp.keys = []
            crdm_questplus_trial_resp.rt = []
            _crdm_questplus_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_questplusComponents = [crdm_questplus_img, crdm_questplus_trial_lott_top_txt, crdm_questplus_trial_lott_bot_txt, crdm_questplus_trial_sure_amt_txt, GRFX_fix3, crdm_questplus_trial_cue, crdm_questplus_trial_resp]
            for thisComponent in crdm_questplusComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_questplus" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_questplus_img* updates
                
                # if crdm_questplus_img is starting this frame...
                if crdm_questplus_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_img.frameNStart = frameN  # exact frame index
                    crdm_questplus_img.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_img.status = STARTED
                    crdm_questplus_img.setAutoDraw(True)
                
                # if crdm_questplus_img is active this frame...
                if crdm_questplus_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_img is stopping this frame...
                if crdm_questplus_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_img.tStop = t  # not accounting for scr refresh
                        crdm_questplus_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_img.status = FINISHED
                        crdm_questplus_img.setAutoDraw(False)
                
                # *crdm_questplus_trial_lott_top_txt* updates
                
                # if crdm_questplus_trial_lott_top_txt is starting this frame...
                if crdm_questplus_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_lott_top_txt.status = STARTED
                    crdm_questplus_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_lott_top_txt is active this frame...
                if crdm_questplus_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_lott_top_txt is stopping this frame...
                if crdm_questplus_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_lott_top_txt.status = FINISHED
                        crdm_questplus_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_questplus_trial_lott_bot_txt* updates
                
                # if crdm_questplus_trial_lott_bot_txt is starting this frame...
                if crdm_questplus_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_lott_bot_txt.status = STARTED
                    crdm_questplus_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_lott_bot_txt is active this frame...
                if crdm_questplus_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_lott_bot_txt is stopping this frame...
                if crdm_questplus_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_lott_bot_txt.status = FINISHED
                        crdm_questplus_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_questplus_trial_sure_amt_txt* updates
                
                # if crdm_questplus_trial_sure_amt_txt is starting this frame...
                if crdm_questplus_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_sure_amt_txt.status = STARTED
                    crdm_questplus_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_questplus_trial_sure_amt_txt is active this frame...
                if crdm_questplus_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_sure_amt_txt is stopping this frame...
                if crdm_questplus_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_sure_amt_txt.status = FINISHED
                        crdm_questplus_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix3* updates
                
                # if GRFX_fix3 is starting this frame...
                if GRFX_fix3.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix3.frameNStart = frameN  # exact frame index
                    GRFX_fix3.tStart = t  # local t and not account for scr refresh
                    GRFX_fix3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix3.status = STARTED
                    GRFX_fix3.setAutoDraw(True)
                
                # if GRFX_fix3 is active this frame...
                if GRFX_fix3.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix3 is stopping this frame...
                if GRFX_fix3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix3.tStop = t  # not accounting for scr refresh
                        GRFX_fix3.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix3.status = FINISHED
                        GRFX_fix3.setAutoDraw(False)
                
                # *crdm_questplus_trial_cue* updates
                
                # if crdm_questplus_trial_cue is starting this frame...
                if crdm_questplus_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_cue.status = STARTED
                    crdm_questplus_trial_cue.setAutoDraw(True)
                
                # if crdm_questplus_trial_cue is active this frame...
                if crdm_questplus_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_questplus_trial_cue is stopping this frame...
                if crdm_questplus_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_cue.status = FINISHED
                        crdm_questplus_trial_cue.setAutoDraw(False)
                
                # *crdm_questplus_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_questplus_trial_resp is starting this frame...
                if crdm_questplus_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_questplus_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_questplus_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_questplus_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_questplus_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_questplus_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_questplus_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_questplus_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_questplus_trial_resp is stopping this frame...
                if crdm_questplus_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_questplus_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_questplus_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_questplus_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_questplus_trial_resp.status = FINISHED
                        crdm_questplus_trial_resp.status = FINISHED
                if crdm_questplus_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_questplus_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_questplus_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_questplus_trial_resp_allKeys):
                        crdm_questplus_trial_resp.keys = _crdm_questplus_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_questplus_trial_resp.rt = _crdm_questplus_trial_resp_allKeys[0].rt
                        crdm_questplus_trial_resp.duration = _crdm_questplus_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_questplus_trial_resp.keys == str(crdm_sure_resp_qp)) or (crdm_questplus_trial_resp.keys == crdm_sure_resp_qp):
                            crdm_questplus_trial_resp.corr = 1
                        else:
                            crdm_questplus_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_questplusComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_questplus" ---
            for thisComponent in crdm_questplusComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_questplus.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_questplus_JS
            qp_key = crdm_questplus_trial_resp.keys
            qp_sure_key = crdm_questplus_trial_resp.corr
            my_loop.addData("crdm_trial_type", "questplus")
            
            
            
            
            my_loop.addData("response", cur_response)
            my_loop.addData('mean_alpha', post_mean[0])
            my_loop.addData('mean_beta', post_mean[1])
            my_loop.addData('mean_gamma', post_mean[2])
            my_loop.addData('sd_alpha', post_sd[0])
            my_loop.addData('sd_beta', post_sd[1])
            my_loop.addData('sd_gamma', post_sd[2])
            my_loop.addData("lott_reward", cur_design["value_reward"])
            my_loop.addData("lott_prob", int(cur_design["p_reward"]*100))
            my_loop.addData("ambig_level", int(cur_design["amb_level"]*100))
            # check responses
            if crdm_questplus_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_questplus_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp_qp).lower() == 'none':
                   crdm_questplus_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_questplus_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_qp_trials2 (TrialHandler)
            crdm_qp_trials2.addData('crdm_questplus_trial_resp.keys',crdm_questplus_trial_resp.keys)
            crdm_qp_trials2.addData('crdm_questplus_trial_resp.corr', crdm_questplus_trial_resp.corr)
            if crdm_questplus_trial_resp.keys != None:  # we had a response
                crdm_qp_trials2.addData('crdm_questplus_trial_resp.rt', crdm_questplus_trial_resp.rt)
                crdm_qp_trials2.addData('crdm_questplus_trial_resp.duration', crdm_questplus_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_qp_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_qp_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_qp_feedback_code
            if len(crdm_qp_key) == 0: #Ss did not respond
                crdm_msg_qp  = "NO RESPONSE"
            elif crdm_qp_sure_key: #Ss chose sure amt
                crdm_msg_qp  = "CERTAIN $" + str(format(cur_design["value_null"]))
            else: #Ss chose lottery
                crdm_msg_qp  = "LOTTERY"
            crdm_qp_feedback_txt.setText(crdm_msg_qp)
            # keep track of which components have finished
            crdm_qp_feedbackComponents = [crdm_qp_feedback_txt]
            for thisComponent in crdm_qp_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_qp_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_qp_feedback_txt* updates
                
                # if crdm_qp_feedback_txt is starting this frame...
                if crdm_qp_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_qp_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_qp_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_qp_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_qp_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_qp_feedback_txt.status = STARTED
                    crdm_qp_feedback_txt.setAutoDraw(True)
                
                # if crdm_qp_feedback_txt is active this frame...
                if crdm_qp_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_qp_feedback_txt is stopping this frame...
                if crdm_qp_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_qp_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_qp_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_qp_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_qp_feedback_txt.status = FINISHED
                        crdm_qp_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_qp_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_qp_feedback" ---
            for thisComponent in crdm_qp_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_qp_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_qp_trials2'
        
        
        # --- Prepare to start Routine "crdm_schedule_gen" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_schedule_gen.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_schedule_genComponents = []
        for thisComponent in crdm_schedule_genComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_schedule_gen" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_schedule_genComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_schedule_gen" ---
        for thisComponent in crdm_schedule_genComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_schedule_gen.stopped', globalClock.getTime())
        # the Routine "crdm_schedule_gen" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_pract2_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_pract2_instr.started', globalClock.getTime())
        crdm_pract2_instr_key.keys = []
        crdm_pract2_instr_key.rt = []
        _crdm_pract2_instr_key_allKeys = []
        # keep track of which components have finished
        crdm_pract2_instrComponents = [crdm_pract2_instr_name_txt, crdm_pract2_instr_txt, crdm_pract2_instr_space_txt, crdm_pract2_instr_key]
        for thisComponent in crdm_pract2_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_pract2_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_pract2_instr_name_txt* updates
            
            # if crdm_pract2_instr_name_txt is starting this frame...
            if crdm_pract2_instr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_name_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_name_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_name_txt.status = STARTED
                crdm_pract2_instr_name_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_name_txt is active this frame...
            if crdm_pract2_instr_name_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_txt* updates
            
            # if crdm_pract2_instr_txt is starting this frame...
            if crdm_pract2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_txt.status = STARTED
                crdm_pract2_instr_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_txt is active this frame...
            if crdm_pract2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_space_txt* updates
            
            # if crdm_pract2_instr_space_txt is starting this frame...
            if crdm_pract2_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_space_txt.status = STARTED
                crdm_pract2_instr_space_txt.setAutoDraw(True)
            
            # if crdm_pract2_instr_space_txt is active this frame...
            if crdm_pract2_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_pract2_instr_key* updates
            waitOnFlip = False
            
            # if crdm_pract2_instr_key is starting this frame...
            if crdm_pract2_instr_key.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_pract2_instr_key.frameNStart = frameN  # exact frame index
                crdm_pract2_instr_key.tStart = t  # local t and not account for scr refresh
                crdm_pract2_instr_key.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_pract2_instr_key, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_pract2_instr_key.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_pract2_instr_key.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_pract2_instr_key.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_pract2_instr_key.status == STARTED and not waitOnFlip:
                theseKeys = crdm_pract2_instr_key.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_pract2_instr_key_allKeys.extend(theseKeys)
                if len(_crdm_pract2_instr_key_allKeys):
                    crdm_pract2_instr_key.keys = _crdm_pract2_instr_key_allKeys[-1].name  # just the last key pressed
                    crdm_pract2_instr_key.rt = _crdm_pract2_instr_key_allKeys[-1].rt
                    crdm_pract2_instr_key.duration = _crdm_pract2_instr_key_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_pract2_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_pract2_instr" ---
        for thisComponent in crdm_pract2_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_pract2_instr.stopped', globalClock.getTime())
        # the Routine "crdm_pract2_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_pract2_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_practice2.csv'),
            seed=None, name='crdm_pract2_trials2')
        thisExp.addLoop(crdm_pract2_trials2)  # add the loop to the experiment
        thisCrdm_pract2_trials2 = crdm_pract2_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract2_trials2.rgb)
        if thisCrdm_pract2_trials2 != None:
            for paramName in thisCrdm_pract2_trials2:
                globals()[paramName] = thisCrdm_pract2_trials2[paramName]
        
        for thisCrdm_pract2_trials2 in crdm_pract2_trials2:
            currentLoop = crdm_pract2_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_pract2_trials2.rgb)
            if thisCrdm_pract2_trials2 != None:
                for paramName in thisCrdm_pract2_trials2:
                    globals()[paramName] = thisCrdm_pract2_trials2[paramName]
            
            # --- Prepare to start Routine "crdm_pract2_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_trial_code
            my_loop = eval(crdm_practice_loop2_name)
            
            #random index for certain outcome position and response
            crdm_idx2 = random.randint(0,1) 
            crdm_sure_pos2 = crdm_pos2[crdm_idx2] 
            crdm_sure_resp2 = crdm_resp2[crdm_idx2]
            crdm_pract2_trial_img.setImage("crdm/" + crdm_img2)
            crdm_pract2_trial_lott_top_txt.setText(str("$"+str(format(crdm_lott_top2))))
            crdm_pract2_trial_lott_bot_txt.setText(str("$"+str(format(crdm_lott_bot2))))
            crdm_pract2_trial_sure_amt_txt.setPos(crdm_sure_pos2)
            crdm_pract2_trial_sure_amt_txt.setText(str("$"+str(format(crdm_sure_amt2)))
            )
            crdm_pract2_trial_resp.keys = []
            crdm_pract2_trial_resp.rt = []
            _crdm_pract2_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract2_trialComponents = [crdm_pract2_trial_img, crdm_pract2_trial_lott_top_txt, crdm_pract2_trial_lott_bot_txt, crdm_pract2_trial_sure_amt_txt, GRFX_fix2, crdm_pract2_trial_cue, crdm_pract2_trial_resp]
            for thisComponent in crdm_pract2_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_trial_img* updates
                
                # if crdm_pract2_trial_img is starting this frame...
                if crdm_pract2_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_img.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_img.status = STARTED
                    crdm_pract2_trial_img.setAutoDraw(True)
                
                # if crdm_pract2_trial_img is active this frame...
                if crdm_pract2_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_img is stopping this frame...
                if crdm_pract2_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_img.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_img.status = FINISHED
                        crdm_pract2_trial_img.setAutoDraw(False)
                
                # *crdm_pract2_trial_lott_top_txt* updates
                
                # if crdm_pract2_trial_lott_top_txt is starting this frame...
                if crdm_pract2_trial_lott_top_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_lott_top_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_lott_top_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_lott_top_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_lott_top_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_lott_top_txt.status = STARTED
                    crdm_pract2_trial_lott_top_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_lott_top_txt is active this frame...
                if crdm_pract2_trial_lott_top_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_lott_top_txt is stopping this frame...
                if crdm_pract2_trial_lott_top_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_lott_top_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_lott_top_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_lott_top_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_lott_top_txt.status = FINISHED
                        crdm_pract2_trial_lott_top_txt.setAutoDraw(False)
                
                # *crdm_pract2_trial_lott_bot_txt* updates
                
                # if crdm_pract2_trial_lott_bot_txt is starting this frame...
                if crdm_pract2_trial_lott_bot_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_lott_bot_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_lott_bot_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_lott_bot_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_lott_bot_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_lott_bot_txt.status = STARTED
                    crdm_pract2_trial_lott_bot_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_lott_bot_txt is active this frame...
                if crdm_pract2_trial_lott_bot_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_lott_bot_txt is stopping this frame...
                if crdm_pract2_trial_lott_bot_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_lott_bot_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_lott_bot_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_lott_bot_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_lott_bot_txt.status = FINISHED
                        crdm_pract2_trial_lott_bot_txt.setAutoDraw(False)
                
                # *crdm_pract2_trial_sure_amt_txt* updates
                
                # if crdm_pract2_trial_sure_amt_txt is starting this frame...
                if crdm_pract2_trial_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_sure_amt_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_sure_amt_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_sure_amt_txt.status = STARTED
                    crdm_pract2_trial_sure_amt_txt.setAutoDraw(True)
                
                # if crdm_pract2_trial_sure_amt_txt is active this frame...
                if crdm_pract2_trial_sure_amt_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_sure_amt_txt is stopping this frame...
                if crdm_pract2_trial_sure_amt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_sure_amt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_sure_amt_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_sure_amt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_sure_amt_txt.status = FINISHED
                        crdm_pract2_trial_sure_amt_txt.setAutoDraw(False)
                
                # *GRFX_fix2* updates
                
                # if GRFX_fix2 is starting this frame...
                if GRFX_fix2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix2.frameNStart = frameN  # exact frame index
                    GRFX_fix2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix2.status = STARTED
                    GRFX_fix2.setAutoDraw(True)
                
                # if GRFX_fix2 is active this frame...
                if GRFX_fix2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix2 is stopping this frame...
                if GRFX_fix2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix2.tStop = t  # not accounting for scr refresh
                        GRFX_fix2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix2.status = FINISHED
                        GRFX_fix2.setAutoDraw(False)
                
                # *crdm_pract2_trial_cue* updates
                
                # if crdm_pract2_trial_cue is starting this frame...
                if crdm_pract2_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_cue.status = STARTED
                    crdm_pract2_trial_cue.setAutoDraw(True)
                
                # if crdm_pract2_trial_cue is active this frame...
                if crdm_pract2_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_trial_cue is stopping this frame...
                if crdm_pract2_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_cue.status = FINISHED
                        crdm_pract2_trial_cue.setAutoDraw(False)
                
                # *crdm_pract2_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_pract2_trial_resp is starting this frame...
                if crdm_pract2_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_pract2_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract2_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract2_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract2_trial_resp is stopping this frame...
                if crdm_pract2_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract2_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_trial_resp.status = FINISHED
                        crdm_pract2_trial_resp.status = FINISHED
                if crdm_pract2_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract2_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract2_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract2_trial_resp_allKeys):
                        crdm_pract2_trial_resp.keys = _crdm_pract2_trial_resp_allKeys[0].name  # just the first key pressed
                        crdm_pract2_trial_resp.rt = _crdm_pract2_trial_resp_allKeys[0].rt
                        crdm_pract2_trial_resp.duration = _crdm_pract2_trial_resp_allKeys[0].duration
                        # was this correct?
                        if (crdm_pract2_trial_resp.keys == str(crdm_sure_resp2)) or (crdm_pract2_trial_resp.keys == crdm_sure_resp2):
                            crdm_pract2_trial_resp.corr = 1
                        else:
                            crdm_pract2_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_trial" ---
            for thisComponent in crdm_pract2_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_pract2_trial_code
            crdm_pract2_key = crdm_pract2_trial_resp.keys
            crdm_pract2_sure_key = crdm_pract2_trial_resp.corr
            
            my_loop.addData("crdm_trial_type", "practice2")
            # check responses
            if crdm_pract2_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_pract2_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp2).lower() == 'none':
                   crdm_pract2_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_pract2_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_pract2_trials2 (TrialHandler)
            crdm_pract2_trials2.addData('crdm_pract2_trial_resp.keys',crdm_pract2_trial_resp.keys)
            crdm_pract2_trials2.addData('crdm_pract2_trial_resp.corr', crdm_pract2_trial_resp.corr)
            if crdm_pract2_trial_resp.keys != None:  # we had a response
                crdm_pract2_trials2.addData('crdm_pract2_trial_resp.rt', crdm_pract2_trial_resp.rt)
                crdm_pract2_trials2.addData('crdm_pract2_trial_resp.duration', crdm_pract2_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_pract2_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_feedback_code
            if len(crdm_pract2_key) == 0: #Ss did not respond
                crdm_msg2 = "NO RESPONSE"
            elif crdm_pract2_sure_key: #Ss chose sure amt
                crdm_msg2 = "CERTAIN $" + str(format(crdm_sure_amt2))
            else: #Ss chose lottery
                crdm_msg2 = "LOTTERY"
            crdm_pract2_feedback_txt.setText(crdm_msg2)
            # keep track of which components have finished
            crdm_pract2_feedbackComponents = [crdm_pract2_feedback_txt]
            for thisComponent in crdm_pract2_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_feedback_txt* updates
                
                # if crdm_pract2_feedback_txt is starting this frame...
                if crdm_pract2_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_feedback_txt.status = STARTED
                    crdm_pract2_feedback_txt.setAutoDraw(True)
                
                # if crdm_pract2_feedback_txt is active this frame...
                if crdm_pract2_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_feedback_txt is stopping this frame...
                if crdm_pract2_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_feedback_txt.status = FINISHED
                        crdm_pract2_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_feedback" ---
            for thisComponent in crdm_pract2_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "crdm_pract2_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_conf_code
            #Ss did not respond
            if len(crdm_pract2_key) == 0: 
                continueRoutine = False
            
            #set default gray for all four response boxes
            conf1_color = [0, 0, 0] 
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            crdm_pract2_conf_resp.keys = []
            crdm_pract2_conf_resp.rt = []
            _crdm_pract2_conf_resp_allKeys = []
            # keep track of which components have finished
            crdm_pract2_confComponents = [crdm_pract2_conf_txt, crdm_pract2_conf1, crdm_pract2_conf1_txt, crdm_pract2_conf2, crdm_pract2_conf2_txt, crdm_pract2_conf3, crdm_pract2_conf3_txt, crdm_pract2_conf4, crdm_pract2_conf4_txt, crdm_pract2_conf_resp]
            for thisComponent in crdm_pract2_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_pract2_conf_code
                #resp is received
                crdm_pract_conf_key = crdm_pract2_conf_resp.keys
                if len(crdm_pract_conf_key) == 1:
                    #not at all confident
                    if crdm_pract_conf_key == "1":
                        #change box color to indicate selection
                        conf1_color = "darkgray" 
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    #less confident
                    elif crdm_pract_conf_key == "2": 
                        conf1_color = [0,0,0]
                        conf2_color = "darkgray"
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    #somewhat confident
                    elif crdm_pract_conf_key == "3": 
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = "darkgray"
                        conf4_color = [0,0,0]
                    #very confident
                    elif crdm_pract_conf_key == "4": 
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = "darkgray"
                
                # *crdm_pract2_conf_txt* updates
                
                # if crdm_pract2_conf_txt is starting this frame...
                if crdm_pract2_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf_txt.status = STARTED
                    crdm_pract2_conf_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf_txt is active this frame...
                if crdm_pract2_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf_txt is stopping this frame...
                if crdm_pract2_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf_txt.status = FINISHED
                        crdm_pract2_conf_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf1* updates
                
                # if crdm_pract2_conf1 is starting this frame...
                if crdm_pract2_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf1.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf1.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf1.status = STARTED
                    crdm_pract2_conf1.setAutoDraw(True)
                
                # if crdm_pract2_conf1 is active this frame...
                if crdm_pract2_conf1.status == STARTED:
                    # update params
                    crdm_pract2_conf1.setFillColor(conf1_color, log=False)
                
                # if crdm_pract2_conf1 is stopping this frame...
                if crdm_pract2_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf1.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf1.status = FINISHED
                        crdm_pract2_conf1.setAutoDraw(False)
                
                # *crdm_pract2_conf1_txt* updates
                
                # if crdm_pract2_conf1_txt is starting this frame...
                if crdm_pract2_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf1_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf1_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf1_txt.status = STARTED
                    crdm_pract2_conf1_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf1_txt is active this frame...
                if crdm_pract2_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf1_txt is stopping this frame...
                if crdm_pract2_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf1_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf1_txt.status = FINISHED
                        crdm_pract2_conf1_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf2* updates
                
                # if crdm_pract2_conf2 is starting this frame...
                if crdm_pract2_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf2.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf2.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf2.status = STARTED
                    crdm_pract2_conf2.setAutoDraw(True)
                
                # if crdm_pract2_conf2 is active this frame...
                if crdm_pract2_conf2.status == STARTED:
                    # update params
                    crdm_pract2_conf2.setFillColor(conf2_color, log=False)
                
                # if crdm_pract2_conf2 is stopping this frame...
                if crdm_pract2_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf2.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf2.status = FINISHED
                        crdm_pract2_conf2.setAutoDraw(False)
                
                # *crdm_pract2_conf2_txt* updates
                
                # if crdm_pract2_conf2_txt is starting this frame...
                if crdm_pract2_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf2_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf2_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf2_txt.status = STARTED
                    crdm_pract2_conf2_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf2_txt is active this frame...
                if crdm_pract2_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf2_txt is stopping this frame...
                if crdm_pract2_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf2_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf2_txt.status = FINISHED
                        crdm_pract2_conf2_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf3* updates
                
                # if crdm_pract2_conf3 is starting this frame...
                if crdm_pract2_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf3.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf3.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf3.status = STARTED
                    crdm_pract2_conf3.setAutoDraw(True)
                
                # if crdm_pract2_conf3 is active this frame...
                if crdm_pract2_conf3.status == STARTED:
                    # update params
                    crdm_pract2_conf3.setFillColor(conf3_color, log=False)
                
                # if crdm_pract2_conf3 is stopping this frame...
                if crdm_pract2_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf3.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf3.status = FINISHED
                        crdm_pract2_conf3.setAutoDraw(False)
                
                # *crdm_pract2_conf3_txt* updates
                
                # if crdm_pract2_conf3_txt is starting this frame...
                if crdm_pract2_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf3_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf3_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf3_txt.status = STARTED
                    crdm_pract2_conf3_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf3_txt is active this frame...
                if crdm_pract2_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf3_txt is stopping this frame...
                if crdm_pract2_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf3_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf3_txt.status = FINISHED
                        crdm_pract2_conf3_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf4* updates
                
                # if crdm_pract2_conf4 is starting this frame...
                if crdm_pract2_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf4.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf4.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf4.status = STARTED
                    crdm_pract2_conf4.setAutoDraw(True)
                
                # if crdm_pract2_conf4 is active this frame...
                if crdm_pract2_conf4.status == STARTED:
                    # update params
                    crdm_pract2_conf4.setFillColor(conf4_color, log=False)
                
                # if crdm_pract2_conf4 is stopping this frame...
                if crdm_pract2_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf4.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf4.status = FINISHED
                        crdm_pract2_conf4.setAutoDraw(False)
                
                # *crdm_pract2_conf4_txt* updates
                
                # if crdm_pract2_conf4_txt is starting this frame...
                if crdm_pract2_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf4_txt.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf4_txt.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf4_txt.status = STARTED
                    crdm_pract2_conf4_txt.setAutoDraw(True)
                
                # if crdm_pract2_conf4_txt is active this frame...
                if crdm_pract2_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_conf4_txt is stopping this frame...
                if crdm_pract2_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf4_txt.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf4_txt.status = FINISHED
                        crdm_pract2_conf4_txt.setAutoDraw(False)
                
                # *crdm_pract2_conf_resp* updates
                waitOnFlip = False
                
                # if crdm_pract2_conf_resp is starting this frame...
                if crdm_pract2_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_conf_resp.frameNStart = frameN  # exact frame index
                    crdm_pract2_conf_resp.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_pract2_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_pract2_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_pract2_conf_resp is stopping this frame...
                if crdm_pract2_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_conf_resp.tStop = t  # not accounting for scr refresh
                        crdm_pract2_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_conf_resp.status = FINISHED
                        crdm_pract2_conf_resp.status = FINISHED
                if crdm_pract2_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_pract2_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_pract2_conf_resp_allKeys.extend(theseKeys)
                    if len(_crdm_pract2_conf_resp_allKeys):
                        crdm_pract2_conf_resp.keys = _crdm_pract2_conf_resp_allKeys[-1].name  # just the last key pressed
                        crdm_pract2_conf_resp.rt = _crdm_pract2_conf_resp_allKeys[-1].rt
                        crdm_pract2_conf_resp.duration = _crdm_pract2_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_conf" ---
            for thisComponent in crdm_pract2_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_conf.stopped', globalClock.getTime())
            # check responses
            if crdm_pract2_conf_resp.keys in ['', [], None]:  # No response was made
                crdm_pract2_conf_resp.keys = None
            crdm_pract2_trials2.addData('crdm_pract2_conf_resp.keys',crdm_pract2_conf_resp.keys)
            if crdm_pract2_conf_resp.keys != None:  # we had a response
                crdm_pract2_trials2.addData('crdm_pract2_conf_resp.rt', crdm_pract2_conf_resp.rt)
                crdm_pract2_trials2.addData('crdm_pract2_conf_resp.duration', crdm_pract2_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "crdm_pract2_iti2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_pract2_iti2.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_pract2_iti2_code
            #3 CRDM practice trials
            if crdm_pract2_trials2.thisTrialN == 5:
                continueRoutine = False
            # keep track of which components have finished
            crdm_pract2_iti2Components = [crdm_pract2_iti2_poly]
            for thisComponent in crdm_pract2_iti2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_pract2_iti2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_pract2_iti2_poly* updates
                
                # if crdm_pract2_iti2_poly is starting this frame...
                if crdm_pract2_iti2_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_pract2_iti2_poly.frameNStart = frameN  # exact frame index
                    crdm_pract2_iti2_poly.tStart = t  # local t and not account for scr refresh
                    crdm_pract2_iti2_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_pract2_iti2_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_pract2_iti2_poly.status = STARTED
                    crdm_pract2_iti2_poly.setAutoDraw(True)
                
                # if crdm_pract2_iti2_poly is active this frame...
                if crdm_pract2_iti2_poly.status == STARTED:
                    # update params
                    pass
                
                # if crdm_pract2_iti2_poly is stopping this frame...
                if crdm_pract2_iti2_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_pract2_iti2_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_pract2_iti2_poly.tStop = t  # not accounting for scr refresh
                        crdm_pract2_iti2_poly.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_pract2_iti2_poly.status = FINISHED
                        crdm_pract2_iti2_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_pract2_iti2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_pract2_iti2" ---
            for thisComponent in crdm_pract2_iti2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_pract2_iti2.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_pract2_trials2'
        
        
        # --- Prepare to start Routine "crdm_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_trial_instr.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_trial_instr_code
        crdm_task_resps = []
        crdm_conf_resps = []
        crdm_catch_trials = []
        crdm_iti_list = [random.random() for i in range(144)] #create list of random floats (0-1) which is length of trial schedule
        crdm_s = sum(crdm_iti_list) #sum list of rnadom floats
        crdm_iti_list = [i*144/crdm_s for i in crdm_iti_list] #for each item in iti_list: multiple by list length, then divide by list sum
        crdm_trial_instr_resp.keys = []
        crdm_trial_instr_resp.rt = []
        _crdm_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        crdm_trial_instrComponents = [crdm_trial_instr_title_txt, crdm_trial_instr_txt, crdm_trial_instr_space_txt, crdm_trial_instr_resp]
        for thisComponent in crdm_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_trial_instr_title_txt* updates
            
            # if crdm_trial_instr_title_txt is starting this frame...
            if crdm_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_title_txt.status = STARTED
                crdm_trial_instr_title_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_title_txt is active this frame...
            if crdm_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_txt* updates
            
            # if crdm_trial_instr_txt is starting this frame...
            if crdm_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_txt.status = STARTED
                crdm_trial_instr_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_txt is active this frame...
            if crdm_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_space_txt* updates
            
            # if crdm_trial_instr_space_txt is starting this frame...
            if crdm_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                crdm_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_space_txt.status = STARTED
                crdm_trial_instr_space_txt.setAutoDraw(True)
            
            # if crdm_trial_instr_space_txt is active this frame...
            if crdm_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_trial_instr_resp* updates
            waitOnFlip = False
            
            # if crdm_trial_instr_resp is starting this frame...
            if crdm_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_trial_instr_resp.frameNStart = frameN  # exact frame index
                crdm_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                crdm_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_crdm_trial_instr_resp_allKeys):
                    crdm_trial_instr_resp.keys = _crdm_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    crdm_trial_instr_resp.rt = _crdm_trial_instr_resp_allKeys[-1].rt
                    crdm_trial_instr_resp.duration = _crdm_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_trial_instr" ---
        for thisComponent in crdm_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_trial_instr.stopped', globalClock.getTime())
        # the Routine "crdm_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "crdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        crdm_init_fixComponents = [crdm_init_fix_poly]
        for thisComponent in crdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_init_fix_poly* updates
            
            # if crdm_init_fix_poly is starting this frame...
            if crdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_init_fix_poly.frameNStart = frameN  # exact frame index
                crdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                crdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_init_fix_poly.status = STARTED
                crdm_init_fix_poly.setAutoDraw(True)
            
            # if crdm_init_fix_poly is active this frame...
            if crdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if crdm_init_fix_poly is stopping this frame...
            if crdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > crdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    crdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    crdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    crdm_init_fix_poly.status = FINISHED
                    crdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_init_fix" ---
        for thisComponent in crdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        crdm_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('crdm/crdm_gen_trials_idx.csv'),
            seed=None, name='crdm_trials2')
        thisExp.addLoop(crdm_trials2)  # add the loop to the experiment
        thisCrdm_trials2 = crdm_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCrdm_trials2.rgb)
        if thisCrdm_trials2 != None:
            for paramName in thisCrdm_trials2:
                globals()[paramName] = thisCrdm_trials2[paramName]
        
        for thisCrdm_trials2 in crdm_trials2:
            currentLoop = crdm_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCrdm_trials2.rgb)
            if thisCrdm_trials2 != None:
                for paramName in thisCrdm_trials2:
                    globals()[paramName] = thisCrdm_trials2[paramName]
            
            # --- Prepare to start Routine "crdm_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_trial_JS
            v
            crdm_trial_img.setImage("crdm/" + crdm_img)
            crdm_trial_lott_top.setText(str("$"+str(format(crdm_lott_top))))
            crdm_trial_lott_bot.setText(str("$"+str(format(crdm_lott_bot))))
            crdm_trial_sure_amt.setPos(crdm_sure_pos)
            crdm_trial_sure_amt.setText(str("$"+str(format(crdm_sure_amt))))
            crdm_trial_resp.keys = []
            crdm_trial_resp.rt = []
            _crdm_trial_resp_allKeys = []
            # keep track of which components have finished
            crdm_trialComponents = [crdm_trial_img, crdm_trial_lott_top, crdm_trial_lott_bot, crdm_trial_sure_amt, GRFX_fix, crdm_trial_cue, crdm_trial_resp]
            for thisComponent in crdm_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_trial_JS
                v
                
                # *crdm_trial_img* updates
                
                # if crdm_trial_img is starting this frame...
                if crdm_trial_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_img.frameNStart = frameN  # exact frame index
                    crdm_trial_img.tStart = t  # local t and not account for scr refresh
                    crdm_trial_img.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_img, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trial_img.started')
                    # update status
                    crdm_trial_img.status = STARTED
                    crdm_trial_img.setAutoDraw(True)
                
                # if crdm_trial_img is active this frame...
                if crdm_trial_img.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_img is stopping this frame...
                if crdm_trial_img.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_img.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_img.tStop = t  # not accounting for scr refresh
                        crdm_trial_img.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trial_img.stopped')
                        # update status
                        crdm_trial_img.status = FINISHED
                        crdm_trial_img.setAutoDraw(False)
                
                # *crdm_trial_lott_top* updates
                
                # if crdm_trial_lott_top is starting this frame...
                if crdm_trial_lott_top.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_lott_top.frameNStart = frameN  # exact frame index
                    crdm_trial_lott_top.tStart = t  # local t and not account for scr refresh
                    crdm_trial_lott_top.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_lott_top, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_lott_top.status = STARTED
                    crdm_trial_lott_top.setAutoDraw(True)
                
                # if crdm_trial_lott_top is active this frame...
                if crdm_trial_lott_top.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_lott_top is stopping this frame...
                if crdm_trial_lott_top.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_lott_top.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_lott_top.tStop = t  # not accounting for scr refresh
                        crdm_trial_lott_top.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_lott_top.status = FINISHED
                        crdm_trial_lott_top.setAutoDraw(False)
                
                # *crdm_trial_lott_bot* updates
                
                # if crdm_trial_lott_bot is starting this frame...
                if crdm_trial_lott_bot.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_lott_bot.frameNStart = frameN  # exact frame index
                    crdm_trial_lott_bot.tStart = t  # local t and not account for scr refresh
                    crdm_trial_lott_bot.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_lott_bot, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_lott_bot.status = STARTED
                    crdm_trial_lott_bot.setAutoDraw(True)
                
                # if crdm_trial_lott_bot is active this frame...
                if crdm_trial_lott_bot.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_lott_bot is stopping this frame...
                if crdm_trial_lott_bot.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_lott_bot.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_lott_bot.tStop = t  # not accounting for scr refresh
                        crdm_trial_lott_bot.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_lott_bot.status = FINISHED
                        crdm_trial_lott_bot.setAutoDraw(False)
                
                # *crdm_trial_sure_amt* updates
                
                # if crdm_trial_sure_amt is starting this frame...
                if crdm_trial_sure_amt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_sure_amt.frameNStart = frameN  # exact frame index
                    crdm_trial_sure_amt.tStart = t  # local t and not account for scr refresh
                    crdm_trial_sure_amt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_sure_amt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_sure_amt.status = STARTED
                    crdm_trial_sure_amt.setAutoDraw(True)
                
                # if crdm_trial_sure_amt is active this frame...
                if crdm_trial_sure_amt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_sure_amt is stopping this frame...
                if crdm_trial_sure_amt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_sure_amt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_sure_amt.tStop = t  # not accounting for scr refresh
                        crdm_trial_sure_amt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_sure_amt.status = FINISHED
                        crdm_trial_sure_amt.setAutoDraw(False)
                
                # *GRFX_fix* updates
                
                # if GRFX_fix is starting this frame...
                if GRFX_fix.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix.frameNStart = frameN  # exact frame index
                    GRFX_fix.tStart = t  # local t and not account for scr refresh
                    GRFX_fix.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix.status = STARTED
                    GRFX_fix.setAutoDraw(True)
                
                # if GRFX_fix is active this frame...
                if GRFX_fix.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix is stopping this frame...
                if GRFX_fix.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix.tStop = t  # not accounting for scr refresh
                        GRFX_fix.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix.status = FINISHED
                        GRFX_fix.setAutoDraw(False)
                
                # *crdm_trial_cue* updates
                
                # if crdm_trial_cue is starting this frame...
                if crdm_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_cue.frameNStart = frameN  # exact frame index
                    crdm_trial_cue.tStart = t  # local t and not account for scr refresh
                    crdm_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trial_cue.started')
                    # update status
                    crdm_trial_cue.status = STARTED
                    crdm_trial_cue.setAutoDraw(True)
                
                # if crdm_trial_cue is active this frame...
                if crdm_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trial_cue is stopping this frame...
                if crdm_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_cue.tStop = t  # not accounting for scr refresh
                        crdm_trial_cue.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trial_cue.stopped')
                        # update status
                        crdm_trial_cue.status = FINISHED
                        crdm_trial_cue.setAutoDraw(False)
                
                # *crdm_trial_resp* updates
                waitOnFlip = False
                
                # if crdm_trial_resp is starting this frame...
                if crdm_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trial_resp.frameNStart = frameN  # exact frame index
                    crdm_trial_resp.tStart = t  # local t and not account for scr refresh
                    crdm_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_trial_resp is stopping this frame...
                if crdm_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trial_resp.tStop = t  # not accounting for scr refresh
                        crdm_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_trial_resp.status = FINISHED
                        crdm_trial_resp.status = FINISHED
                if crdm_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_trial_resp_allKeys.extend(theseKeys)
                    if len(_crdm_trial_resp_allKeys):
                        crdm_trial_resp.keys = _crdm_trial_resp_allKeys[-1].name  # just the last key pressed
                        crdm_trial_resp.rt = _crdm_trial_resp_allKeys[-1].rt
                        crdm_trial_resp.duration = _crdm_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (crdm_trial_resp.keys == str(crdm_sure_resp)) or (crdm_trial_resp.keys == crdm_sure_resp):
                            crdm_trial_resp.corr = 1
                        else:
                            crdm_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_trial" ---
            for thisComponent in crdm_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_trial.stopped', globalClock.getTime())
            # check responses
            if crdm_trial_resp.keys in ['', [], None]:  # No response was made
                crdm_trial_resp.keys = None
                # was no response the correct answer?!
                if str(crdm_sure_resp).lower() == 'none':
                   crdm_trial_resp.corr = 1;  # correct non-response
                else:
                   crdm_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for crdm_trials2 (TrialHandler)
            crdm_trials2.addData('crdm_trial_resp.keys',crdm_trial_resp.keys)
            crdm_trials2.addData('crdm_trial_resp.corr', crdm_trial_resp.corr)
            if crdm_trial_resp.keys != None:  # we had a response
                crdm_trials2.addData('crdm_trial_resp.rt', crdm_trial_resp.rt)
                crdm_trials2.addData('crdm_trial_resp.duration', crdm_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "crdm_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_feedback_code
            if len(crdm_key) == 0: #Ss did not respond
                crdm_msg = "NO RESPONSE"
            elif crdm_sure_key: #Ss chose sure $5
                crdm_msg = "CERTAIN $" + str(format(crdm_sure_amt))
            else: #Ss chose lottery
                crdm_msg = "LOTTERY"
            crdm_feedback_txt.setText(crdm_msg)
            # keep track of which components have finished
            crdm_feedbackComponents = [crdm_feedback_txt]
            for thisComponent in crdm_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_feedback_txt* updates
                
                # if crdm_feedback_txt is starting this frame...
                if crdm_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_feedback_txt.frameNStart = frameN  # exact frame index
                    crdm_feedback_txt.tStart = t  # local t and not account for scr refresh
                    crdm_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_feedback_txt.status = STARTED
                    crdm_feedback_txt.setAutoDraw(True)
                
                # if crdm_feedback_txt is active this frame...
                if crdm_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_feedback_txt is stopping this frame...
                if crdm_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_feedback_txt.tStop = t  # not accounting for scr refresh
                        crdm_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_feedback_txt.status = FINISHED
                        crdm_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_feedback" ---
            for thisComponent in crdm_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "crdm_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_conf_code
            if len(crdm_key) == 0: #Ss did not respond
                continueRoutine = False #do not run conf routine
            
            #set default gray for all four response boxes
            conf1_color = [0, 0, 0] 
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            crdm_conf_resp.keys = []
            crdm_conf_resp.rt = []
            _crdm_conf_resp_allKeys = []
            # keep track of which components have finished
            crdm_confComponents = [crdm_conf_txt, crdm_conf1, crdm_conf1_txt, crdm_conf2, crdm_conf2_txt, crdm_conf3, crdm_conf3_txt, crdm_conf4, crdm_conf4_txt, crdm_conf_resp]
            for thisComponent in crdm_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from crdm_conf_code
                crdm_conf_key = crdm_conf_resp.keys
                if len(crdm_conf_key) == 1: #Ss responded
                    if crdm_conf_key == "1": #not at all confident
                        #change box color to indicate selection
                        conf1_color = "darkgray" 
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "2": #less confident
                        conf1_color = [0,0,0]
                        conf2_color = "darkgray"
                        conf3_color = [0,0,0]
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "3": #somewhat confident
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = "darkgray"
                        conf4_color = [0,0,0]
                    elif crdm_conf_key == "4": #very confident
                        conf1_color = [0,0,0]
                        conf2_color = [0,0,0]
                        conf3_color = [0,0,0]
                        conf4_color = "darkgray"
                
                # *crdm_conf_txt* updates
                
                # if crdm_conf_txt is starting this frame...
                if crdm_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf_txt.frameNStart = frameN  # exact frame index
                    crdm_conf_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf_txt.status = STARTED
                    crdm_conf_txt.setAutoDraw(True)
                
                # if crdm_conf_txt is active this frame...
                if crdm_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf_txt is stopping this frame...
                if crdm_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf_txt.status = FINISHED
                        crdm_conf_txt.setAutoDraw(False)
                
                # *crdm_conf1* updates
                
                # if crdm_conf1 is starting this frame...
                if crdm_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf1.frameNStart = frameN  # exact frame index
                    crdm_conf1.tStart = t  # local t and not account for scr refresh
                    crdm_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf1.status = STARTED
                    crdm_conf1.setAutoDraw(True)
                
                # if crdm_conf1 is active this frame...
                if crdm_conf1.status == STARTED:
                    # update params
                    crdm_conf1.setFillColor(conf1_color, log=False)
                
                # if crdm_conf1 is stopping this frame...
                if crdm_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf1.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf1.tStop = t  # not accounting for scr refresh
                        crdm_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf1.status = FINISHED
                        crdm_conf1.setAutoDraw(False)
                
                # *crdm_conf1_txt* updates
                
                # if crdm_conf1_txt is starting this frame...
                if crdm_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf1_txt.frameNStart = frameN  # exact frame index
                    crdm_conf1_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf1_txt.status = STARTED
                    crdm_conf1_txt.setAutoDraw(True)
                
                # if crdm_conf1_txt is active this frame...
                if crdm_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf1_txt is stopping this frame...
                if crdm_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf1_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf1_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf1_txt.status = FINISHED
                        crdm_conf1_txt.setAutoDraw(False)
                
                # *crdm_conf2* updates
                
                # if crdm_conf2 is starting this frame...
                if crdm_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf2.frameNStart = frameN  # exact frame index
                    crdm_conf2.tStart = t  # local t and not account for scr refresh
                    crdm_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf2.status = STARTED
                    crdm_conf2.setAutoDraw(True)
                
                # if crdm_conf2 is active this frame...
                if crdm_conf2.status == STARTED:
                    # update params
                    crdm_conf2.setFillColor(conf2_color, log=False)
                
                # if crdm_conf2 is stopping this frame...
                if crdm_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf2.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf2.tStop = t  # not accounting for scr refresh
                        crdm_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf2.status = FINISHED
                        crdm_conf2.setAutoDraw(False)
                
                # *crdm_conf2_txt* updates
                
                # if crdm_conf2_txt is starting this frame...
                if crdm_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf2_txt.frameNStart = frameN  # exact frame index
                    crdm_conf2_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf2_txt.status = STARTED
                    crdm_conf2_txt.setAutoDraw(True)
                
                # if crdm_conf2_txt is active this frame...
                if crdm_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf2_txt is stopping this frame...
                if crdm_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf2_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf2_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf2_txt.status = FINISHED
                        crdm_conf2_txt.setAutoDraw(False)
                
                # *crdm_conf3* updates
                
                # if crdm_conf3 is starting this frame...
                if crdm_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf3.frameNStart = frameN  # exact frame index
                    crdm_conf3.tStart = t  # local t and not account for scr refresh
                    crdm_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf3.status = STARTED
                    crdm_conf3.setAutoDraw(True)
                
                # if crdm_conf3 is active this frame...
                if crdm_conf3.status == STARTED:
                    # update params
                    crdm_conf3.setFillColor(conf3_color, log=False)
                
                # if crdm_conf3 is stopping this frame...
                if crdm_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf3.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf3.tStop = t  # not accounting for scr refresh
                        crdm_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf3.status = FINISHED
                        crdm_conf3.setAutoDraw(False)
                
                # *crdm_conf3_txt* updates
                
                # if crdm_conf3_txt is starting this frame...
                if crdm_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf3_txt.frameNStart = frameN  # exact frame index
                    crdm_conf3_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf3_txt.status = STARTED
                    crdm_conf3_txt.setAutoDraw(True)
                
                # if crdm_conf3_txt is active this frame...
                if crdm_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf3_txt is stopping this frame...
                if crdm_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf3_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf3_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf3_txt.status = FINISHED
                        crdm_conf3_txt.setAutoDraw(False)
                
                # *crdm_conf4* updates
                
                # if crdm_conf4 is starting this frame...
                if crdm_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf4.frameNStart = frameN  # exact frame index
                    crdm_conf4.tStart = t  # local t and not account for scr refresh
                    crdm_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf4.status = STARTED
                    crdm_conf4.setAutoDraw(True)
                
                # if crdm_conf4 is active this frame...
                if crdm_conf4.status == STARTED:
                    # update params
                    crdm_conf4.setFillColor(conf4_color, log=False)
                
                # if crdm_conf4 is stopping this frame...
                if crdm_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf4.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf4.tStop = t  # not accounting for scr refresh
                        crdm_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf4.status = FINISHED
                        crdm_conf4.setAutoDraw(False)
                
                # *crdm_conf4_txt* updates
                
                # if crdm_conf4_txt is starting this frame...
                if crdm_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf4_txt.frameNStart = frameN  # exact frame index
                    crdm_conf4_txt.tStart = t  # local t and not account for scr refresh
                    crdm_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf4_txt.status = STARTED
                    crdm_conf4_txt.setAutoDraw(True)
                
                # if crdm_conf4_txt is active this frame...
                if crdm_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if crdm_conf4_txt is stopping this frame...
                if crdm_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf4_txt.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf4_txt.tStop = t  # not accounting for scr refresh
                        crdm_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf4_txt.status = FINISHED
                        crdm_conf4_txt.setAutoDraw(False)
                
                # *crdm_conf_resp* updates
                waitOnFlip = False
                
                # if crdm_conf_resp is starting this frame...
                if crdm_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_conf_resp.frameNStart = frameN  # exact frame index
                    crdm_conf_resp.tStart = t  # local t and not account for scr refresh
                    crdm_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    crdm_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(crdm_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(crdm_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if crdm_conf_resp is stopping this frame...
                if crdm_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_conf_resp.tStartRefresh + 2.5-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_conf_resp.tStop = t  # not accounting for scr refresh
                        crdm_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        crdm_conf_resp.status = FINISHED
                        crdm_conf_resp.status = FINISHED
                if crdm_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = crdm_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _crdm_conf_resp_allKeys.extend(theseKeys)
                    if len(_crdm_conf_resp_allKeys):
                        crdm_conf_resp.keys = _crdm_conf_resp_allKeys[-1].name  # just the last key pressed
                        crdm_conf_resp.rt = _crdm_conf_resp_allKeys[-1].rt
                        crdm_conf_resp.duration = _crdm_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_conf" ---
            for thisComponent in crdm_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_conf.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_conf_code
            my_loop.addData("crdm_conf", crdm_conf_key);
            # check responses
            if crdm_conf_resp.keys in ['', [], None]:  # No response was made
                crdm_conf_resp.keys = None
            crdm_trials2.addData('crdm_conf_resp.keys',crdm_conf_resp.keys)
            if crdm_conf_resp.keys != None:  # we had a response
                crdm_trials2.addData('crdm_conf_resp.rt', crdm_conf_resp.rt)
                crdm_trials2.addData('crdm_conf_resp.duration', crdm_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.500000)
            
            # --- Prepare to start Routine "crdm_trials_iti2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('crdm_trials_iti2.started', globalClock.getTime())
            # Run 'Begin Routine' code from crdm_trials_iti2_code
            #variable ITI for non-practice trials
            iti_time = iti_list[my_loop.thisIndex] + delta_time
            
            if crdm_pract_trials2.thisTrialN == 79:
                continueRoutine = False
            # keep track of which components have finished
            crdm_trials_iti2Components = [crdm_trials_iti2_poly]
            for thisComponent in crdm_trials_iti2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "crdm_trials_iti2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *crdm_trials_iti2_poly* updates
                
                # if crdm_trials_iti2_poly is starting this frame...
                if crdm_trials_iti2_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    crdm_trials_iti2_poly.frameNStart = frameN  # exact frame index
                    crdm_trials_iti2_poly.tStart = t  # local t and not account for scr refresh
                    crdm_trials_iti2_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(crdm_trials_iti2_poly, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'crdm_trials_iti2_poly.started')
                    # update status
                    crdm_trials_iti2_poly.status = STARTED
                    crdm_trials_iti2_poly.setAutoDraw(True)
                
                # if crdm_trials_iti2_poly is active this frame...
                if crdm_trials_iti2_poly.status == STARTED:
                    # update params
                    pass
                
                # if crdm_trials_iti2_poly is stopping this frame...
                if crdm_trials_iti2_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > crdm_trials_iti2_poly.tStartRefresh + crdm_iti_time-frameTolerance:
                        # keep track of stop time/frame for later
                        crdm_trials_iti2_poly.tStop = t  # not accounting for scr refresh
                        crdm_trials_iti2_poly.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'crdm_trials_iti2_poly.stopped')
                        # update status
                        crdm_trials_iti2_poly.status = FINISHED
                        crdm_trials_iti2_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in crdm_trials_iti2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "crdm_trials_iti2" ---
            for thisComponent in crdm_trials_iti2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('crdm_trials_iti2.stopped', globalClock.getTime())
            # Run 'End Routine' code from crdm_trials_iti2_code
            #record delta time
            my_loop.addData("crdm_delta_time", delta_time) 
            #record iti time
            my_loop.addData("crdm_iti_time", iti_time) 
            # the Routine "crdm_trials_iti2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'crdm_trials2'
        
        
        # --- Prepare to start Routine "crdm_end" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('crdm_end.started', globalClock.getTime())
        # Run 'Begin Routine' code from crdm_end_code
        crdm_unique_resps = []
        crdm_unique_count = 0
        for i in crdm_task_resps:
            if i not in crdm_unique_resps:
                crdm_unique_count += 1
                crdm_unique_resps.append(i)
        
        crdm_task_end_text = ""
        crdm_space_text = ""
        #filter for nonresponses
        if len(crdm_task_resps) < 68 or len(crdm_conf_resps) < 68: #95% of 72 CRDM trials
            if len(crdm_task_resps) < 68:
                crdm_task_end_text = "You failed to respond to " + str(72-len(crdm_task_resps)) + " task trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close."
            if len(crdm_conf_resps) < 68:
                crdm_task_end_text = "You failed to respond to both parts of " + str(72-len(crdm_conf_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close."
            crdm_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("crdm_subReject1", "< 95% resp rate")
            my_loop.addData("crdm_subReject1_nonresps-task", 72-len(crdm_task_resps))
            my_loop.addData("crdm_subReject1_nonresps-conf", 72-len(crdm_conf_resps))
        #filter for single-button responses
        elif crdm_unique_count < 2: #same for each exp
            crdm_task_end_text = "You provided the same response to all " + str(len(crdm_task_resps)) + " trials. \n \n You did not follow task instructions. \n \n The Risk & Ambiguity Task will now close."
            crdm_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("crdm_subReject2", "1key response")
            my_loop.addData("crdm_subReject2_key", crdm_task_resps[0])
        #filter for poor performance on CRDM catch trials (10/20 catch trials -- 0.097% of random success on 10 trials)
        #elif sum(crdm_catch_trials) < 10: 
            #crdm_task_end_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The Risk & Ambiguity Task will now close."
            #crdm_space_text = "Press SPACE to end."
            #exp_proceed = False
            #my_loop.addData("crdm_subReject3", "catch fail")
            #my_loop.addData("crdm_subReject3_fails", 20-sum(crdm_catch_trials))
        #all CRDM task trial criterion are met
        else:
            crdm_task_end_text = "You have completed the Risk & Ambiguity Task!"
            crdm_space_text = "Press SPACE to continue."
        crdm_end_txt_ON.setText(crdm_task_end_text)
        crdm_end_space_ON.setText(crdm_space_text)
        crdm_end_resp.keys = []
        crdm_end_resp.rt = []
        _crdm_end_resp_allKeys = []
        # keep track of which components have finished
        crdm_endComponents = [crdm_end_title_txt, crdm_end_txt_ON, crdm_end_space_ON, crdm_end_resp]
        for thisComponent in crdm_endComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "crdm_end" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *crdm_end_title_txt* updates
            
            # if crdm_end_title_txt is starting this frame...
            if crdm_end_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_title_txt.frameNStart = frameN  # exact frame index
                crdm_end_title_txt.tStart = t  # local t and not account for scr refresh
                crdm_end_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_title_txt.status = STARTED
                crdm_end_title_txt.setAutoDraw(True)
            
            # if crdm_end_title_txt is active this frame...
            if crdm_end_title_txt.status == STARTED:
                # update params
                pass
            
            # *crdm_end_txt_ON* updates
            
            # if crdm_end_txt_ON is starting this frame...
            if crdm_end_txt_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_txt_ON.frameNStart = frameN  # exact frame index
                crdm_end_txt_ON.tStart = t  # local t and not account for scr refresh
                crdm_end_txt_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_txt_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_txt_ON.status = STARTED
                crdm_end_txt_ON.setAutoDraw(True)
            
            # if crdm_end_txt_ON is active this frame...
            if crdm_end_txt_ON.status == STARTED:
                # update params
                pass
            
            # *crdm_end_space_ON* updates
            
            # if crdm_end_space_ON is starting this frame...
            if crdm_end_space_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_space_ON.frameNStart = frameN  # exact frame index
                crdm_end_space_ON.tStart = t  # local t and not account for scr refresh
                crdm_end_space_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_space_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_space_ON.status = STARTED
                crdm_end_space_ON.setAutoDraw(True)
            
            # if crdm_end_space_ON is active this frame...
            if crdm_end_space_ON.status == STARTED:
                # update params
                pass
            
            # *crdm_end_resp* updates
            waitOnFlip = False
            
            # if crdm_end_resp is starting this frame...
            if crdm_end_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                crdm_end_resp.frameNStart = frameN  # exact frame index
                crdm_end_resp.tStart = t  # local t and not account for scr refresh
                crdm_end_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(crdm_end_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                crdm_end_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(crdm_end_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(crdm_end_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if crdm_end_resp.status == STARTED and not waitOnFlip:
                theseKeys = crdm_end_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _crdm_end_resp_allKeys.extend(theseKeys)
                if len(_crdm_end_resp_allKeys):
                    crdm_end_resp.keys = _crdm_end_resp_allKeys[-1].name  # just the last key pressed
                    crdm_end_resp.rt = _crdm_end_resp_allKeys[-1].rt
                    crdm_end_resp.duration = _crdm_end_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in crdm_endComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "crdm_end" ---
        for thisComponent in crdm_endComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('crdm_end.stopped', globalClock.getTime())
        # the Routine "crdm_end" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "idm_term_check" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_term_check.started', globalClock.getTime())
        # Run 'Begin Routine' code from idm_term_check_code
        if exp_proceed == False:
            core.quit()
        # keep track of which components have finished
        idm_term_checkComponents = []
        for thisComponent in idm_term_checkComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_term_check" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_term_check" ---
        for thisComponent in idm_term_checkComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_term_check.stopped', globalClock.getTime())
        # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
    # completed loop5 repeats of 'should_run5'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run6 = data.TrialHandler(nReps=loop6, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run6')
    thisExp.addLoop(should_run6)  # add the loop to the experiment
    thisShould_run6 = should_run6.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run6.rgb)
    if thisShould_run6 != None:
        for paramName in thisShould_run6:
            globals()[paramName] = thisShould_run6[paramName]
    
    for thisShould_run6 in should_run6:
        currentLoop = should_run6
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run6.rgb)
        if thisShould_run6 != None:
            for paramName in thisShould_run6:
                globals()[paramName] = thisShould_run6[paramName]
        
        # --- Prepare to start Routine "cdd_namer2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_namer2.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_namer2_code
        #provides specific loop names for each of two interations of DD
        #to provide flexibility of cdd_pract_trial and cdd_trial routines
        cdd_practice_loop1_name = "cdd_pract1_trials2"
        cdd_questplus_loop_name = "cdd_qp_trials2"
        cdd_practice_loop2_name = "cdd_pract2_trials2"
        cdd_loop_name = "cdd_trials2"
        # keep track of which components have finished
        cdd_namer2Components = []
        for thisComponent in cdd_namer2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_namer2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_namer2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_namer2" ---
        for thisComponent in cdd_namer2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_namer2.stopped', globalClock.getTime())
        # the Routine "cdd_namer2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr1.started', globalClock.getTime())
        cdd_instr1_resp.keys = []
        cdd_instr1_resp.rt = []
        _cdd_instr1_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr1Components = [cdd_instr1_title_txt, cdd_instr1_txt, cdd_instr1_space_txt, cdd_instr1_resp]
        for thisComponent in cdd_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr1_title_txt* updates
            
            # if cdd_instr1_title_txt is starting this frame...
            if cdd_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_title_txt.status = STARTED
                cdd_instr1_title_txt.setAutoDraw(True)
            
            # if cdd_instr1_title_txt is active this frame...
            if cdd_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_txt* updates
            
            # if cdd_instr1_txt is starting this frame...
            if cdd_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_txt.status = STARTED
                cdd_instr1_txt.setAutoDraw(True)
            
            # if cdd_instr1_txt is active this frame...
            if cdd_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_space_txt* updates
            
            # if cdd_instr1_space_txt is starting this frame...
            if cdd_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_space_txt.status = STARTED
                cdd_instr1_space_txt.setAutoDraw(True)
            
            # if cdd_instr1_space_txt is active this frame...
            if cdd_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr1_resp* updates
            waitOnFlip = False
            
            # if cdd_instr1_resp is starting this frame...
            if cdd_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr1_resp.frameNStart = frameN  # exact frame index
                cdd_instr1_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr1_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr1_resp_allKeys):
                    cdd_instr1_resp.keys = _cdd_instr1_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr1_resp.rt = _cdd_instr1_resp_allKeys[-1].rt
                    cdd_instr1_resp.duration = _cdd_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr1" ---
        for thisComponent in cdd_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr1.stopped', globalClock.getTime())
        # the Routine "cdd_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr2.started', globalClock.getTime())
        cdd_instr2_resp.keys = []
        cdd_instr2_resp.rt = []
        _cdd_instr2_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr2Components = [cdd_instr2_title_txt, cdd_instr2_txt, cdd_instr2_img, cdd_instr2_space_txt, cdd_instr2_resp]
        for thisComponent in cdd_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr2_title_txt* updates
            
            # if cdd_instr2_title_txt is starting this frame...
            if cdd_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_title_txt.status = STARTED
                cdd_instr2_title_txt.setAutoDraw(True)
            
            # if cdd_instr2_title_txt is active this frame...
            if cdd_instr2_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_txt* updates
            
            # if cdd_instr2_txt is starting this frame...
            if cdd_instr2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_txt.status = STARTED
                cdd_instr2_txt.setAutoDraw(True)
            
            # if cdd_instr2_txt is active this frame...
            if cdd_instr2_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_img* updates
            
            # if cdd_instr2_img is starting this frame...
            if cdd_instr2_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_img.frameNStart = frameN  # exact frame index
                cdd_instr2_img.tStart = t  # local t and not account for scr refresh
                cdd_instr2_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_img.status = STARTED
                cdd_instr2_img.setAutoDraw(True)
            
            # if cdd_instr2_img is active this frame...
            if cdd_instr2_img.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_space_txt* updates
            
            # if cdd_instr2_space_txt is starting this frame...
            if cdd_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_space_txt.status = STARTED
                cdd_instr2_space_txt.setAutoDraw(True)
            
            # if cdd_instr2_space_txt is active this frame...
            if cdd_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr2_resp* updates
            waitOnFlip = False
            
            # if cdd_instr2_resp is starting this frame...
            if cdd_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr2_resp.frameNStart = frameN  # exact frame index
                cdd_instr2_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr2_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr2_resp_allKeys):
                    cdd_instr2_resp.keys = _cdd_instr2_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr2_resp.rt = _cdd_instr2_resp_allKeys[-1].rt
                    cdd_instr2_resp.duration = _cdd_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr2" ---
        for thisComponent in cdd_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr2.stopped', globalClock.getTime())
        # the Routine "cdd_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_instr3.started', globalClock.getTime())
        cdd_instr3_resp.keys = []
        cdd_instr3_resp.rt = []
        _cdd_instr3_resp_allKeys = []
        # keep track of which components have finished
        cdd_instr3Components = [cdd_instr3_title_txt, cdd_instr3_txt, cdd_instr3_img, cdd_instr3_space_txt, cdd_instr3_resp]
        for thisComponent in cdd_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_instr3_title_txt* updates
            
            # if cdd_instr3_title_txt is starting this frame...
            if cdd_instr3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_title_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_title_txt.status = STARTED
                cdd_instr3_title_txt.setAutoDraw(True)
            
            # if cdd_instr3_title_txt is active this frame...
            if cdd_instr3_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_txt* updates
            
            # if cdd_instr3_txt is starting this frame...
            if cdd_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_txt.status = STARTED
                cdd_instr3_txt.setAutoDraw(True)
            
            # if cdd_instr3_txt is active this frame...
            if cdd_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_img* updates
            
            # if cdd_instr3_img is starting this frame...
            if cdd_instr3_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_img.frameNStart = frameN  # exact frame index
                cdd_instr3_img.tStart = t  # local t and not account for scr refresh
                cdd_instr3_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_img.status = STARTED
                cdd_instr3_img.setAutoDraw(True)
            
            # if cdd_instr3_img is active this frame...
            if cdd_instr3_img.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_space_txt* updates
            
            # if cdd_instr3_space_txt is starting this frame...
            if cdd_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_space_txt.frameNStart = frameN  # exact frame index
                cdd_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_space_txt.status = STARTED
                cdd_instr3_space_txt.setAutoDraw(True)
            
            # if cdd_instr3_space_txt is active this frame...
            if cdd_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_instr3_resp* updates
            waitOnFlip = False
            
            # if cdd_instr3_resp is starting this frame...
            if cdd_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_instr3_resp.frameNStart = frameN  # exact frame index
                cdd_instr3_resp.tStart = t  # local t and not account for scr refresh
                cdd_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_instr3_resp_allKeys.extend(theseKeys)
                if len(_cdd_instr3_resp_allKeys):
                    cdd_instr3_resp.keys = _cdd_instr3_resp_allKeys[-1].name  # just the last key pressed
                    cdd_instr3_resp.rt = _cdd_instr3_resp_allKeys[-1].rt
                    cdd_instr3_resp.duration = _cdd_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_instr3" ---
        for thisComponent in cdd_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_instr3.stopped', globalClock.getTime())
        # the Routine "cdd_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_warn.started', globalClock.getTime())
        cdd_warn1_resp.keys = []
        cdd_warn1_resp.rt = []
        _cdd_warn1_resp_allKeys = []
        # keep track of which components have finished
        cdd_warnComponents = [cdd_warn1_title_txt, cdd_warn1_txt, cdd_warn1_space_txt, cdd_warn1_resp]
        for thisComponent in cdd_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_warn1_title_txt* updates
            
            # if cdd_warn1_title_txt is starting this frame...
            if cdd_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_title_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_title_txt.status = STARTED
                cdd_warn1_title_txt.setAutoDraw(True)
            
            # if cdd_warn1_title_txt is active this frame...
            if cdd_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_txt* updates
            
            # if cdd_warn1_txt is starting this frame...
            if cdd_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_txt.status = STARTED
                cdd_warn1_txt.setAutoDraw(True)
            
            # if cdd_warn1_txt is active this frame...
            if cdd_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_space_txt* updates
            
            # if cdd_warn1_space_txt is starting this frame...
            if cdd_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_space_txt.frameNStart = frameN  # exact frame index
                cdd_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_space_txt.status = STARTED
                cdd_warn1_space_txt.setAutoDraw(True)
            
            # if cdd_warn1_space_txt is active this frame...
            if cdd_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_warn1_resp* updates
            waitOnFlip = False
            
            # if cdd_warn1_resp is starting this frame...
            if cdd_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_warn1_resp.frameNStart = frameN  # exact frame index
                cdd_warn1_resp.tStart = t  # local t and not account for scr refresh
                cdd_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_warn1_resp_allKeys.extend(theseKeys)
                if len(_cdd_warn1_resp_allKeys):
                    cdd_warn1_resp.keys = _cdd_warn1_resp_allKeys[-1].name  # just the last key pressed
                    cdd_warn1_resp.rt = _cdd_warn1_resp_allKeys[-1].rt
                    cdd_warn1_resp.duration = _cdd_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_warn" ---
        for thisComponent in cdd_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_warn.stopped', globalClock.getTime())
        # the Routine "cdd_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_pract1_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_pract1_instr.started', globalClock.getTime())
        cdd_pract1_instr_resp.keys = []
        cdd_pract1_instr_resp.rt = []
        _cdd_pract1_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_pract1_instrComponents = [cdd_pract1_instr_left_poly, cdd_pract1_instr_right_poly, cdd_pract1_instr_txt, cdd_pract1_instr_immed_txt, cdd_pract1_instr_delay_txt, cdd_pract1_instr_or_txt, cdd_pract1_instr_space_txt, cdd_pract1_instr_resp]
        for thisComponent in cdd_pract1_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_pract1_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_pract1_instr_left_poly* updates
            
            # if cdd_pract1_instr_left_poly is starting this frame...
            if cdd_pract1_instr_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_left_poly.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_left_poly.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_left_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_left_poly.status = STARTED
                cdd_pract1_instr_left_poly.setAutoDraw(True)
            
            # if cdd_pract1_instr_left_poly is active this frame...
            if cdd_pract1_instr_left_poly.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_right_poly* updates
            
            # if cdd_pract1_instr_right_poly is starting this frame...
            if cdd_pract1_instr_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_right_poly.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_right_poly.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_right_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_right_poly.status = STARTED
                cdd_pract1_instr_right_poly.setAutoDraw(True)
            
            # if cdd_pract1_instr_right_poly is active this frame...
            if cdd_pract1_instr_right_poly.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_txt* updates
            
            # if cdd_pract1_instr_txt is starting this frame...
            if cdd_pract1_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_txt.status = STARTED
                cdd_pract1_instr_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_txt is active this frame...
            if cdd_pract1_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_immed_txt* updates
            
            # if cdd_pract1_instr_immed_txt is starting this frame...
            if cdd_pract1_instr_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_immed_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_immed_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_immed_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_immed_txt.status = STARTED
                cdd_pract1_instr_immed_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_immed_txt is active this frame...
            if cdd_pract1_instr_immed_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_delay_txt* updates
            
            # if cdd_pract1_instr_delay_txt is starting this frame...
            if cdd_pract1_instr_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_delay_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_delay_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_delay_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_delay_txt.status = STARTED
                cdd_pract1_instr_delay_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_delay_txt is active this frame...
            if cdd_pract1_instr_delay_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_or_txt* updates
            
            # if cdd_pract1_instr_or_txt is starting this frame...
            if cdd_pract1_instr_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_or_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_or_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_or_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_or_txt.status = STARTED
                cdd_pract1_instr_or_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_or_txt is active this frame...
            if cdd_pract1_instr_or_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_space_txt* updates
            
            # if cdd_pract1_instr_space_txt is starting this frame...
            if cdd_pract1_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_space_txt.status = STARTED
                cdd_pract1_instr_space_txt.setAutoDraw(True)
            
            # if cdd_pract1_instr_space_txt is active this frame...
            if cdd_pract1_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract1_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_pract1_instr_resp is starting this frame...
            if cdd_pract1_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract1_instr_resp.frameNStart = frameN  # exact frame index
                cdd_pract1_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_pract1_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract1_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract1_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_pract1_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_pract1_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_pract1_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_pract1_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_pract1_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_pract1_instr_resp_allKeys):
                    cdd_pract1_instr_resp.keys = _cdd_pract1_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_pract1_instr_resp.rt = _cdd_pract1_instr_resp_allKeys[-1].rt
                    cdd_pract1_instr_resp.duration = _cdd_pract1_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_pract1_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_pract1_instr" ---
        for thisComponent in cdd_pract1_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_pract1_instr.stopped', globalClock.getTime())
        # the Routine "cdd_pract1_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_pract1_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_practice1.csv'),
            seed=None, name='cdd_pract1_trials2')
        thisExp.addLoop(cdd_pract1_trials2)  # add the loop to the experiment
        thisCdd_pract1_trials2 = cdd_pract1_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract1_trials2.rgb)
        if thisCdd_pract1_trials2 != None:
            for paramName in thisCdd_pract1_trials2:
                globals()[paramName] = thisCdd_pract1_trials2[paramName]
        
        for thisCdd_pract1_trials2 in cdd_pract1_trials2:
            currentLoop = cdd_pract1_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract1_trials2.rgb)
            if thisCdd_pract1_trials2 != None:
                for paramName in thisCdd_pract1_trials2:
                    globals()[paramName] = thisCdd_pract1_trials2[paramName]
            
            # --- Prepare to start Routine "cdd_pract1_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract1_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract1_trial_code
            my_loop = eval(cdd_practice_loop1_name) 
            cdd_idx1 = random.randint(0,1) #random selection of position and resp key
            cdd_immed_pos1 = cdd_pos1[cdd_idx1]
            cdd_immed_resp1 = cdd_resp1[cdd_idx1]
            
            if cdd_idx1 == 0: 
                #delay is right
                cdd_delay_pos1 = cdd_pos1[1] 
                #immed is right side
            else: 
                #delay is left
                cdd_delay_pos1 = cdd_pos1[0] 
            cdd_pract1_trial_immed_txt.setPos(cdd_immed_pos1)
            cdd_pract1_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt1))) + "\n" + "\n" + " TODAY")
            cdd_pract1_trial_delay_txt.setPos(cdd_delay_pos1)
            cdd_pract1_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt1))) + "\n" + "\n" + str(cdd_delay_wait1) + " DAYS")
            cdd_pract1_trial_resp.keys = []
            cdd_pract1_trial_resp.rt = []
            _cdd_pract1_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract1_trialComponents = [cdd_pract1_trial_left_poly, cdd_pract1_trial_right_poly, cdd_pract1_trial_prompt_txt, cdd_pract1_trial_immed_txt, cdd_pract1_trial_or_txt, cdd_pract1_trial_delay_txt, cdd_pract1_trial_cue, cdd_pract1_trial_resp]
            for thisComponent in cdd_pract1_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract1_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract1_trial_left_poly* updates
                
                # if cdd_pract1_trial_left_poly is starting this frame...
                if cdd_pract1_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_left_poly.status = STARTED
                    cdd_pract1_trial_left_poly.setAutoDraw(True)
                
                # if cdd_pract1_trial_left_poly is active this frame...
                if cdd_pract1_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_left_poly is stopping this frame...
                if cdd_pract1_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_left_poly.status = FINISHED
                        cdd_pract1_trial_left_poly.setAutoDraw(False)
                
                # *cdd_pract1_trial_right_poly* updates
                
                # if cdd_pract1_trial_right_poly is starting this frame...
                if cdd_pract1_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_right_poly.status = STARTED
                    cdd_pract1_trial_right_poly.setAutoDraw(True)
                
                # if cdd_pract1_trial_right_poly is active this frame...
                if cdd_pract1_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_right_poly is stopping this frame...
                if cdd_pract1_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_right_poly.status = FINISHED
                        cdd_pract1_trial_right_poly.setAutoDraw(False)
                
                # *cdd_pract1_trial_prompt_txt* updates
                
                # if cdd_pract1_trial_prompt_txt is starting this frame...
                if cdd_pract1_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_prompt_txt.status = STARTED
                    cdd_pract1_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_prompt_txt is active this frame...
                if cdd_pract1_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_prompt_txt is stopping this frame...
                if cdd_pract1_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_prompt_txt.status = FINISHED
                        cdd_pract1_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_immed_txt* updates
                
                # if cdd_pract1_trial_immed_txt is starting this frame...
                if cdd_pract1_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_immed_txt.status = STARTED
                    cdd_pract1_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_immed_txt is active this frame...
                if cdd_pract1_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_immed_txt is stopping this frame...
                if cdd_pract1_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_immed_txt.status = FINISHED
                        cdd_pract1_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_or_txt* updates
                
                # if cdd_pract1_trial_or_txt is starting this frame...
                if cdd_pract1_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_or_txt.status = STARTED
                    cdd_pract1_trial_or_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_or_txt is active this frame...
                if cdd_pract1_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_or_txt is stopping this frame...
                if cdd_pract1_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_or_txt.status = FINISHED
                        cdd_pract1_trial_or_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_delay_txt* updates
                
                # if cdd_pract1_trial_delay_txt is starting this frame...
                if cdd_pract1_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_delay_txt.status = STARTED
                    cdd_pract1_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_pract1_trial_delay_txt is active this frame...
                if cdd_pract1_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_delay_txt is stopping this frame...
                if cdd_pract1_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_delay_txt.status = FINISHED
                        cdd_pract1_trial_delay_txt.setAutoDraw(False)
                
                # *cdd_pract1_trial_cue* updates
                
                # if cdd_pract1_trial_cue is starting this frame...
                if cdd_pract1_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_cue.status = STARTED
                    cdd_pract1_trial_cue.setAutoDraw(True)
                
                # if cdd_pract1_trial_cue is active this frame...
                if cdd_pract1_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_trial_cue is stopping this frame...
                if cdd_pract1_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_cue.status = FINISHED
                        cdd_pract1_trial_cue.setAutoDraw(False)
                
                # *cdd_pract1_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_pract1_trial_resp is starting this frame...
                if cdd_pract1_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_pract1_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract1_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract1_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract1_trial_resp is stopping this frame...
                if cdd_pract1_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract1_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_trial_resp.status = FINISHED
                        cdd_pract1_trial_resp.status = FINISHED
                if cdd_pract1_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract1_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract1_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract1_trial_resp_allKeys):
                        cdd_pract1_trial_resp.keys = _cdd_pract1_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract1_trial_resp.rt = _cdd_pract1_trial_resp_allKeys[-1].rt
                        cdd_pract1_trial_resp.duration = _cdd_pract1_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_pract1_trial_resp.keys == str(cdd_immed_resp1)) or (cdd_pract1_trial_resp.keys == cdd_immed_resp1):
                            cdd_pract1_trial_resp.corr = 1
                        else:
                            cdd_pract1_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract1_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract1_trial" ---
            for thisComponent in cdd_pract1_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract1_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_pract1_trial_code
            cdd_pract1_key = cdd_pract1_trial_resp.keys #Ss response key
            cdd_pract1_immed_key = cdd_pract1_trial_resp.corr #1 when immediate amt is chosen
            my_loop.addData("cdd_trial_type", "practice1")
            # check responses
            if cdd_pract1_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_pract1_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp1).lower() == 'none':
                   cdd_pract1_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_pract1_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_pract1_trials2 (TrialHandler)
            cdd_pract1_trials2.addData('cdd_pract1_trial_resp.keys',cdd_pract1_trial_resp.keys)
            cdd_pract1_trials2.addData('cdd_pract1_trial_resp.corr', cdd_pract1_trial_resp.corr)
            if cdd_pract1_trial_resp.keys != None:  # we had a response
                cdd_pract1_trials2.addData('cdd_pract1_trial_resp.rt', cdd_pract1_trial_resp.rt)
                cdd_pract1_trials2.addData('cdd_pract1_trial_resp.duration', cdd_pract1_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_pract1_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract1_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract1_feedback_py
            if len(cdd_pract1_key) == 0: #Ss did not respond 
                cdd_msg1 = "NO RESPONSE"
            elif cdd_pract1_immed_key: #Ss chose smaller, immediate option
                cdd_msg1 = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg1 = "$ LATER"
            cdd_pract1_feedback_txt.setText(cdd_msg1)
            # keep track of which components have finished
            cdd_pract1_feedbackComponents = [cdd_pract1_feedback_txt]
            for thisComponent in cdd_pract1_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract1_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract1_feedback_txt* updates
                
                # if cdd_pract1_feedback_txt is starting this frame...
                if cdd_pract1_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract1_feedback_txt.frameNStart = frameN  # exact frame index
                    cdd_pract1_feedback_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract1_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract1_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract1_feedback_txt.status = STARTED
                    cdd_pract1_feedback_txt.setAutoDraw(True)
                
                # if cdd_pract1_feedback_txt is active this frame...
                if cdd_pract1_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract1_feedback_txt is stopping this frame...
                if cdd_pract1_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract1_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract1_feedback_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract1_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract1_feedback_txt.status = FINISHED
                        cdd_pract1_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract1_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract1_feedback" ---
            for thisComponent in cdd_pract1_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract1_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_pract1_trials2'
        
        
        # --- Prepare to start Routine "cdd_qp_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_qp_instr.started', globalClock.getTime())
        cdd_qp_instr_resp.keys = []
        cdd_qp_instr_resp.rt = []
        _cdd_qp_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_qp_instrComponents = [cdd_qp_instr_title_txt, cdd_qp_instr_txt, cdd_qp_instr_space_txt, cdd_qp_instr_resp]
        for thisComponent in cdd_qp_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_qp_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_qp_instr_title_txt* updates
            
            # if cdd_qp_instr_title_txt is starting this frame...
            if cdd_qp_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_title_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_title_txt.status = STARTED
                cdd_qp_instr_title_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_title_txt is active this frame...
            if cdd_qp_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_txt* updates
            
            # if cdd_qp_instr_txt is starting this frame...
            if cdd_qp_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_txt.status = STARTED
                cdd_qp_instr_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_txt is active this frame...
            if cdd_qp_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_space_txt* updates
            
            # if cdd_qp_instr_space_txt is starting this frame...
            if cdd_qp_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_qp_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_space_txt.status = STARTED
                cdd_qp_instr_space_txt.setAutoDraw(True)
            
            # if cdd_qp_instr_space_txt is active this frame...
            if cdd_qp_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_qp_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_qp_instr_resp is starting this frame...
            if cdd_qp_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_qp_instr_resp.frameNStart = frameN  # exact frame index
                cdd_qp_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_qp_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_qp_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_qp_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_qp_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_qp_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_qp_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_qp_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_qp_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_qp_instr_resp_allKeys):
                    cdd_qp_instr_resp.keys = _cdd_qp_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_qp_instr_resp.rt = _cdd_qp_instr_resp_allKeys[-1].rt
                    cdd_qp_instr_resp.duration = _cdd_qp_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_qp_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_qp_instr" ---
        for thisComponent in cdd_qp_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_qp_instr.stopped', globalClock.getTime())
        # the Routine "cdd_qp_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        cdd_qp_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_qp_trials.csv'),
            seed=None, name='cdd_qp_trials2')
        thisExp.addLoop(cdd_qp_trials2)  # add the loop to the experiment
        thisCdd_qp_trials2 = cdd_qp_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_qp_trials2.rgb)
        if thisCdd_qp_trials2 != None:
            for paramName in thisCdd_qp_trials2:
                globals()[paramName] = thisCdd_qp_trials2[paramName]
        
        for thisCdd_qp_trials2 in cdd_qp_trials2:
            currentLoop = cdd_qp_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_qp_trials2.rgb)
            if thisCdd_qp_trials2 != None:
                for paramName in thisCdd_qp_trials2:
                    globals()[paramName] = thisCdd_qp_trials2[paramName]
            
            # --- Prepare to start Routine "cdd_questplus" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_questplus.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_questplus_JS
            my_loop = eval(cdd_practice_loop_name);
            cdd_idx_qp = random.randint(0, 1);
            cdd_immed_pos_qp = cdd_pos_qp[cdd_idx_qp];
            cdd_immed_resp_qp = cdd_resp_qp[cdd_idx_qp];
            cdd_questplus_trial_immed_txt.setPos(cdd_immed_pos_qp)
            cdd_questplus_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt_qp))) + "\n" + "\n" + " TODAY")
            cdd_questplus_trial_delay_txt.setPos(cdd_delay_pos_qp)
            cdd_questplus_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt_qp))) + "\n" + "\n" + str(cdd_delay_wait_qp) + " DAYS")
            cdd_questplus_trial_resp.keys = []
            cdd_questplus_trial_resp.rt = []
            _cdd_questplus_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_questplusComponents = [cdd_questplus_trial_left_poly, cdd_questplus_trial_right_poly, cdd_questplus_trial_prompt_txt, cdd_questplus_trial_immed_txt, cdd_questplus_trial_or_txt, cdd_questplus_trial_delay_txt, GRFX_fix2_2, cdd_questplus_trial_cue, cdd_questplus_trial_resp]
            for thisComponent in cdd_questplusComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_questplus" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_questplus_trial_left_poly* updates
                
                # if cdd_questplus_trial_left_poly is starting this frame...
                if cdd_questplus_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_left_poly.status = STARTED
                    cdd_questplus_trial_left_poly.setAutoDraw(True)
                
                # if cdd_questplus_trial_left_poly is active this frame...
                if cdd_questplus_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_left_poly is stopping this frame...
                if cdd_questplus_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_left_poly.status = FINISHED
                        cdd_questplus_trial_left_poly.setAutoDraw(False)
                
                # *cdd_questplus_trial_right_poly* updates
                
                # if cdd_questplus_trial_right_poly is starting this frame...
                if cdd_questplus_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_right_poly.status = STARTED
                    cdd_questplus_trial_right_poly.setAutoDraw(True)
                
                # if cdd_questplus_trial_right_poly is active this frame...
                if cdd_questplus_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_right_poly is stopping this frame...
                if cdd_questplus_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_right_poly.status = FINISHED
                        cdd_questplus_trial_right_poly.setAutoDraw(False)
                
                # *cdd_questplus_trial_prompt_txt* updates
                
                # if cdd_questplus_trial_prompt_txt is starting this frame...
                if cdd_questplus_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_prompt_txt.status = STARTED
                    cdd_questplus_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_prompt_txt is active this frame...
                if cdd_questplus_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_prompt_txt is stopping this frame...
                if cdd_questplus_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_prompt_txt.status = FINISHED
                        cdd_questplus_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_immed_txt* updates
                
                # if cdd_questplus_trial_immed_txt is starting this frame...
                if cdd_questplus_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_immed_txt.status = STARTED
                    cdd_questplus_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_immed_txt is active this frame...
                if cdd_questplus_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_immed_txt is stopping this frame...
                if cdd_questplus_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_immed_txt.status = FINISHED
                        cdd_questplus_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_or_txt* updates
                
                # if cdd_questplus_trial_or_txt is starting this frame...
                if cdd_questplus_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_or_txt.status = STARTED
                    cdd_questplus_trial_or_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_or_txt is active this frame...
                if cdd_questplus_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_or_txt is stopping this frame...
                if cdd_questplus_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_or_txt.status = FINISHED
                        cdd_questplus_trial_or_txt.setAutoDraw(False)
                
                # *cdd_questplus_trial_delay_txt* updates
                
                # if cdd_questplus_trial_delay_txt is starting this frame...
                if cdd_questplus_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_delay_txt.status = STARTED
                    cdd_questplus_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_questplus_trial_delay_txt is active this frame...
                if cdd_questplus_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_delay_txt is stopping this frame...
                if cdd_questplus_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_delay_txt.status = FINISHED
                        cdd_questplus_trial_delay_txt.setAutoDraw(False)
                
                # *GRFX_fix2_2* updates
                
                # if GRFX_fix2_2 is starting this frame...
                if GRFX_fix2_2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix2_2.frameNStart = frameN  # exact frame index
                    GRFX_fix2_2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix2_2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix2_2.status = STARTED
                    GRFX_fix2_2.setAutoDraw(True)
                
                # if GRFX_fix2_2 is active this frame...
                if GRFX_fix2_2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix2_2 is stopping this frame...
                if GRFX_fix2_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix2_2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix2_2.tStop = t  # not accounting for scr refresh
                        GRFX_fix2_2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix2_2.status = FINISHED
                        GRFX_fix2_2.setAutoDraw(False)
                
                # *cdd_questplus_trial_cue* updates
                
                # if cdd_questplus_trial_cue is starting this frame...
                if cdd_questplus_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_cue.status = STARTED
                    cdd_questplus_trial_cue.setAutoDraw(True)
                
                # if cdd_questplus_trial_cue is active this frame...
                if cdd_questplus_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_questplus_trial_cue is stopping this frame...
                if cdd_questplus_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_cue.status = FINISHED
                        cdd_questplus_trial_cue.setAutoDraw(False)
                
                # *cdd_questplus_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_questplus_trial_resp is starting this frame...
                if cdd_questplus_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_questplus_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_questplus_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_questplus_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_questplus_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_questplus_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_questplus_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_questplus_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_questplus_trial_resp is stopping this frame...
                if cdd_questplus_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_questplus_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_questplus_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_questplus_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_questplus_trial_resp.status = FINISHED
                        cdd_questplus_trial_resp.status = FINISHED
                if cdd_questplus_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_questplus_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_questplus_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_questplus_trial_resp_allKeys):
                        cdd_questplus_trial_resp.keys = _cdd_questplus_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_questplus_trial_resp.rt = _cdd_questplus_trial_resp_allKeys[-1].rt
                        cdd_questplus_trial_resp.duration = _cdd_questplus_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_questplus_trial_resp.keys == str(cdd_immed_resp_qp)) or (cdd_questplus_trial_resp.keys == cdd_immed_resp_qp):
                            cdd_questplus_trial_resp.corr = 1
                        else:
                            cdd_questplus_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_questplusComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_questplus" ---
            for thisComponent in cdd_questplusComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_questplus.stopped', globalClock.getTime())
            # check responses
            if cdd_questplus_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_questplus_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp_qp).lower() == 'none':
                   cdd_questplus_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_questplus_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_qp_trials2 (TrialHandler)
            cdd_qp_trials2.addData('cdd_questplus_trial_resp.keys',cdd_questplus_trial_resp.keys)
            cdd_qp_trials2.addData('cdd_questplus_trial_resp.corr', cdd_questplus_trial_resp.corr)
            if cdd_questplus_trial_resp.keys != None:  # we had a response
                cdd_qp_trials2.addData('cdd_questplus_trial_resp.rt', cdd_questplus_trial_resp.rt)
                cdd_qp_trials2.addData('cdd_questplus_trial_resp.duration', cdd_questplus_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_questplus_fb" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_questplus_fb.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_questplus_fb_code
            if len(cdd_qp_key) == 0: #Ss did not respond
                cdd_msg_qp = "NO RESPONSE"
            elif cdd_qp_immed_key: #Ss chose smaller, immediate option
                cdd_msg_qp = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg_qp = "$ LATER"
            cdd_qp_fb_txt.setText(cdd_msg_qp)
            # keep track of which components have finished
            cdd_questplus_fbComponents = [cdd_qp_fb_txt]
            for thisComponent in cdd_questplus_fbComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_questplus_fb" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_qp_fb_txt* updates
                
                # if cdd_qp_fb_txt is starting this frame...
                if cdd_qp_fb_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_qp_fb_txt.frameNStart = frameN  # exact frame index
                    cdd_qp_fb_txt.tStart = t  # local t and not account for scr refresh
                    cdd_qp_fb_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_qp_fb_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_qp_fb_txt.status = STARTED
                    cdd_qp_fb_txt.setAutoDraw(True)
                
                # if cdd_qp_fb_txt is active this frame...
                if cdd_qp_fb_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_qp_fb_txt is stopping this frame...
                if cdd_qp_fb_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_qp_fb_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_qp_fb_txt.tStop = t  # not accounting for scr refresh
                        cdd_qp_fb_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_qp_fb_txt.status = FINISHED
                        cdd_qp_fb_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_questplus_fbComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_questplus_fb" ---
            for thisComponent in cdd_questplus_fbComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_questplus_fb.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_qp_trials2'
        
        
        # --- Prepare to start Routine "cdd_schedule_gen" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_schedule_gen.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_schedule_genComponents = []
        for thisComponent in cdd_schedule_genComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_schedule_gen" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_schedule_genComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_schedule_gen" ---
        for thisComponent in cdd_schedule_genComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_schedule_gen.stopped', globalClock.getTime())
        # the Routine "cdd_schedule_gen" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_pract2_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_pract2_instr.started', globalClock.getTime())
        cdd_pract_instr_resp_2.keys = []
        cdd_pract_instr_resp_2.rt = []
        _cdd_pract_instr_resp_2_allKeys = []
        # keep track of which components have finished
        cdd_pract2_instrComponents = [cdd_pract2_intr_name_txt, cdd_pract2_instr_txt, cdd_pract_instr_space_txt_2, cdd_pract_instr_resp_2]
        for thisComponent in cdd_pract2_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_pract2_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_pract2_intr_name_txt* updates
            
            # if cdd_pract2_intr_name_txt is starting this frame...
            if cdd_pract2_intr_name_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract2_intr_name_txt.frameNStart = frameN  # exact frame index
                cdd_pract2_intr_name_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract2_intr_name_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract2_intr_name_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract2_intr_name_txt.status = STARTED
                cdd_pract2_intr_name_txt.setAutoDraw(True)
            
            # if cdd_pract2_intr_name_txt is active this frame...
            if cdd_pract2_intr_name_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract2_instr_txt* updates
            
            # if cdd_pract2_instr_txt is starting this frame...
            if cdd_pract2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract2_instr_txt.frameNStart = frameN  # exact frame index
                cdd_pract2_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_pract2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract2_instr_txt.status = STARTED
                cdd_pract2_instr_txt.setAutoDraw(True)
            
            # if cdd_pract2_instr_txt is active this frame...
            if cdd_pract2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_pract_instr_space_txt_2* updates
            
            # if cdd_pract_instr_space_txt_2 is starting this frame...
            if cdd_pract_instr_space_txt_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract_instr_space_txt_2.frameNStart = frameN  # exact frame index
                cdd_pract_instr_space_txt_2.tStart = t  # local t and not account for scr refresh
                cdd_pract_instr_space_txt_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract_instr_space_txt_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract_instr_space_txt_2.status = STARTED
                cdd_pract_instr_space_txt_2.setAutoDraw(True)
            
            # if cdd_pract_instr_space_txt_2 is active this frame...
            if cdd_pract_instr_space_txt_2.status == STARTED:
                # update params
                pass
            
            # *cdd_pract_instr_resp_2* updates
            waitOnFlip = False
            
            # if cdd_pract_instr_resp_2 is starting this frame...
            if cdd_pract_instr_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_pract_instr_resp_2.frameNStart = frameN  # exact frame index
                cdd_pract_instr_resp_2.tStart = t  # local t and not account for scr refresh
                cdd_pract_instr_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_pract_instr_resp_2, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_pract_instr_resp_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_pract_instr_resp_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_pract_instr_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_pract_instr_resp_2.status == STARTED and not waitOnFlip:
                theseKeys = cdd_pract_instr_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_pract_instr_resp_2_allKeys.extend(theseKeys)
                if len(_cdd_pract_instr_resp_2_allKeys):
                    cdd_pract_instr_resp_2.keys = _cdd_pract_instr_resp_2_allKeys[-1].name  # just the last key pressed
                    cdd_pract_instr_resp_2.rt = _cdd_pract_instr_resp_2_allKeys[-1].rt
                    cdd_pract_instr_resp_2.duration = _cdd_pract_instr_resp_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_pract2_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_pract2_instr" ---
        for thisComponent in cdd_pract2_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_pract2_instr.stopped', globalClock.getTime())
        # the Routine "cdd_pract2_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_pract2_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_practice2.csv'),
            seed=None, name='cdd_pract2_trials2')
        thisExp.addLoop(cdd_pract2_trials2)  # add the loop to the experiment
        thisCdd_pract2_trials2 = cdd_pract2_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract2_trials2.rgb)
        if thisCdd_pract2_trials2 != None:
            for paramName in thisCdd_pract2_trials2:
                globals()[paramName] = thisCdd_pract2_trials2[paramName]
        
        for thisCdd_pract2_trials2 in cdd_pract2_trials2:
            currentLoop = cdd_pract2_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_pract2_trials2.rgb)
            if thisCdd_pract2_trials2 != None:
                for paramName in thisCdd_pract2_trials2:
                    globals()[paramName] = thisCdd_pract2_trials2[paramName]
            
            # --- Prepare to start Routine "cdd_pract2_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_trial_code
            my_loop = eval(cdd_practice_loop2_name) 
            cdd_idx2 = random.randint(0,1) #random selection of position and resp key
            cdd_immed_pos2 = cdd_pos2[cdd_idx2]
            cdd_immed_resp2 = cdd_resp1[cdd_idx2]
            cdd_pract2_trial_immed_txt.setPos(cdd_immed_pos2)
            cdd_pract2_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt2))) + "\n" + "\n" + " TODAY")
            cdd_pract2_trial_delay_txt.setPos(cdd_delay_pos2)
            cdd_pract2_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt2))) + "\n" + "\n" + str(cdd_delay_wait2) + " DAYS")
            cdd_pract2_trial_resp.keys = []
            cdd_pract2_trial_resp.rt = []
            _cdd_pract2_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract2_trialComponents = [cdd_pract2_trial_left_poly, cdd_pract2_trial_right_poly, cdd_pract2_trial_prompt_txt, cdd_pract2_trial_immed_txt, cdd_pract2_trial_or_txt, cdd_pract2_trial_delay_txt, GRFX_fix3_2, cdd_pract2_trial_cue, cdd_pract2_trial_resp]
            for thisComponent in cdd_pract2_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_trial_left_poly* updates
                
                # if cdd_pract2_trial_left_poly is starting this frame...
                if cdd_pract2_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_left_poly.status = STARTED
                    cdd_pract2_trial_left_poly.setAutoDraw(True)
                
                # if cdd_pract2_trial_left_poly is active this frame...
                if cdd_pract2_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_left_poly is stopping this frame...
                if cdd_pract2_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_left_poly.status = FINISHED
                        cdd_pract2_trial_left_poly.setAutoDraw(False)
                
                # *cdd_pract2_trial_right_poly* updates
                
                # if cdd_pract2_trial_right_poly is starting this frame...
                if cdd_pract2_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_right_poly.status = STARTED
                    cdd_pract2_trial_right_poly.setAutoDraw(True)
                
                # if cdd_pract2_trial_right_poly is active this frame...
                if cdd_pract2_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_right_poly is stopping this frame...
                if cdd_pract2_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_right_poly.status = FINISHED
                        cdd_pract2_trial_right_poly.setAutoDraw(False)
                
                # *cdd_pract2_trial_prompt_txt* updates
                
                # if cdd_pract2_trial_prompt_txt is starting this frame...
                if cdd_pract2_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_prompt_txt.status = STARTED
                    cdd_pract2_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_prompt_txt is active this frame...
                if cdd_pract2_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_prompt_txt is stopping this frame...
                if cdd_pract2_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_prompt_txt.status = FINISHED
                        cdd_pract2_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_immed_txt* updates
                
                # if cdd_pract2_trial_immed_txt is starting this frame...
                if cdd_pract2_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_immed_txt.status = STARTED
                    cdd_pract2_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_immed_txt is active this frame...
                if cdd_pract2_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_immed_txt is stopping this frame...
                if cdd_pract2_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_immed_txt.status = FINISHED
                        cdd_pract2_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_or_txt* updates
                
                # if cdd_pract2_trial_or_txt is starting this frame...
                if cdd_pract2_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_or_txt.status = STARTED
                    cdd_pract2_trial_or_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_or_txt is active this frame...
                if cdd_pract2_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_or_txt is stopping this frame...
                if cdd_pract2_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_or_txt.status = FINISHED
                        cdd_pract2_trial_or_txt.setAutoDraw(False)
                
                # *cdd_pract2_trial_delay_txt* updates
                
                # if cdd_pract2_trial_delay_txt is starting this frame...
                if cdd_pract2_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_delay_txt.status = STARTED
                    cdd_pract2_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_pract2_trial_delay_txt is active this frame...
                if cdd_pract2_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_delay_txt is stopping this frame...
                if cdd_pract2_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_delay_txt.status = FINISHED
                        cdd_pract2_trial_delay_txt.setAutoDraw(False)
                
                # *GRFX_fix3_2* updates
                
                # if GRFX_fix3_2 is starting this frame...
                if GRFX_fix3_2.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    GRFX_fix3_2.frameNStart = frameN  # exact frame index
                    GRFX_fix3_2.tStart = t  # local t and not account for scr refresh
                    GRFX_fix3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(GRFX_fix3_2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    GRFX_fix3_2.status = STARTED
                    GRFX_fix3_2.setAutoDraw(True)
                
                # if GRFX_fix3_2 is active this frame...
                if GRFX_fix3_2.status == STARTED:
                    # update params
                    pass
                
                # if GRFX_fix3_2 is stopping this frame...
                if GRFX_fix3_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > GRFX_fix3_2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        GRFX_fix3_2.tStop = t  # not accounting for scr refresh
                        GRFX_fix3_2.frameNStop = frameN  # exact frame index
                        # update status
                        GRFX_fix3_2.status = FINISHED
                        GRFX_fix3_2.setAutoDraw(False)
                
                # *cdd_pract2_trial_cue* updates
                
                # if cdd_pract2_trial_cue is starting this frame...
                if cdd_pract2_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_cue.status = STARTED
                    cdd_pract2_trial_cue.setAutoDraw(True)
                
                # if cdd_pract2_trial_cue is active this frame...
                if cdd_pract2_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_trial_cue is stopping this frame...
                if cdd_pract2_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_cue.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_cue.status = FINISHED
                        cdd_pract2_trial_cue.setAutoDraw(False)
                
                # *cdd_pract2_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_pract2_trial_resp is starting this frame...
                if cdd_pract2_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_pract2_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract2_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract2_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract2_trial_resp is stopping this frame...
                if cdd_pract2_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract2_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_trial_resp.status = FINISHED
                        cdd_pract2_trial_resp.status = FINISHED
                if cdd_pract2_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract2_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract2_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract2_trial_resp_allKeys):
                        cdd_pract2_trial_resp.keys = _cdd_pract2_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract2_trial_resp.rt = _cdd_pract2_trial_resp_allKeys[-1].rt
                        cdd_pract2_trial_resp.duration = _cdd_pract2_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_pract2_trial_resp.keys == str(cdd_immed_resp2)) or (cdd_pract2_trial_resp.keys == cdd_immed_resp2):
                            cdd_pract2_trial_resp.corr = 1
                        else:
                            cdd_pract2_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_trial" ---
            for thisComponent in cdd_pract2_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_pract2_trial_code
            cdd_pract2_key = cdd_pract2_trial_resp.keys #Ss response key
            cdd_pract2_immed_key = cdd_pract2_trial_resp.corr #1 when immediate amt is chosen
            my_loop.addData("cdd_trial_type", "practice2")
            # check responses
            if cdd_pract2_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_pract2_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp2).lower() == 'none':
                   cdd_pract2_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_pract2_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_pract2_trials2 (TrialHandler)
            cdd_pract2_trials2.addData('cdd_pract2_trial_resp.keys',cdd_pract2_trial_resp.keys)
            cdd_pract2_trials2.addData('cdd_pract2_trial_resp.corr', cdd_pract2_trial_resp.corr)
            if cdd_pract2_trial_resp.keys != None:  # we had a response
                cdd_pract2_trials2.addData('cdd_pract2_trial_resp.rt', cdd_pract2_trial_resp.rt)
                cdd_pract2_trials2.addData('cdd_pract2_trial_resp.duration', cdd_pract2_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_pract2_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_fb_py
            if len(cdd_pract2_key) == 0: #Ss did not respond
                cdd_msg2 = "NO RESPONSE"
            elif cdd_pract2_immed_key: #Ss chose smaller, immediate option
                cdd_msg2 = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg2 = "$ LATER"
            cdd_pract2_fb_txt.setText(cdd_msg2)
            # keep track of which components have finished
            cdd_pract2_feedbackComponents = [cdd_pract2_fb_txt]
            for thisComponent in cdd_pract2_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_fb_txt* updates
                
                # if cdd_pract2_fb_txt is starting this frame...
                if cdd_pract2_fb_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_fb_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_fb_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_fb_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_fb_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_fb_txt.status = STARTED
                    cdd_pract2_fb_txt.setAutoDraw(True)
                
                # if cdd_pract2_fb_txt is active this frame...
                if cdd_pract2_fb_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_fb_txt is stopping this frame...
                if cdd_pract2_fb_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_fb_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_fb_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_fb_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_fb_txt.status = FINISHED
                        cdd_pract2_fb_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_feedback" ---
            for thisComponent in cdd_pract2_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "cdd_pract2_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_conf_py
            if len(cdd_pract2_key) == 0: #Ss did not respond to choice trial
                continueRoutine = False
            
            #set all 4 boxes as gray by default
            conf1_color = [0, 0, 0]
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            cdd_pract2_conf_resp.keys = []
            cdd_pract2_conf_resp.rt = []
            _cdd_pract2_conf_resp_allKeys = []
            # keep track of which components have finished
            cdd_pract2_confComponents = [cdd_pract2_conf_txt, cdd_pract2_conf1, cdd_pract2_conf1_txt, cdd_pract2_conf2, cdd_pract2_conf2_txt, cdd_pract2_conf3, cdd_pract2_conf3_txt, cdd_pract2_conf4, cdd_pract2_conf4_txt, cdd_pract2_conf_resp]
            for thisComponent in cdd_pract2_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cdd_pract2_conf_py
                cdd_pract_conf_key = cdd_pract_conf_resp.keys
                #confidence rating received
                if len(cdd_pract_conf_key) == 1:
                    #not at all confident
                    if cdd_pract_conf_key == "1":
                        conf1_color = "darkgray"
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #less confident
                    elif cdd_pract_conf_key == "2":
                        conf1_color = [0, 0, 0]
                        conf2_color = "darkgray"
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #somewhat confident
                    elif cdd_pract_conf_key == "3":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = "darkgray"
                        conf4_color = [0, 0, 0]
                    #very confident
                    elif cdd_pract_conf_key == "4":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = "darkgray"
                
                # *cdd_pract2_conf_txt* updates
                
                # if cdd_pract2_conf_txt is starting this frame...
                if cdd_pract2_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf_txt.status = STARTED
                    cdd_pract2_conf_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf_txt is active this frame...
                if cdd_pract2_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf_txt is stopping this frame...
                if cdd_pract2_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf_txt.status = FINISHED
                        cdd_pract2_conf_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf1* updates
                
                # if cdd_pract2_conf1 is starting this frame...
                if cdd_pract2_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf1.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf1.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf1.status = STARTED
                    cdd_pract2_conf1.setAutoDraw(True)
                
                # if cdd_pract2_conf1 is active this frame...
                if cdd_pract2_conf1.status == STARTED:
                    # update params
                    cdd_pract2_conf1.setFillColor(conf1_color, log=False)
                
                # if cdd_pract2_conf1 is stopping this frame...
                if cdd_pract2_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf1.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf1.status = FINISHED
                        cdd_pract2_conf1.setAutoDraw(False)
                
                # *cdd_pract2_conf1_txt* updates
                
                # if cdd_pract2_conf1_txt is starting this frame...
                if cdd_pract2_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf1_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf1_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf1_txt.status = STARTED
                    cdd_pract2_conf1_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf1_txt is active this frame...
                if cdd_pract2_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf1_txt is stopping this frame...
                if cdd_pract2_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf1_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf1_txt.status = FINISHED
                        cdd_pract2_conf1_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf2* updates
                
                # if cdd_pract2_conf2 is starting this frame...
                if cdd_pract2_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf2.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf2.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf2.status = STARTED
                    cdd_pract2_conf2.setAutoDraw(True)
                
                # if cdd_pract2_conf2 is active this frame...
                if cdd_pract2_conf2.status == STARTED:
                    # update params
                    cdd_pract2_conf2.setFillColor(conf2_color, log=False)
                
                # if cdd_pract2_conf2 is stopping this frame...
                if cdd_pract2_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf2.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf2.status = FINISHED
                        cdd_pract2_conf2.setAutoDraw(False)
                
                # *cdd_pract2_conf2_txt* updates
                
                # if cdd_pract2_conf2_txt is starting this frame...
                if cdd_pract2_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf2_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf2_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf2_txt.status = STARTED
                    cdd_pract2_conf2_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf2_txt is active this frame...
                if cdd_pract2_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf2_txt is stopping this frame...
                if cdd_pract2_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf2_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf2_txt.status = FINISHED
                        cdd_pract2_conf2_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf3* updates
                
                # if cdd_pract2_conf3 is starting this frame...
                if cdd_pract2_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf3.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf3.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf3.status = STARTED
                    cdd_pract2_conf3.setAutoDraw(True)
                
                # if cdd_pract2_conf3 is active this frame...
                if cdd_pract2_conf3.status == STARTED:
                    # update params
                    cdd_pract2_conf3.setFillColor(conf3_color, log=False)
                
                # if cdd_pract2_conf3 is stopping this frame...
                if cdd_pract2_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf3.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf3.status = FINISHED
                        cdd_pract2_conf3.setAutoDraw(False)
                
                # *cdd_pract2_conf3_txt* updates
                
                # if cdd_pract2_conf3_txt is starting this frame...
                if cdd_pract2_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf3_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf3_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf3_txt.status = STARTED
                    cdd_pract2_conf3_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf3_txt is active this frame...
                if cdd_pract2_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf3_txt is stopping this frame...
                if cdd_pract2_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf3_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf3_txt.status = FINISHED
                        cdd_pract2_conf3_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf4* updates
                
                # if cdd_pract2_conf4 is starting this frame...
                if cdd_pract2_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf4.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf4.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf4.status = STARTED
                    cdd_pract2_conf4.setAutoDraw(True)
                
                # if cdd_pract2_conf4 is active this frame...
                if cdd_pract2_conf4.status == STARTED:
                    # update params
                    cdd_pract2_conf4.setFillColor(conf4_color, log=False)
                
                # if cdd_pract2_conf4 is stopping this frame...
                if cdd_pract2_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf4.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf4.status = FINISHED
                        cdd_pract2_conf4.setAutoDraw(False)
                
                # *cdd_pract2_conf4_txt* updates
                
                # if cdd_pract2_conf4_txt is starting this frame...
                if cdd_pract2_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf4_txt.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf4_txt.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf4_txt.status = STARTED
                    cdd_pract2_conf4_txt.setAutoDraw(True)
                
                # if cdd_pract2_conf4_txt is active this frame...
                if cdd_pract2_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_conf4_txt is stopping this frame...
                if cdd_pract2_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf4_txt.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf4_txt.status = FINISHED
                        cdd_pract2_conf4_txt.setAutoDraw(False)
                
                # *cdd_pract2_conf_resp* updates
                waitOnFlip = False
                
                # if cdd_pract2_conf_resp is starting this frame...
                if cdd_pract2_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_conf_resp.frameNStart = frameN  # exact frame index
                    cdd_pract2_conf_resp.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_pract2_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_pract2_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_pract2_conf_resp is stopping this frame...
                if cdd_pract2_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_conf_resp.tStop = t  # not accounting for scr refresh
                        cdd_pract2_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_conf_resp.status = FINISHED
                        cdd_pract2_conf_resp.status = FINISHED
                if cdd_pract2_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_pract2_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_pract2_conf_resp_allKeys.extend(theseKeys)
                    if len(_cdd_pract2_conf_resp_allKeys):
                        cdd_pract2_conf_resp.keys = _cdd_pract2_conf_resp_allKeys[-1].name  # just the last key pressed
                        cdd_pract2_conf_resp.rt = _cdd_pract2_conf_resp_allKeys[-1].rt
                        cdd_pract2_conf_resp.duration = _cdd_pract2_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_conf" ---
            for thisComponent in cdd_pract2_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_conf.stopped', globalClock.getTime())
            # check responses
            if cdd_pract2_conf_resp.keys in ['', [], None]:  # No response was made
                cdd_pract2_conf_resp.keys = None
            cdd_pract2_trials2.addData('cdd_pract2_conf_resp.keys',cdd_pract2_conf_resp.keys)
            if cdd_pract2_conf_resp.keys != None:  # we had a response
                cdd_pract2_trials2.addData('cdd_pract2_conf_resp.rt', cdd_pract2_conf_resp.rt)
                cdd_pract2_trials2.addData('cdd_pract2_conf_resp.duration', cdd_pract2_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "cdd_pract2_iti2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_pract2_iti2.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_pract2_iti2_code
            #3 CDD practice trials
            if cdd_pract2_trials2.thisTrialN == 2: #after the last practice trial
                continueRoutine = False #do not run ITI fixation
            # keep track of which components have finished
            cdd_pract2_iti2Components = [cdd_pract2_iti2_poly]
            for thisComponent in cdd_pract2_iti2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_pract2_iti2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_pract2_iti2_poly* updates
                
                # if cdd_pract2_iti2_poly is starting this frame...
                if cdd_pract2_iti2_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_pract2_iti2_poly.frameNStart = frameN  # exact frame index
                    cdd_pract2_iti2_poly.tStart = t  # local t and not account for scr refresh
                    cdd_pract2_iti2_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_pract2_iti2_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_pract2_iti2_poly.status = STARTED
                    cdd_pract2_iti2_poly.setAutoDraw(True)
                
                # if cdd_pract2_iti2_poly is active this frame...
                if cdd_pract2_iti2_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_pract2_iti2_poly is stopping this frame...
                if cdd_pract2_iti2_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_pract2_iti2_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_pract2_iti2_poly.tStop = t  # not accounting for scr refresh
                        cdd_pract2_iti2_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_pract2_iti2_poly.status = FINISHED
                        cdd_pract2_iti2_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_pract2_iti2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_pract2_iti2" ---
            for thisComponent in cdd_pract2_iti2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_pract2_iti2.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_pract2_trials2'
        
        
        # --- Prepare to start Routine "cdd_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_trial_instr.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_trial_instr_code
        #QC check
        cdd_task_resps = []
        cdd_conf_resps = []
        cdd_catch_trials = []
        
        #variable ITI list creation
        cdd_iti_list = [random.random() for i in range(100)]
        cdd_s = sum(cdd_iti_list)
        cdd_iti_list = [i*100/cdd_s for i in cdd_iti_list]
        cdd_trial_instr_resp.keys = []
        cdd_trial_instr_resp.rt = []
        _cdd_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        cdd_trial_instrComponents = [cdd_trial_instr_title_txt, cdd_trial_instr_txt, cdd_trial_instr_space_txt, cdd_trial_instr_resp]
        for thisComponent in cdd_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_trial_instr_title_txt* updates
            
            # if cdd_trial_instr_title_txt is starting this frame...
            if cdd_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_title_txt.status = STARTED
                cdd_trial_instr_title_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_title_txt is active this frame...
            if cdd_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_txt* updates
            
            # if cdd_trial_instr_txt is starting this frame...
            if cdd_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_txt.status = STARTED
                cdd_trial_instr_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_txt is active this frame...
            if cdd_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_space_txt* updates
            
            # if cdd_trial_instr_space_txt is starting this frame...
            if cdd_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                cdd_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_space_txt.status = STARTED
                cdd_trial_instr_space_txt.setAutoDraw(True)
            
            # if cdd_trial_instr_space_txt is active this frame...
            if cdd_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_trial_instr_resp* updates
            waitOnFlip = False
            
            # if cdd_trial_instr_resp is starting this frame...
            if cdd_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_trial_instr_resp.frameNStart = frameN  # exact frame index
                cdd_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                cdd_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_cdd_trial_instr_resp_allKeys):
                    cdd_trial_instr_resp.keys = _cdd_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    cdd_trial_instr_resp.rt = _cdd_trial_instr_resp_allKeys[-1].rt
                    cdd_trial_instr_resp.duration = _cdd_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_trial_instr" ---
        for thisComponent in cdd_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_trial_instr.stopped', globalClock.getTime())
        # the Routine "cdd_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cdd_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cdd_init_fixComponents = [cdd_init_fix_polygon]
        for thisComponent in cdd_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_init_fix_polygon* updates
            
            # if cdd_init_fix_polygon is starting this frame...
            if cdd_init_fix_polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_init_fix_polygon.frameNStart = frameN  # exact frame index
                cdd_init_fix_polygon.tStart = t  # local t and not account for scr refresh
                cdd_init_fix_polygon.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_init_fix_polygon, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_init_fix_polygon.status = STARTED
                cdd_init_fix_polygon.setAutoDraw(True)
            
            # if cdd_init_fix_polygon is active this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # update params
                pass
            
            # if cdd_init_fix_polygon is stopping this frame...
            if cdd_init_fix_polygon.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cdd_init_fix_polygon.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cdd_init_fix_polygon.tStop = t  # not accounting for scr refresh
                    cdd_init_fix_polygon.frameNStop = frameN  # exact frame index
                    # update status
                    cdd_init_fix_polygon.status = FINISHED
                    cdd_init_fix_polygon.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_init_fix" ---
        for thisComponent in cdd_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cdd_trials2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cdd/cdd_gen_trials_idx.csv'),
            seed=None, name='cdd_trials2')
        thisExp.addLoop(cdd_trials2)  # add the loop to the experiment
        thisCdd_trials2 = cdd_trials2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCdd_trials2.rgb)
        if thisCdd_trials2 != None:
            for paramName in thisCdd_trials2:
                globals()[paramName] = thisCdd_trials2[paramName]
        
        for thisCdd_trials2 in cdd_trials2:
            currentLoop = cdd_trials2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCdd_trials2.rgb)
            if thisCdd_trials2 != None:
                for paramName in thisCdd_trials2:
                    globals()[paramName] = thisCdd_trials2[paramName]
            
            # --- Prepare to start Routine "cdd_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_trial.started', globalClock.getTime())
            cdd_trial_immed_txt.setPos(cdd_immed_pos)
            cdd_trial_immed_txt.setText(str("$"+str(format(cdd_immed_amt))) + "\n" + "\n" + " TODAY")
            cdd_trial_delay_txt.setPos(cdd_delay_pos)
            cdd_trial_delay_txt.setText(str("$"+str(format(cdd_delay_amt))) + "\n" + "\n" + str(cdd_delay_wait) + " DAYS")
            cdd_trial_resp.keys = []
            cdd_trial_resp.rt = []
            _cdd_trial_resp_allKeys = []
            # keep track of which components have finished
            cdd_trialComponents = [cdd_trial_left_poly, cdd_trial_right_poly, cdd_trial_prompt_txt, cdd_trial_immed_txt, cdd_trial_or_txt, cdd_trial_delay_txt, cdd_trial_cue, cdd_trial_resp]
            for thisComponent in cdd_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 5.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_trial_left_poly* updates
                
                # if cdd_trial_left_poly is starting this frame...
                if cdd_trial_left_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_left_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_left_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_left_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_left_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_left_poly.status = STARTED
                    cdd_trial_left_poly.setAutoDraw(True)
                
                # if cdd_trial_left_poly is active this frame...
                if cdd_trial_left_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_left_poly is stopping this frame...
                if cdd_trial_left_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_left_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_left_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_left_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_left_poly.status = FINISHED
                        cdd_trial_left_poly.setAutoDraw(False)
                
                # *cdd_trial_right_poly* updates
                
                # if cdd_trial_right_poly is starting this frame...
                if cdd_trial_right_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_right_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_right_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_right_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_right_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_right_poly.status = STARTED
                    cdd_trial_right_poly.setAutoDraw(True)
                
                # if cdd_trial_right_poly is active this frame...
                if cdd_trial_right_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_right_poly is stopping this frame...
                if cdd_trial_right_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_right_poly.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_right_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_right_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_right_poly.status = FINISHED
                        cdd_trial_right_poly.setAutoDraw(False)
                
                # *cdd_trial_prompt_txt* updates
                
                # if cdd_trial_prompt_txt is starting this frame...
                if cdd_trial_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_prompt_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_prompt_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_prompt_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_prompt_txt.status = STARTED
                    cdd_trial_prompt_txt.setAutoDraw(True)
                
                # if cdd_trial_prompt_txt is active this frame...
                if cdd_trial_prompt_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_prompt_txt is stopping this frame...
                if cdd_trial_prompt_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_prompt_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_prompt_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_prompt_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_prompt_txt.status = FINISHED
                        cdd_trial_prompt_txt.setAutoDraw(False)
                
                # *cdd_trial_immed_txt* updates
                
                # if cdd_trial_immed_txt is starting this frame...
                if cdd_trial_immed_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_immed_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_immed_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_immed_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_immed_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_immed_txt.status = STARTED
                    cdd_trial_immed_txt.setAutoDraw(True)
                
                # if cdd_trial_immed_txt is active this frame...
                if cdd_trial_immed_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_immed_txt is stopping this frame...
                if cdd_trial_immed_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_immed_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_immed_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_immed_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_immed_txt.status = FINISHED
                        cdd_trial_immed_txt.setAutoDraw(False)
                
                # *cdd_trial_or_txt* updates
                
                # if cdd_trial_or_txt is starting this frame...
                if cdd_trial_or_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_or_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_or_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_or_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_or_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_or_txt.status = STARTED
                    cdd_trial_or_txt.setAutoDraw(True)
                
                # if cdd_trial_or_txt is active this frame...
                if cdd_trial_or_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_or_txt is stopping this frame...
                if cdd_trial_or_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_or_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_or_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_or_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_or_txt.status = FINISHED
                        cdd_trial_or_txt.setAutoDraw(False)
                
                # *cdd_trial_delay_txt* updates
                
                # if cdd_trial_delay_txt is starting this frame...
                if cdd_trial_delay_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_delay_txt.frameNStart = frameN  # exact frame index
                    cdd_trial_delay_txt.tStart = t  # local t and not account for scr refresh
                    cdd_trial_delay_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_delay_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_delay_txt.status = STARTED
                    cdd_trial_delay_txt.setAutoDraw(True)
                
                # if cdd_trial_delay_txt is active this frame...
                if cdd_trial_delay_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_delay_txt is stopping this frame...
                if cdd_trial_delay_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_delay_txt.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_delay_txt.tStop = t  # not accounting for scr refresh
                        cdd_trial_delay_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_delay_txt.status = FINISHED
                        cdd_trial_delay_txt.setAutoDraw(False)
                
                # *cdd_trial_cue* updates
                
                # if cdd_trial_cue is starting this frame...
                if cdd_trial_cue.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_cue.frameNStart = frameN  # exact frame index
                    cdd_trial_cue.tStart = t  # local t and not account for scr refresh
                    cdd_trial_cue.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_cue, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'cdd_trial_cue.started')
                    # update status
                    cdd_trial_cue.status = STARTED
                    cdd_trial_cue.setAutoDraw(True)
                
                # if cdd_trial_cue is active this frame...
                if cdd_trial_cue.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_cue is stopping this frame...
                if cdd_trial_cue.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_cue.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_cue.tStop = t  # not accounting for scr refresh
                        cdd_trial_cue.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cdd_trial_cue.stopped')
                        # update status
                        cdd_trial_cue.status = FINISHED
                        cdd_trial_cue.setAutoDraw(False)
                
                # *cdd_trial_resp* updates
                waitOnFlip = False
                
                # if cdd_trial_resp is starting this frame...
                if cdd_trial_resp.status == NOT_STARTED and tThisFlip >= 3-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_resp.frameNStart = frameN  # exact frame index
                    cdd_trial_resp.tStart = t  # local t and not account for scr refresh
                    cdd_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_trial_resp is stopping this frame...
                if cdd_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_resp.tStop = t  # not accounting for scr refresh
                        cdd_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_trial_resp.status = FINISHED
                        cdd_trial_resp.status = FINISHED
                if cdd_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_trial_resp.getKeys(keyList=['1', '2'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_trial_resp_allKeys.extend(theseKeys)
                    if len(_cdd_trial_resp_allKeys):
                        cdd_trial_resp.keys = _cdd_trial_resp_allKeys[-1].name  # just the last key pressed
                        cdd_trial_resp.rt = _cdd_trial_resp_allKeys[-1].rt
                        cdd_trial_resp.duration = _cdd_trial_resp_allKeys[-1].duration
                        # was this correct?
                        if (cdd_trial_resp.keys == str(cdd_immed_resp)) or (cdd_trial_resp.keys == cdd_immed_resp):
                            cdd_trial_resp.corr = 1
                        else:
                            cdd_trial_resp.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_trial" ---
            for thisComponent in cdd_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_trial.stopped', globalClock.getTime())
            # check responses
            if cdd_trial_resp.keys in ['', [], None]:  # No response was made
                cdd_trial_resp.keys = None
                # was no response the correct answer?!
                if str(cdd_immed_resp).lower() == 'none':
                   cdd_trial_resp.corr = 1;  # correct non-response
                else:
                   cdd_trial_resp.corr = 0;  # failed to respond (incorrectly)
            # store data for cdd_trials2 (TrialHandler)
            cdd_trials2.addData('cdd_trial_resp.keys',cdd_trial_resp.keys)
            cdd_trials2.addData('cdd_trial_resp.corr', cdd_trial_resp.corr)
            if cdd_trial_resp.keys != None:  # we had a response
                cdd_trials2.addData('cdd_trial_resp.rt', cdd_trial_resp.rt)
                cdd_trials2.addData('cdd_trial_resp.duration', cdd_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-5.000000)
            
            # --- Prepare to start Routine "cdd_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_feedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_feedback_code
            if len(cdd_key) == 0: #Ss did not respond
                cdd_msg = "NO RESPONSE"
            elif cdd_immed_key: #Ss chose smaller, immediate option
                cdd_msg = "$ NOW"
            else: #Ss chose larger, delayed option
                cdd_msg = "$ LATER"
            cdd_feedback_txt.setText(cdd_msg)
            # keep track of which components have finished
            cdd_feedbackComponents = [cdd_feedback_txt]
            for thisComponent in cdd_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 0.5:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_feedback_txt* updates
                
                # if cdd_feedback_txt is starting this frame...
                if cdd_feedback_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_feedback_txt.frameNStart = frameN  # exact frame index
                    cdd_feedback_txt.tStart = t  # local t and not account for scr refresh
                    cdd_feedback_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_feedback_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_feedback_txt.status = STARTED
                    cdd_feedback_txt.setAutoDraw(True)
                
                # if cdd_feedback_txt is active this frame...
                if cdd_feedback_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_feedback_txt is stopping this frame...
                if cdd_feedback_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_feedback_txt.tStartRefresh + 0.5-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_feedback_txt.tStop = t  # not accounting for scr refresh
                        cdd_feedback_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_feedback_txt.status = FINISHED
                        cdd_feedback_txt.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_feedback" ---
            for thisComponent in cdd_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-0.500000)
            
            # --- Prepare to start Routine "cdd_conf" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_conf.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_conf_code
            #Ss did not respond to choice trial
            if len(cdd_key) == 0:
                continueRoutine = False
            
            #set all 4 boxes as gray by default
            conf1_color = [0, 0, 0]
            conf2_color = [0, 0, 0]
            conf3_color = [0, 0, 0]
            conf4_color = [0, 0, 0]
            cdd_conf_resp.keys = []
            cdd_conf_resp.rt = []
            _cdd_conf_resp_allKeys = []
            # keep track of which components have finished
            cdd_confComponents = [cdd_conf_txt, cdd_conf1, cdd_conf1_txt, cdd_conf2, cdd_conf2_txt, cdd_conf3, cdd_conf3_txt, cdd_conf4, cdd_conf4_txt, cdd_conf_resp]
            for thisComponent in cdd_confComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_conf" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cdd_conf_code
                cdd_conf_key = cdd_conf_resp.keys
                #confidence rating received
                if len(cdd_conf_key) == 1:
                    #not at all confident
                    if cdd_conf_key == "1":
                        conf1_color = "darkgray"
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #less confident
                    elif cdd_conf_key == "2":
                        conf1_color = [0, 0, 0]
                        conf2_color = "darkgray"
                        conf3_color = [0, 0, 0]
                        conf4_color = [0, 0, 0]
                    #somewhat confident
                    elif cdd_conf_key == "3":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = "darkgray"
                        conf4_color = [0, 0, 0]
                    #very confident
                    elif cdd_conf_key == "4":
                        conf1_color = [0, 0, 0]
                        conf2_color = [0, 0, 0]
                        conf3_color = [0, 0, 0]
                        conf4_color = "darkgray"
                
                # *cdd_conf_txt* updates
                
                # if cdd_conf_txt is starting this frame...
                if cdd_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf_txt.frameNStart = frameN  # exact frame index
                    cdd_conf_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf_txt.status = STARTED
                    cdd_conf_txt.setAutoDraw(True)
                
                # if cdd_conf_txt is active this frame...
                if cdd_conf_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf_txt is stopping this frame...
                if cdd_conf_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf_txt.status = FINISHED
                        cdd_conf_txt.setAutoDraw(False)
                
                # *cdd_conf1* updates
                
                # if cdd_conf1 is starting this frame...
                if cdd_conf1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf1.frameNStart = frameN  # exact frame index
                    cdd_conf1.tStart = t  # local t and not account for scr refresh
                    cdd_conf1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf1, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf1.status = STARTED
                    cdd_conf1.setAutoDraw(True)
                
                # if cdd_conf1 is active this frame...
                if cdd_conf1.status == STARTED:
                    # update params
                    cdd_conf1.setFillColor(conf1_color, log=False)
                
                # if cdd_conf1 is stopping this frame...
                if cdd_conf1.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf1.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf1.tStop = t  # not accounting for scr refresh
                        cdd_conf1.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf1.status = FINISHED
                        cdd_conf1.setAutoDraw(False)
                
                # *cdd_conf1_txt* updates
                
                # if cdd_conf1_txt is starting this frame...
                if cdd_conf1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf1_txt.frameNStart = frameN  # exact frame index
                    cdd_conf1_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf1_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf1_txt.status = STARTED
                    cdd_conf1_txt.setAutoDraw(True)
                
                # if cdd_conf1_txt is active this frame...
                if cdd_conf1_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf1_txt is stopping this frame...
                if cdd_conf1_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf1_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf1_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf1_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf1_txt.status = FINISHED
                        cdd_conf1_txt.setAutoDraw(False)
                
                # *cdd_conf2* updates
                
                # if cdd_conf2 is starting this frame...
                if cdd_conf2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf2.frameNStart = frameN  # exact frame index
                    cdd_conf2.tStart = t  # local t and not account for scr refresh
                    cdd_conf2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf2.status = STARTED
                    cdd_conf2.setAutoDraw(True)
                
                # if cdd_conf2 is active this frame...
                if cdd_conf2.status == STARTED:
                    # update params
                    cdd_conf2.setFillColor(conf2_color, log=False)
                
                # if cdd_conf2 is stopping this frame...
                if cdd_conf2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf2.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf2.tStop = t  # not accounting for scr refresh
                        cdd_conf2.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf2.status = FINISHED
                        cdd_conf2.setAutoDraw(False)
                
                # *cdd_conf2_txt* updates
                
                # if cdd_conf2_txt is starting this frame...
                if cdd_conf2_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf2_txt.frameNStart = frameN  # exact frame index
                    cdd_conf2_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf2_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf2_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf2_txt.status = STARTED
                    cdd_conf2_txt.setAutoDraw(True)
                
                # if cdd_conf2_txt is active this frame...
                if cdd_conf2_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf2_txt is stopping this frame...
                if cdd_conf2_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf2_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf2_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf2_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf2_txt.status = FINISHED
                        cdd_conf2_txt.setAutoDraw(False)
                
                # *cdd_conf3* updates
                
                # if cdd_conf3 is starting this frame...
                if cdd_conf3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf3.frameNStart = frameN  # exact frame index
                    cdd_conf3.tStart = t  # local t and not account for scr refresh
                    cdd_conf3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf3, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf3.status = STARTED
                    cdd_conf3.setAutoDraw(True)
                
                # if cdd_conf3 is active this frame...
                if cdd_conf3.status == STARTED:
                    # update params
                    cdd_conf3.setFillColor(conf3_color, log=False)
                
                # if cdd_conf3 is stopping this frame...
                if cdd_conf3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf3.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf3.tStop = t  # not accounting for scr refresh
                        cdd_conf3.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf3.status = FINISHED
                        cdd_conf3.setAutoDraw(False)
                
                # *cdd_conf3_txt* updates
                
                # if cdd_conf3_txt is starting this frame...
                if cdd_conf3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf3_txt.frameNStart = frameN  # exact frame index
                    cdd_conf3_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf3_txt.status = STARTED
                    cdd_conf3_txt.setAutoDraw(True)
                
                # if cdd_conf3_txt is active this frame...
                if cdd_conf3_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf3_txt is stopping this frame...
                if cdd_conf3_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf3_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf3_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf3_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf3_txt.status = FINISHED
                        cdd_conf3_txt.setAutoDraw(False)
                
                # *cdd_conf4* updates
                
                # if cdd_conf4 is starting this frame...
                if cdd_conf4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf4.frameNStart = frameN  # exact frame index
                    cdd_conf4.tStart = t  # local t and not account for scr refresh
                    cdd_conf4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf4, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf4.status = STARTED
                    cdd_conf4.setAutoDraw(True)
                
                # if cdd_conf4 is active this frame...
                if cdd_conf4.status == STARTED:
                    # update params
                    cdd_conf4.setFillColor(conf4_color, log=False)
                
                # if cdd_conf4 is stopping this frame...
                if cdd_conf4.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf4.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf4.tStop = t  # not accounting for scr refresh
                        cdd_conf4.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf4.status = FINISHED
                        cdd_conf4.setAutoDraw(False)
                
                # *cdd_conf4_txt* updates
                
                # if cdd_conf4_txt is starting this frame...
                if cdd_conf4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf4_txt.frameNStart = frameN  # exact frame index
                    cdd_conf4_txt.tStart = t  # local t and not account for scr refresh
                    cdd_conf4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf4_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf4_txt.status = STARTED
                    cdd_conf4_txt.setAutoDraw(True)
                
                # if cdd_conf4_txt is active this frame...
                if cdd_conf4_txt.status == STARTED:
                    # update params
                    pass
                
                # if cdd_conf4_txt is stopping this frame...
                if cdd_conf4_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf4_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf4_txt.tStop = t  # not accounting for scr refresh
                        cdd_conf4_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf4_txt.status = FINISHED
                        cdd_conf4_txt.setAutoDraw(False)
                
                # *cdd_conf_resp* updates
                waitOnFlip = False
                
                # if cdd_conf_resp is starting this frame...
                if cdd_conf_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_conf_resp.frameNStart = frameN  # exact frame index
                    cdd_conf_resp.tStart = t  # local t and not account for scr refresh
                    cdd_conf_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_conf_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cdd_conf_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cdd_conf_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cdd_conf_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cdd_conf_resp is stopping this frame...
                if cdd_conf_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_conf_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_conf_resp.tStop = t  # not accounting for scr refresh
                        cdd_conf_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cdd_conf_resp.status = FINISHED
                        cdd_conf_resp.status = FINISHED
                if cdd_conf_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cdd_conf_resp.getKeys(keyList=['1', '2', '3', '4'], ignoreKeys=["escape"], waitRelease=False)
                    _cdd_conf_resp_allKeys.extend(theseKeys)
                    if len(_cdd_conf_resp_allKeys):
                        cdd_conf_resp.keys = _cdd_conf_resp_allKeys[-1].name  # just the last key pressed
                        cdd_conf_resp.rt = _cdd_conf_resp_allKeys[-1].rt
                        cdd_conf_resp.duration = _cdd_conf_resp_allKeys[-1].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_confComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_conf" ---
            for thisComponent in cdd_confComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_conf.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_conf_code
            my_loop.addData("cdd_conf", cdd_conf_key)
            
            if len(cdd_conf_key) == 1:
                if type(cdd_conf_key) == list:
                    if cdd_conf_key[-1] in ["1", "2", "3", "4"]:
                        cdd_conf_resps.append(cdd_conf_key)
                else:
                    if cdd_conf_key in ["1", "2", "3", "4"]:
                        cdd_conf_resps.append(cdd_conf_key)
            # check responses
            if cdd_conf_resp.keys in ['', [], None]:  # No response was made
                cdd_conf_resp.keys = None
            cdd_trials2.addData('cdd_conf_resp.keys',cdd_conf_resp.keys)
            if cdd_conf_resp.keys != None:  # we had a response
                cdd_trials2.addData('cdd_conf_resp.rt', cdd_conf_resp.rt)
                cdd_trials2.addData('cdd_conf_resp.duration', cdd_conf_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            
            # --- Prepare to start Routine "cdd_trial_iti2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cdd_trial_iti2.started', globalClock.getTime())
            # Run 'Begin Routine' code from cdd_trial_iti2_code
            #variable ITI for non-practice trials
            cdd_iti_time = cdd_iti_list[my_loop.thisIndex] + cdd_delta_time
            
            #90 trials in CDD task
            if cdd_trials2.thisTrialN == 99:
                continueRoutine = False
            # keep track of which components have finished
            cdd_trial_iti2Components = [cdd_trial_iti2_poly]
            for thisComponent in cdd_trial_iti2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cdd_trial_iti2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cdd_trial_iti2_poly* updates
                
                # if cdd_trial_iti2_poly is starting this frame...
                if cdd_trial_iti2_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cdd_trial_iti2_poly.frameNStart = frameN  # exact frame index
                    cdd_trial_iti2_poly.tStart = t  # local t and not account for scr refresh
                    cdd_trial_iti2_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cdd_trial_iti2_poly, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'cdd_trial_iti2_poly.started')
                    # update status
                    cdd_trial_iti2_poly.status = STARTED
                    cdd_trial_iti2_poly.setAutoDraw(True)
                
                # if cdd_trial_iti2_poly is active this frame...
                if cdd_trial_iti2_poly.status == STARTED:
                    # update params
                    pass
                
                # if cdd_trial_iti2_poly is stopping this frame...
                if cdd_trial_iti2_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cdd_trial_iti2_poly.tStartRefresh + cdd_iti_time-frameTolerance:
                        # keep track of stop time/frame for later
                        cdd_trial_iti2_poly.tStop = t  # not accounting for scr refresh
                        cdd_trial_iti2_poly.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cdd_trial_iti2_poly.stopped')
                        # update status
                        cdd_trial_iti2_poly.status = FINISHED
                        cdd_trial_iti2_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cdd_trial_iti2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cdd_trial_iti2" ---
            for thisComponent in cdd_trial_iti2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cdd_trial_iti2.stopped', globalClock.getTime())
            # Run 'End Routine' code from cdd_trial_iti2_code
            my_loop.addData("cdd_delta_time", delta_time)
            my_loop.addData("cdd_iti_time", iti_time)
            # the Routine "cdd_trial_iti2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cdd_trials2'
        
        
        # --- Prepare to start Routine "cdd_end" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cdd_end.started', globalClock.getTime())
        # Run 'Begin Routine' code from cdd_end_code
        cdd_unique_resps = []
        cdd_unique_count = 0
        for i in cdd_task_resps:
            if i not in cdd_unique_resps:
                cdd_unique_count += 1
                cdd_unique_resps.append(i)
        
        cdd_task_end_text = ""
        cdd_space_text = ""
        #filter for nonresponses
        if len(cdd_task_resps) < 95 or len(cdd_conf_resps) < 95: #95% of 100 CDD trials
            if len(cdd_task_resps) < 95:
                cdd_task_end_text = "You failed to respond to " + str(100-len(cdd_task_resps)) + " task trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            if len(cdd_conf_resps) < 95:
                cdd_task_end_text = "You failed to respond to both parts of " + str(100-len(cdd_conf_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            cdd_space_text = "Press SPACE to end."
            my_loop.addData("cdd_subReject1", "< 95% resp rate")
            my_loop.addData("cdd_subReject1_nonresps-task", 100-len(cdd_task_resps))
            my_loop.addData("cdd_subReject1_nonresps-conf", 100-len(cdd_conf_resps))
            exp_proceed = False
        #filter for single-button responses
        elif cdd_unique_count < 2: #same for each exp
            cdd_task_end_text = "You provided the same response to all " + str(len(cdd_task_resps)) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            cdd_space_text = "Press SPACE to end."
            exp_proceed = False
            my_loop.addData("cdd_subReject2", "1key response")
            my_loop.addData("cdd_subReject2_key", cdd_task_resps[0])
        #filter for poor performance on CDD catch trials (5/6 catch trials -- 3.125% of random success on 5 trials)
        #elif sum(cdd_catch_trials) < 5: 
        #    cdd_task_end_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
        #    cdd_space_text = "Press SPACE to end."
        #    exp_proceed = False
        #    my_loop.addData("cdd_subReject3", "catch fail")
        #    my_loop.addData("cdd_subReject3_fails", 6-sum(cdd_catch_trials))
        #all CDD task trial criterion are met
        else:
            cdd_task_end_text = "You have completed the Delay Discounting Task!"
            cdd_space_text = "Press SPACE to continue."
        cdd_end_txt_ON.setText(cdd_task_end_text)
        cdd_end_space_ON.setText(cdd_space_text)
        cdd_end_resp.keys = []
        cdd_end_resp.rt = []
        _cdd_end_resp_allKeys = []
        # keep track of which components have finished
        cdd_endComponents = [cdd_end_title_txt, cdd_end_txt_ON, cdd_end_space_ON, cdd_end_resp]
        for thisComponent in cdd_endComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cdd_end" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cdd_end_title_txt* updates
            
            # if cdd_end_title_txt is starting this frame...
            if cdd_end_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_title_txt.frameNStart = frameN  # exact frame index
                cdd_end_title_txt.tStart = t  # local t and not account for scr refresh
                cdd_end_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_title_txt.status = STARTED
                cdd_end_title_txt.setAutoDraw(True)
            
            # if cdd_end_title_txt is active this frame...
            if cdd_end_title_txt.status == STARTED:
                # update params
                pass
            
            # *cdd_end_txt_ON* updates
            
            # if cdd_end_txt_ON is starting this frame...
            if cdd_end_txt_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_txt_ON.frameNStart = frameN  # exact frame index
                cdd_end_txt_ON.tStart = t  # local t and not account for scr refresh
                cdd_end_txt_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_txt_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_txt_ON.status = STARTED
                cdd_end_txt_ON.setAutoDraw(True)
            
            # if cdd_end_txt_ON is active this frame...
            if cdd_end_txt_ON.status == STARTED:
                # update params
                pass
            
            # *cdd_end_space_ON* updates
            
            # if cdd_end_space_ON is starting this frame...
            if cdd_end_space_ON.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_space_ON.frameNStart = frameN  # exact frame index
                cdd_end_space_ON.tStart = t  # local t and not account for scr refresh
                cdd_end_space_ON.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_space_ON, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_space_ON.status = STARTED
                cdd_end_space_ON.setAutoDraw(True)
            
            # if cdd_end_space_ON is active this frame...
            if cdd_end_space_ON.status == STARTED:
                # update params
                pass
            
            # *cdd_end_resp* updates
            waitOnFlip = False
            
            # if cdd_end_resp is starting this frame...
            if cdd_end_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cdd_end_resp.frameNStart = frameN  # exact frame index
                cdd_end_resp.tStart = t  # local t and not account for scr refresh
                cdd_end_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cdd_end_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cdd_end_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cdd_end_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cdd_end_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cdd_end_resp.status == STARTED and not waitOnFlip:
                theseKeys = cdd_end_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cdd_end_resp_allKeys.extend(theseKeys)
                if len(_cdd_end_resp_allKeys):
                    cdd_end_resp.keys = _cdd_end_resp_allKeys[-1].name  # just the last key pressed
                    cdd_end_resp.rt = _cdd_end_resp_allKeys[-1].rt
                    cdd_end_resp.duration = _cdd_end_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cdd_endComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cdd_end" ---
        for thisComponent in cdd_endComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cdd_end.stopped', globalClock.getTime())
        # the Routine "cdd_end" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "idm_term_check" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('idm_term_check.started', globalClock.getTime())
        # Run 'Begin Routine' code from idm_term_check_code
        if exp_proceed == False:
            core.quit()
        # keep track of which components have finished
        idm_term_checkComponents = []
        for thisComponent in idm_term_checkComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "idm_term_check" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "idm_term_check" ---
        for thisComponent in idm_term_checkComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('idm_term_check.stopped', globalClock.getTime())
        # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
    # completed loop6 repeats of 'should_run6'
    
    
    # set up handler to look after randomisation of conditions etc
    should_run7 = data.TrialHandler(nReps=loop7, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='should_run7')
    thisExp.addLoop(should_run7)  # add the loop to the experiment
    thisShould_run7 = should_run7.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisShould_run7.rgb)
    if thisShould_run7 != None:
        for paramName in thisShould_run7:
            globals()[paramName] = thisShould_run7[paramName]
    
    for thisShould_run7 in should_run7:
        currentLoop = should_run7
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisShould_run7.rgb)
        if thisShould_run7 != None:
            for paramName in thisShould_run7:
                globals()[paramName] = thisShould_run7[paramName]
        
        # --- Prepare to start Routine "cpdm_namer3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_namer3.started', globalClock.getTime())
        # Run 'Begin Routine' code from cpdm_namer3_code
        cpdm_practice_loop_name = "cpdm_pract_trials3"
        cpdm_loop_name = "cpdm_trials3"
        # keep track of which components have finished
        cpdm_namer3Components = []
        for thisComponent in cpdm_namer3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_namer3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_namer3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_namer3" ---
        for thisComponent in cpdm_namer3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_namer3.stopped', globalClock.getTime())
        # the Routine "cpdm_namer3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr1.started', globalClock.getTime())
        cpdm_instr1_resp.keys = []
        cpdm_instr1_resp.rt = []
        _cpdm_instr1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr1Components = [cpdm_instr1_img, cpdm_instr1_title_txt, cpdm_instr1_txt, cpdm_instr1_Q_txt, cpdm_instr1_P_txt, cpdm_instr1_A_txt, cpdm_instr1_L_txt, cpdm_instr1_space_txt, cpdm_instr1_resp]
        for thisComponent in cpdm_instr1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr1_img* updates
            
            # if cpdm_instr1_img is starting this frame...
            if cpdm_instr1_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_img.frameNStart = frameN  # exact frame index
                cpdm_instr1_img.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_img.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_img, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_img.status = STARTED
                cpdm_instr1_img.setAutoDraw(True)
            
            # if cpdm_instr1_img is active this frame...
            if cpdm_instr1_img.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_title_txt* updates
            
            # if cpdm_instr1_title_txt is starting this frame...
            if cpdm_instr1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_title_txt.status = STARTED
                cpdm_instr1_title_txt.setAutoDraw(True)
            
            # if cpdm_instr1_title_txt is active this frame...
            if cpdm_instr1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_txt* updates
            
            # if cpdm_instr1_txt is starting this frame...
            if cpdm_instr1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_txt.status = STARTED
                cpdm_instr1_txt.setAutoDraw(True)
            
            # if cpdm_instr1_txt is active this frame...
            if cpdm_instr1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_Q_txt* updates
            
            # if cpdm_instr1_Q_txt is starting this frame...
            if cpdm_instr1_Q_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_Q_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_Q_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_Q_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_Q_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_Q_txt.status = STARTED
                cpdm_instr1_Q_txt.setAutoDraw(True)
            
            # if cpdm_instr1_Q_txt is active this frame...
            if cpdm_instr1_Q_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_P_txt* updates
            
            # if cpdm_instr1_P_txt is starting this frame...
            if cpdm_instr1_P_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_P_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_P_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_P_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_P_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_P_txt.status = STARTED
                cpdm_instr1_P_txt.setAutoDraw(True)
            
            # if cpdm_instr1_P_txt is active this frame...
            if cpdm_instr1_P_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_A_txt* updates
            
            # if cpdm_instr1_A_txt is starting this frame...
            if cpdm_instr1_A_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_A_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_A_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_A_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_A_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_A_txt.status = STARTED
                cpdm_instr1_A_txt.setAutoDraw(True)
            
            # if cpdm_instr1_A_txt is active this frame...
            if cpdm_instr1_A_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_L_txt* updates
            
            # if cpdm_instr1_L_txt is starting this frame...
            if cpdm_instr1_L_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_L_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_L_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_L_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_L_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_L_txt.status = STARTED
                cpdm_instr1_L_txt.setAutoDraw(True)
            
            # if cpdm_instr1_L_txt is active this frame...
            if cpdm_instr1_L_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_space_txt* updates
            
            # if cpdm_instr1_space_txt is starting this frame...
            if cpdm_instr1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_space_txt.status = STARTED
                cpdm_instr1_space_txt.setAutoDraw(True)
            
            # if cpdm_instr1_space_txt is active this frame...
            if cpdm_instr1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr1_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr1_resp is starting this frame...
            if cpdm_instr1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr1_resp.frameNStart = frameN  # exact frame index
                cpdm_instr1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr1_resp_allKeys):
                    cpdm_instr1_resp.keys = _cpdm_instr1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr1_resp.rt = _cpdm_instr1_resp_allKeys[-1].rt
                    cpdm_instr1_resp.duration = _cpdm_instr1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr1" ---
        for thisComponent in cpdm_instr1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr1.stopped', globalClock.getTime())
        # the Routine "cpdm_instr1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr2.started', globalClock.getTime())
        cpdm_instr2_resp.keys = []
        cpdm_instr2_resp.rt = []
        _cpdm_instr2_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr2Components = [cpdm_instr2_title_txt, cpdm_instr2_instr_txt, cpdm_instr2_left_arrow, cpdm_instr2_left_gabor, cpdm_instr2_left_txt, cpdm_instr2_right_arrow, cpdm_instr2_right_gabor, cpdm_instr2_right_txt, cpdm_instr2_space_txt, cpdm_instr2_resp]
        for thisComponent in cpdm_instr2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr2_title_txt* updates
            
            # if cpdm_instr2_title_txt is starting this frame...
            if cpdm_instr2_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_title_txt.status = STARTED
                cpdm_instr2_title_txt.setAutoDraw(True)
            
            # if cpdm_instr2_title_txt is active this frame...
            if cpdm_instr2_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_instr_txt* updates
            
            # if cpdm_instr2_instr_txt is starting this frame...
            if cpdm_instr2_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_instr_txt.status = STARTED
                cpdm_instr2_instr_txt.setAutoDraw(True)
            
            # if cpdm_instr2_instr_txt is active this frame...
            if cpdm_instr2_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_arrow* updates
            
            # if cpdm_instr2_left_arrow is starting this frame...
            if cpdm_instr2_left_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_arrow.status = STARTED
                cpdm_instr2_left_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_left_arrow is active this frame...
            if cpdm_instr2_left_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_gabor* updates
            
            # if cpdm_instr2_left_gabor is starting this frame...
            if cpdm_instr2_left_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_gabor.status = STARTED
                cpdm_instr2_left_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_left_gabor is active this frame...
            if cpdm_instr2_left_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_left_txt* updates
            
            # if cpdm_instr2_left_txt is starting this frame...
            if cpdm_instr2_left_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_left_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_left_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_left_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_left_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_left_txt.status = STARTED
                cpdm_instr2_left_txt.setAutoDraw(True)
            
            # if cpdm_instr2_left_txt is active this frame...
            if cpdm_instr2_left_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_arrow* updates
            
            # if cpdm_instr2_right_arrow is starting this frame...
            if cpdm_instr2_right_arrow.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_arrow.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_arrow.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_arrow.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_arrow, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_arrow.status = STARTED
                cpdm_instr2_right_arrow.setAutoDraw(True)
            
            # if cpdm_instr2_right_arrow is active this frame...
            if cpdm_instr2_right_arrow.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_gabor* updates
            
            # if cpdm_instr2_right_gabor is starting this frame...
            if cpdm_instr2_right_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_gabor.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_gabor.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_gabor, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_gabor.status = STARTED
                cpdm_instr2_right_gabor.setAutoDraw(True)
            
            # if cpdm_instr2_right_gabor is active this frame...
            if cpdm_instr2_right_gabor.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_right_txt* updates
            
            # if cpdm_instr2_right_txt is starting this frame...
            if cpdm_instr2_right_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_right_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_right_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_right_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_right_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_right_txt.status = STARTED
                cpdm_instr2_right_txt.setAutoDraw(True)
            
            # if cpdm_instr2_right_txt is active this frame...
            if cpdm_instr2_right_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_space_txt* updates
            
            # if cpdm_instr2_space_txt is starting this frame...
            if cpdm_instr2_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr2_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_space_txt.status = STARTED
                cpdm_instr2_space_txt.setAutoDraw(True)
            
            # if cpdm_instr2_space_txt is active this frame...
            if cpdm_instr2_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr2_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr2_resp is starting this frame...
            if cpdm_instr2_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr2_resp.frameNStart = frameN  # exact frame index
                cpdm_instr2_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr2_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr2_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr2_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr2_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr2_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr2_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr2_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr2_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr2_resp_allKeys):
                    cpdm_instr2_resp.keys = _cpdm_instr2_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr2_resp.rt = _cpdm_instr2_resp_allKeys[-1].rt
                    cpdm_instr2_resp.duration = _cpdm_instr2_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr2" ---
        for thisComponent in cpdm_instr2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr2.stopped', globalClock.getTime())
        # the Routine "cpdm_instr2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr3.started', globalClock.getTime())
        cpdm_instr3_resp.keys = []
        cpdm_instr3_resp.rt = []
        _cpdm_instr3_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr3Components = [cpdm_instr3_title_txt, cpdm_instr3_txt, cpdm_instr3_space_txt, cpdm_instr3_resp]
        for thisComponent in cpdm_instr3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr3_title_txt* updates
            
            # if cpdm_instr3_title_txt is starting this frame...
            if cpdm_instr3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_title_txt.status = STARTED
                cpdm_instr3_title_txt.setAutoDraw(True)
            
            # if cpdm_instr3_title_txt is active this frame...
            if cpdm_instr3_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_txt* updates
            
            # if cpdm_instr3_txt is starting this frame...
            if cpdm_instr3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_txt.status = STARTED
                cpdm_instr3_txt.setAutoDraw(True)
            
            # if cpdm_instr3_txt is active this frame...
            if cpdm_instr3_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_space_txt* updates
            
            # if cpdm_instr3_space_txt is starting this frame...
            if cpdm_instr3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr3_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_space_txt.status = STARTED
                cpdm_instr3_space_txt.setAutoDraw(True)
            
            # if cpdm_instr3_space_txt is active this frame...
            if cpdm_instr3_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr3_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr3_resp is starting this frame...
            if cpdm_instr3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr3_resp.frameNStart = frameN  # exact frame index
                cpdm_instr3_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr3_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr3_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr3_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr3_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr3_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr3_resp_allKeys):
                    cpdm_instr3_resp.keys = _cpdm_instr3_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr3_resp.rt = _cpdm_instr3_resp_allKeys[-1].rt
                    cpdm_instr3_resp.duration = _cpdm_instr3_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr3" ---
        for thisComponent in cpdm_instr3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr3.stopped', globalClock.getTime())
        # the Routine "cpdm_instr3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_instr4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_instr4.started', globalClock.getTime())
        cpdm_instr4_resp.keys = []
        cpdm_instr4_resp.rt = []
        _cpdm_instr4_resp_allKeys = []
        # keep track of which components have finished
        cpdm_instr4Components = [cpdm_instr4_title_txt, cpdm_instr4_txt, cpdm_instr4_space_txt, cpdm_instr4_resp]
        for thisComponent in cpdm_instr4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_instr4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_instr4_title_txt* updates
            
            # if cpdm_instr4_title_txt is starting this frame...
            if cpdm_instr4_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_title_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_title_txt.status = STARTED
                cpdm_instr4_title_txt.setAutoDraw(True)
            
            # if cpdm_instr4_title_txt is active this frame...
            if cpdm_instr4_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_txt* updates
            
            # if cpdm_instr4_txt is starting this frame...
            if cpdm_instr4_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_txt.status = STARTED
                cpdm_instr4_txt.setAutoDraw(True)
            
            # if cpdm_instr4_txt is active this frame...
            if cpdm_instr4_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_space_txt* updates
            
            # if cpdm_instr4_space_txt is starting this frame...
            if cpdm_instr4_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_space_txt.frameNStart = frameN  # exact frame index
                cpdm_instr4_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_space_txt.status = STARTED
                cpdm_instr4_space_txt.setAutoDraw(True)
            
            # if cpdm_instr4_space_txt is active this frame...
            if cpdm_instr4_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_instr4_resp* updates
            waitOnFlip = False
            
            # if cpdm_instr4_resp is starting this frame...
            if cpdm_instr4_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_instr4_resp.frameNStart = frameN  # exact frame index
                cpdm_instr4_resp.tStart = t  # local t and not account for scr refresh
                cpdm_instr4_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_instr4_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_instr4_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_instr4_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_instr4_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_instr4_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_instr4_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_instr4_resp_allKeys.extend(theseKeys)
                if len(_cpdm_instr4_resp_allKeys):
                    cpdm_instr4_resp.keys = _cpdm_instr4_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_instr4_resp.rt = _cpdm_instr4_resp_allKeys[-1].rt
                    cpdm_instr4_resp.duration = _cpdm_instr4_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_instr4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_instr4" ---
        for thisComponent in cpdm_instr4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_instr4.stopped', globalClock.getTime())
        # the Routine "cpdm_instr4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_warn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_warn.started', globalClock.getTime())
        cpdm_warn1_resp.keys = []
        cpdm_warn1_resp.rt = []
        _cpdm_warn1_resp_allKeys = []
        # keep track of which components have finished
        cpdm_warnComponents = [cpdm_warn1_title_txt, cpdm_warn1_txt, cpdm_warn1_space_txt, cpdm_warn1_resp]
        for thisComponent in cpdm_warnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_warn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_warn1_title_txt* updates
            
            # if cpdm_warn1_title_txt is starting this frame...
            if cpdm_warn1_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_title_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_title_txt.status = STARTED
                cpdm_warn1_title_txt.setAutoDraw(True)
            
            # if cpdm_warn1_title_txt is active this frame...
            if cpdm_warn1_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_txt* updates
            
            # if cpdm_warn1_txt is starting this frame...
            if cpdm_warn1_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_txt.status = STARTED
                cpdm_warn1_txt.setAutoDraw(True)
            
            # if cpdm_warn1_txt is active this frame...
            if cpdm_warn1_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_space_txt* updates
            
            # if cpdm_warn1_space_txt is starting this frame...
            if cpdm_warn1_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_space_txt.frameNStart = frameN  # exact frame index
                cpdm_warn1_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_space_txt.status = STARTED
                cpdm_warn1_space_txt.setAutoDraw(True)
            
            # if cpdm_warn1_space_txt is active this frame...
            if cpdm_warn1_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_warn1_resp* updates
            waitOnFlip = False
            
            # if cpdm_warn1_resp is starting this frame...
            if cpdm_warn1_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_warn1_resp.frameNStart = frameN  # exact frame index
                cpdm_warn1_resp.tStart = t  # local t and not account for scr refresh
                cpdm_warn1_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_warn1_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_warn1_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_warn1_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_warn1_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_warn1_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_warn1_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_warn1_resp_allKeys.extend(theseKeys)
                if len(_cpdm_warn1_resp_allKeys):
                    cpdm_warn1_resp.keys = _cpdm_warn1_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_warn1_resp.rt = _cpdm_warn1_resp_allKeys[-1].rt
                    cpdm_warn1_resp.duration = _cpdm_warn1_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_warnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_warn" ---
        for thisComponent in cpdm_warnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_warn.stopped', globalClock.getTime())
        # the Routine "cpdm_warn" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_pract_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_pract_instr.started', globalClock.getTime())
        cpdm_pract_instr_resp.keys = []
        cpdm_pract_instr_resp.rt = []
        _cpdm_pract_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_pract_instrComponents = [cpdm_pract_instr_title_txt, cpdm_pract_instr_txt, cpdm_pract_instr_space_txt, cpdm_pract_instr_resp]
        for thisComponent in cpdm_pract_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_pract_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_pract_instr_title_txt* updates
            
            # if cpdm_pract_instr_title_txt is starting this frame...
            if cpdm_pract_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_title_txt.status = STARTED
                cpdm_pract_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_title_txt is active this frame...
            if cpdm_pract_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_txt* updates
            
            # if cpdm_pract_instr_txt is starting this frame...
            if cpdm_pract_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_txt.status = STARTED
                cpdm_pract_instr_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_txt is active this frame...
            if cpdm_pract_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_space_txt* updates
            
            # if cpdm_pract_instr_space_txt is starting this frame...
            if cpdm_pract_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_space_txt.status = STARTED
                cpdm_pract_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_pract_instr_space_txt is active this frame...
            if cpdm_pract_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_pract_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_pract_instr_resp is starting this frame...
            if cpdm_pract_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_pract_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_pract_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_pract_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_pract_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_pract_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_pract_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_pract_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_pract_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_pract_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_pract_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_pract_instr_resp_allKeys):
                    cpdm_pract_instr_resp.keys = _cpdm_pract_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_pract_instr_resp.rt = _cpdm_pract_instr_resp_allKeys[-1].rt
                    cpdm_pract_instr_resp.duration = _cpdm_pract_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_pract_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_pract_instr" ---
        for thisComponent in cpdm_pract_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_pract_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_pract_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "cpdm_init_fix" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
        # keep track of which components have finished
        cpdm_init_fixComponents = [cpdm_init_fix_poly]
        for thisComponent in cpdm_init_fixComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_init_fix" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_init_fix_poly* updates
            
            # if cpdm_init_fix_poly is starting this frame...
            if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_init_fix_poly.status = STARTED
                cpdm_init_fix_poly.setAutoDraw(True)
            
            # if cpdm_init_fix_poly is active this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # update params
                pass
            
            # if cpdm_init_fix_poly is stopping this frame...
            if cpdm_init_fix_poly.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                    cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                    # update status
                    cpdm_init_fix_poly.status = FINISHED
                    cpdm_init_fix_poly.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_init_fix" ---
        for thisComponent in cpdm_init_fixComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        cpdm_pract_trials3 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_practice.xlsx'),
            seed=None, name='cpdm_pract_trials3')
        thisExp.addLoop(cpdm_pract_trials3)  # add the loop to the experiment
        thisCpdm_pract_trials3 = cpdm_pract_trials3.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials3.rgb)
        if thisCpdm_pract_trials3 != None:
            for paramName in thisCpdm_pract_trials3:
                globals()[paramName] = thisCpdm_pract_trials3[paramName]
        
        for thisCpdm_pract_trials3 in cpdm_pract_trials3:
            currentLoop = cpdm_pract_trials3
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_pract_trials3.rgb)
            if thisCpdm_pract_trials3 != None:
                for paramName in thisCpdm_pract_trials3:
                    globals()[paramName] = thisCpdm_pract_trials3[paramName]
            
            # --- Prepare to start Routine "cpdm_pract_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_trial.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_trial_code
            my_loop = eval(practice_loop_name)
            trial_acc = 0
            trial_conf = 0 
            
            #set default gray for all four response boxes
            left_high_color = [0,0,0] 
            left_low_color = [0,0,0]
            right_high_color = [0,0,0]
            right_low_color = [0,0,0]
            
            is_clockwise = False 
            if cpdm_gabor_orient > 0.0: 
                is_clockwise = True
            elif cpdm_gabor_orient == 0.0: 
                rand_num = random.randint(1,2)
                if rand_num == 1:
                    is_clockwise = True
                else:
                    is_clockwise = False
            cpdm_pract_trial_gabor.setContrast(cpdm_gabor_contrast)
            cpdm_pract_trial_gabor.setOri(cpdm_gabor_orient)
            cpdm_pract_trial_resp.keys = []
            cpdm_pract_trial_resp.rt = []
            _cpdm_pract_trial_resp_allKeys = []
            # keep track of which components have finished
            cpdm_pract_trialComponents = [cpdm_pract_trial_gabor, cpdm_pract_trial_left_high_poly, cpdm_pract_trial_right_high_poly, cpdm_pract_trial_left_low_poly, cpdm_pract_trial_right_low_poly, cpdm_pract_trial_left_high_txt, cpdm_pract_trial_right_high_txt, cpdm_pract_trial_left_low_txt, cpdm_pract_trial_right_low_txt, cpdm_pract_trial_resp]
            for thisComponent in cpdm_pract_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.3:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                # Run 'Each Frame' code from cpdm_pract_trial_code
                #each trial and resp
                #checks which key Ss pressed and changed the color of the selected box
                #depending on correctness of selection
                #also changes correct_resp variable which is recorded in End Routine
                
                #resp is received
                key = cpdm_pract_trial_resp.keys
                if len(key) == 1: 
                    #Ss selected Left-High
                    if key == "q": 
                        trial_conf = 1
                        #and correct resp is Left
                        if is_clockwise == False: 
                            #change upper-left box to green
                            left_high_color = "green" 
                            #set correct resp to 1
                            trial_acc = 1 
                        #incorrect left resp
                        else: 
                            left_high_color = "red"
                    elif key == "a":
                        #correct left resp
                        if is_clockwise == False: 
                            left_low_color = "green"
                            trial_acc = 1
                        else:
                            left_low_color = "red"
                    elif key == "p":
                        trial_conf = 1
                        #correct right resp
                        if is_clockwise == True: 
                            right_high_color = "green"
                            trial_acc = 1
                            trial_conf = 1
                        #incorrect right resp
                        else: 
                            right_high_color = "red"
                    elif key == "l":
                        #correct right resp
                        if is_clockwise == True: 
                            right_low_color = "green"
                            trial_acc = 1
                        #incorrect right resp
                        else: 
                            right_low_color = "red"
                
                # *cpdm_pract_trial_gabor* updates
                
                # if cpdm_pract_trial_gabor is starting this frame...
                if cpdm_pract_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_gabor.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_gabor.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_gabor.status = STARTED
                    cpdm_pract_trial_gabor.setAutoDraw(True)
                
                # if cpdm_pract_trial_gabor is active this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_gabor is stopping this frame...
                if cpdm_pract_trial_gabor.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_gabor.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_gabor.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_gabor.status = FINISHED
                        cpdm_pract_trial_gabor.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_poly* updates
                
                # if cpdm_pract_trial_left_high_poly is starting this frame...
                if cpdm_pract_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_poly.status = STARTED
                    cpdm_pract_trial_left_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_poly is active this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_high_poly.setFillColor(left_high_color, log=False)
                
                # if cpdm_pract_trial_left_high_poly is stopping this frame...
                if cpdm_pract_trial_left_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_poly.status = FINISHED
                        cpdm_pract_trial_left_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_poly* updates
                
                # if cpdm_pract_trial_right_high_poly is starting this frame...
                if cpdm_pract_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_poly.status = STARTED
                    cpdm_pract_trial_right_high_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_poly is active this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_high_poly.setFillColor(right_high_color, log=False)
                
                # if cpdm_pract_trial_right_high_poly is stopping this frame...
                if cpdm_pract_trial_right_high_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_poly.status = FINISHED
                        cpdm_pract_trial_right_high_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_poly* updates
                
                # if cpdm_pract_trial_left_low_poly is starting this frame...
                if cpdm_pract_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_poly.status = STARTED
                    cpdm_pract_trial_left_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_poly is active this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_left_low_poly.setFillColor(left_low_color, log=False)
                
                # if cpdm_pract_trial_left_low_poly is stopping this frame...
                if cpdm_pract_trial_left_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_poly.status = FINISHED
                        cpdm_pract_trial_left_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_poly* updates
                
                # if cpdm_pract_trial_right_low_poly is starting this frame...
                if cpdm_pract_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_poly.status = STARTED
                    cpdm_pract_trial_right_low_poly.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_poly is active this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # update params
                    cpdm_pract_trial_right_low_poly.setFillColor(right_low_color, log=False)
                
                # if cpdm_pract_trial_right_low_poly is stopping this frame...
                if cpdm_pract_trial_right_low_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_poly.status = FINISHED
                        cpdm_pract_trial_right_low_poly.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_high_txt* updates
                
                # if cpdm_pract_trial_left_high_txt is starting this frame...
                if cpdm_pract_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_high_txt.status = STARTED
                    cpdm_pract_trial_left_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_high_txt is active this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_high_txt is stopping this frame...
                if cpdm_pract_trial_left_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_high_txt.status = FINISHED
                        cpdm_pract_trial_left_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_high_txt* updates
                
                # if cpdm_pract_trial_right_high_txt is starting this frame...
                if cpdm_pract_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_high_txt.status = STARTED
                    cpdm_pract_trial_right_high_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_high_txt is active this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_high_txt is stopping this frame...
                if cpdm_pract_trial_right_high_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_high_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_high_txt.status = FINISHED
                        cpdm_pract_trial_right_high_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_left_low_txt* updates
                
                # if cpdm_pract_trial_left_low_txt is starting this frame...
                if cpdm_pract_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_left_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_left_low_txt.status = STARTED
                    cpdm_pract_trial_left_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_left_low_txt is active this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_left_low_txt is stopping this frame...
                if cpdm_pract_trial_left_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_left_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_left_low_txt.status = FINISHED
                        cpdm_pract_trial_left_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_right_low_txt* updates
                
                # if cpdm_pract_trial_right_low_txt is starting this frame...
                if cpdm_pract_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_right_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_right_low_txt.status = STARTED
                    cpdm_pract_trial_right_low_txt.setAutoDraw(True)
                
                # if cpdm_pract_trial_right_low_txt is active this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_trial_right_low_txt is stopping this frame...
                if cpdm_pract_trial_right_low_txt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_right_low_txt.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_right_low_txt.status = FINISHED
                        cpdm_pract_trial_right_low_txt.setAutoDraw(False)
                
                # *cpdm_pract_trial_resp* updates
                waitOnFlip = False
                
                # if cpdm_pract_trial_resp is starting this frame...
                if cpdm_pract_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_trial_resp.frameNStart = frameN  # exact frame index
                    cpdm_pract_trial_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_trial_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_trial_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_pract_trial_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_pract_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if cpdm_pract_trial_resp is stopping this frame...
                if cpdm_pract_trial_resp.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_trial_resp.tStartRefresh + 2-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_trial_resp.tStop = t  # not accounting for scr refresh
                        cpdm_pract_trial_resp.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_trial_resp.status = FINISHED
                        cpdm_pract_trial_resp.status = FINISHED
                if cpdm_pract_trial_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_pract_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_pract_trial_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_pract_trial_resp_allKeys):
                        cpdm_pract_trial_resp.keys = _cpdm_pract_trial_resp_allKeys[0].name  # just the first key pressed
                        cpdm_pract_trial_resp.rt = _cpdm_pract_trial_resp_allKeys[0].rt
                        cpdm_pract_trial_resp.duration = _cpdm_pract_trial_resp_allKeys[0].duration
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_trial" ---
            for thisComponent in cpdm_pract_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_trial.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_pract_trial_code
            my_loop.addData("cpdm_pract_acc", trial_acc)
            my_loop.addData("cpdm_pract_conf", trial_conf)
            my_loop.addData("cpdm_trial_type", "practice")
            
            # check responses
            if cpdm_pract_trial_resp.keys in ['', [], None]:  # No response was made
                cpdm_pract_trial_resp.keys = None
            cpdm_pract_trials3.addData('cpdm_pract_trial_resp.keys',cpdm_pract_trial_resp.keys)
            if cpdm_pract_trial_resp.keys != None:  # we had a response
                cpdm_pract_trials3.addData('cpdm_pract_trial_resp.rt', cpdm_pract_trial_resp.rt)
                cpdm_pract_trials3.addData('cpdm_pract_trial_resp.duration', cpdm_pract_trial_resp.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.300000)
            
            # --- Prepare to start Routine "cpdm_pract_iti3" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_pract_iti3.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_pract_iti3_code
            #3 CPDM practice trials
            if cpdm_pract_trials3.thisTrialN == 4:
                continueRoutine = False
            # keep track of which components have finished
            cpdm_pract_iti3Components = [cpdm_pract_iti3_poly]
            for thisComponent in cpdm_pract_iti3Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_pract_iti3" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 2.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_pract_iti3_poly* updates
                
                # if cpdm_pract_iti3_poly is starting this frame...
                if cpdm_pract_iti3_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_pract_iti3_poly.frameNStart = frameN  # exact frame index
                    cpdm_pract_iti3_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_pract_iti3_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_pract_iti3_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_pract_iti3_poly.status = STARTED
                    cpdm_pract_iti3_poly.setAutoDraw(True)
                
                # if cpdm_pract_iti3_poly is active this frame...
                if cpdm_pract_iti3_poly.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_pract_iti3_poly is stopping this frame...
                if cpdm_pract_iti3_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_pract_iti3_poly.tStartRefresh + 2.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_pract_iti3_poly.tStop = t  # not accounting for scr refresh
                        cpdm_pract_iti3_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_pract_iti3_poly.status = FINISHED
                        cpdm_pract_iti3_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_pract_iti3Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_pract_iti3" ---
            for thisComponent in cpdm_pract_iti3Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_pract_iti3.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-2.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'cpdm_pract_trials3'
        
        
        # --- Prepare to start Routine "cpdm_trial_instr" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('cpdm_trial_instr.started', globalClock.getTime())
        cpdm_trial_instr_resp.keys = []
        cpdm_trial_instr_resp.rt = []
        _cpdm_trial_instr_resp_allKeys = []
        # keep track of which components have finished
        cpdm_trial_instrComponents = [cpdm_trial_instr_title_txt, cpdm_trial_instr_txt, cpdm_trial_instr_space_txt, cpdm_trial_instr_resp]
        for thisComponent in cpdm_trial_instrComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "cpdm_trial_instr" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *cpdm_trial_instr_title_txt* updates
            
            # if cpdm_trial_instr_title_txt is starting this frame...
            if cpdm_trial_instr_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_title_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_title_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_title_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_title_txt.status = STARTED
                cpdm_trial_instr_title_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_title_txt is active this frame...
            if cpdm_trial_instr_title_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_txt* updates
            
            # if cpdm_trial_instr_txt is starting this frame...
            if cpdm_trial_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_txt.status = STARTED
                cpdm_trial_instr_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_txt is active this frame...
            if cpdm_trial_instr_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_space_txt* updates
            
            # if cpdm_trial_instr_space_txt is starting this frame...
            if cpdm_trial_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_space_txt.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_space_txt.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_space_txt.status = STARTED
                cpdm_trial_instr_space_txt.setAutoDraw(True)
            
            # if cpdm_trial_instr_space_txt is active this frame...
            if cpdm_trial_instr_space_txt.status == STARTED:
                # update params
                pass
            
            # *cpdm_trial_instr_resp* updates
            waitOnFlip = False
            
            # if cpdm_trial_instr_resp is starting this frame...
            if cpdm_trial_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cpdm_trial_instr_resp.frameNStart = frameN  # exact frame index
                cpdm_trial_instr_resp.tStart = t  # local t and not account for scr refresh
                cpdm_trial_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cpdm_trial_instr_resp, 'tStartRefresh')  # time at next scr refresh
                # update status
                cpdm_trial_instr_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(cpdm_trial_instr_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(cpdm_trial_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if cpdm_trial_instr_resp.status == STARTED and not waitOnFlip:
                theseKeys = cpdm_trial_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _cpdm_trial_instr_resp_allKeys.extend(theseKeys)
                if len(_cpdm_trial_instr_resp_allKeys):
                    cpdm_trial_instr_resp.keys = _cpdm_trial_instr_resp_allKeys[-1].name  # just the last key pressed
                    cpdm_trial_instr_resp.rt = _cpdm_trial_instr_resp_allKeys[-1].rt
                    cpdm_trial_instr_resp.duration = _cpdm_trial_instr_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in cpdm_trial_instrComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "cpdm_trial_instr" ---
        for thisComponent in cpdm_trial_instrComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('cpdm_trial_instr.stopped', globalClock.getTime())
        # the Routine "cpdm_trial_instr" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        condition_runs3 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('cpdm/cpdm_run_type.xlsx'),
            seed=None, name='condition_runs3')
        thisExp.addLoop(condition_runs3)  # add the loop to the experiment
        thisCondition_runs3 = condition_runs3.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs3.rgb)
        if thisCondition_runs3 != None:
            for paramName in thisCondition_runs3:
                globals()[paramName] = thisCondition_runs3[paramName]
        
        for thisCondition_runs3 in condition_runs3:
            currentLoop = condition_runs3
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisCondition_runs3.rgb)
            if thisCondition_runs3 != None:
                for paramName in thisCondition_runs3:
                    globals()[paramName] = thisCondition_runs3[paramName]
            
            # --- Prepare to start Routine "cpdm_run_setter" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_setter.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_setter_code
            #Block QC check variables
            run_resps = []
            cpdm_catch_trials = []
            
            #selects contrast schedule depending on run type
            #low volatility
            run_schedule = "cpdm/cpdm-1contrast.xlsx" 
            
            #flexible response text for high confidence options depending on run type
            if "low_risk" in cpdm_run_dimension:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $9 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $9 or $0"
            else:
                left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $13 or $0"
                right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $13 or $0"
            
            #create list of 200 random ITIs
            #iterate through list of ITIs, multiple by number of floats, divide by sum of original list
            #creates random list of ITI value for each trial which sum to 200
            cpdm_iti_list = [random.random() for i in range(200)] 
            cpdm_s = sum(cpdm_iti_list) 
            cpdm_iti_list = [i*200/cpdm_s for i in cpdm_iti_list]
            # keep track of which components have finished
            cpdm_run_setterComponents = []
            for thisComponent in cpdm_run_setterComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_setter" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_setterComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_setter" ---
            for thisComponent in cpdm_run_setterComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_setter.stopped', globalClock.getTime())
            # the Routine "cpdm_run_setter" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_loop_instr" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_loop_instr.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_loop_instr_code
            if "low_risk" in cpdm_run_dimension:
                corr_high_txt = "Correct \n High Confidence \n $9"
            else:
                corr_high_txt = "Correct \n High Confidence \n $13"
            cpdm_loop_instr_code2.setText("Block " + str(run_counter))
            cpdm_loop_instr_corr_high_txt.setText(corr_high_txt)
            cpdm_loop_instr_resp.keys = []
            cpdm_loop_instr_resp.rt = []
            _cpdm_loop_instr_resp_allKeys = []
            # keep track of which components have finished
            cpdm_loop_instrComponents = [cpdm_loop_instr_code2, cpdm_loop_instr_corr_high_poly, cpdm_loop_instr_right_high_poly, cpdm_loop_instr_left_low_poly, cpdm_loop_instr_right_low_poly, cpdm_loop_instr_corr_high_txt, cpdm_loop_instr_incorr_high_txt, cpdm_loop_instr_corr_low_txt, cpdm_loop_instr_incorr_low, cpdm_loop_instr_space_txt, cpdm_loop_instr_resp]
            for thisComponent in cpdm_loop_instrComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_loop_instr" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_loop_instr_code2* updates
                
                # if cpdm_loop_instr_code2 is starting this frame...
                if cpdm_loop_instr_code2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_code2.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_code2.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_code2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_code2, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_code2.status = STARTED
                    cpdm_loop_instr_code2.setAutoDraw(True)
                
                # if cpdm_loop_instr_code2 is active this frame...
                if cpdm_loop_instr_code2.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_poly* updates
                
                # if cpdm_loop_instr_corr_high_poly is starting this frame...
                if cpdm_loop_instr_corr_high_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_poly.status = STARTED
                    cpdm_loop_instr_corr_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_poly is active this frame...
                if cpdm_loop_instr_corr_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_high_poly* updates
                
                # if cpdm_loop_instr_right_high_poly is starting this frame...
                if cpdm_loop_instr_right_high_poly.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_high_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_high_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_high_poly.status = STARTED
                    cpdm_loop_instr_right_high_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_high_poly is active this frame...
                if cpdm_loop_instr_right_high_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_left_low_poly* updates
                
                # if cpdm_loop_instr_left_low_poly is starting this frame...
                if cpdm_loop_instr_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_left_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_left_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_left_low_poly.status = STARTED
                    cpdm_loop_instr_left_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_left_low_poly is active this frame...
                if cpdm_loop_instr_left_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_right_low_poly* updates
                
                # if cpdm_loop_instr_right_low_poly is starting this frame...
                if cpdm_loop_instr_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_right_low_poly.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_right_low_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_right_low_poly.status = STARTED
                    cpdm_loop_instr_right_low_poly.setAutoDraw(True)
                
                # if cpdm_loop_instr_right_low_poly is active this frame...
                if cpdm_loop_instr_right_low_poly.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_high_txt* updates
                
                # if cpdm_loop_instr_corr_high_txt is starting this frame...
                if cpdm_loop_instr_corr_high_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_high_txt.status = STARTED
                    cpdm_loop_instr_corr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_high_txt is active this frame...
                if cpdm_loop_instr_corr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_high_txt* updates
                
                # if cpdm_loop_instr_incorr_high_txt is starting this frame...
                if cpdm_loop_instr_incorr_high_txt.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_high_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_high_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_high_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_high_txt.status = STARTED
                    cpdm_loop_instr_incorr_high_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_high_txt is active this frame...
                if cpdm_loop_instr_incorr_high_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_corr_low_txt* updates
                
                # if cpdm_loop_instr_corr_low_txt is starting this frame...
                if cpdm_loop_instr_corr_low_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_corr_low_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_corr_low_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_corr_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_corr_low_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_corr_low_txt.status = STARTED
                    cpdm_loop_instr_corr_low_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_corr_low_txt is active this frame...
                if cpdm_loop_instr_corr_low_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_incorr_low* updates
                
                # if cpdm_loop_instr_incorr_low is starting this frame...
                if cpdm_loop_instr_incorr_low.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_incorr_low.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_incorr_low.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_incorr_low.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_incorr_low, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_incorr_low.status = STARTED
                    cpdm_loop_instr_incorr_low.setAutoDraw(True)
                
                # if cpdm_loop_instr_incorr_low is active this frame...
                if cpdm_loop_instr_incorr_low.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_space_txt* updates
                
                # if cpdm_loop_instr_space_txt is starting this frame...
                if cpdm_loop_instr_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_space_txt.status = STARTED
                    cpdm_loop_instr_space_txt.setAutoDraw(True)
                
                # if cpdm_loop_instr_space_txt is active this frame...
                if cpdm_loop_instr_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_loop_instr_resp* updates
                waitOnFlip = False
                
                # if cpdm_loop_instr_resp is starting this frame...
                if cpdm_loop_instr_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_loop_instr_resp.frameNStart = frameN  # exact frame index
                    cpdm_loop_instr_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_loop_instr_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_loop_instr_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_loop_instr_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_loop_instr_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_loop_instr_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_loop_instr_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_loop_instr_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_loop_instr_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_loop_instr_resp_allKeys):
                        cpdm_loop_instr_resp.keys = _cpdm_loop_instr_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_loop_instr_resp.rt = _cpdm_loop_instr_resp_allKeys[-1].rt
                        cpdm_loop_instr_resp.duration = _cpdm_loop_instr_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_loop_instrComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_loop_instr" ---
            for thisComponent in cpdm_loop_instrComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_loop_instr.stopped', globalClock.getTime())
            # Run 'End Routine' code from cpdm_loop_instr_code
            run_counter += 1
            # the Routine "cpdm_loop_instr" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "cpdm_init_fix" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_init_fix.started', globalClock.getTime())
            # keep track of which components have finished
            cpdm_init_fixComponents = [cpdm_init_fix_poly]
            for thisComponent in cpdm_init_fixComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_init_fix" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_init_fix_poly* updates
                
                # if cpdm_init_fix_poly is starting this frame...
                if cpdm_init_fix_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_init_fix_poly.frameNStart = frameN  # exact frame index
                    cpdm_init_fix_poly.tStart = t  # local t and not account for scr refresh
                    cpdm_init_fix_poly.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_init_fix_poly, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_init_fix_poly.status = STARTED
                    cpdm_init_fix_poly.setAutoDraw(True)
                
                # if cpdm_init_fix_poly is active this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # update params
                    pass
                
                # if cpdm_init_fix_poly is stopping this frame...
                if cpdm_init_fix_poly.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > cpdm_init_fix_poly.tStartRefresh + 1.0-frameTolerance:
                        # keep track of stop time/frame for later
                        cpdm_init_fix_poly.tStop = t  # not accounting for scr refresh
                        cpdm_init_fix_poly.frameNStop = frameN  # exact frame index
                        # update status
                        cpdm_init_fix_poly.status = FINISHED
                        cpdm_init_fix_poly.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_init_fixComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_init_fix" ---
            for thisComponent in cpdm_init_fixComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_init_fix.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # set up handler to look after randomisation of conditions etc
            cpdm_trials3 = data.TrialHandler(nReps=1.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=data.importConditions('cpdm/cpdm-1contrast.xlsx'),
                seed=None, name='cpdm_trials3')
            thisExp.addLoop(cpdm_trials3)  # add the loop to the experiment
            thisCpdm_trials3 = cpdm_trials3.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials3.rgb)
            if thisCpdm_trials3 != None:
                for paramName in thisCpdm_trials3:
                    globals()[paramName] = thisCpdm_trials3[paramName]
            
            for thisCpdm_trials3 in cpdm_trials3:
                currentLoop = cpdm_trials3
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisCpdm_trials3.rgb)
                if thisCpdm_trials3 != None:
                    for paramName in thisCpdm_trials3:
                        globals()[paramName] = thisCpdm_trials3[paramName]
                
                # --- Prepare to start Routine "cpdm_trial" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trial.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trial_code
                my_loop = eval(cpdm_loop_name)
                cpdm_stop_timer = None
                cpdm_stopped_time = 0
                cpdm_trial_acc = 0
                cpdm_trial_conf = 0 
                
                #set default gray for all four response boxes
                left_high_color = [0,0,0] 
                left_low_color = [0,0,0]
                right_high_color = [0,0,0]
                right_low_color = [0,0,0]
                
                is_clockwise = False
                if cpdm_gabor_orient > 0.0: 
                    is_clockwise = True
                elif cpdm_gabor_orient == 0.0: 
                    cpdm_rand_num = random.randint(1,2)
                    if cpdm_rand_num == 1:
                        is_clockwise = True
                    else:
                        is_clockwise = False
                cpdm_trial_gabor.setContrast(cpdm_gabor_contrast)
                cpdm_trial_gabor.setOri(cpdm_gabor_orient)
                cpdm_trial_left_high_txt.setText(left_resp_txt)
                cpdm_trial_right_high_txt.setText(right_resp_txt)
                cpdm_trial_resp.keys = []
                cpdm_trial_resp.rt = []
                _cpdm_trial_resp_allKeys = []
                # keep track of which components have finished
                cpdm_trialComponents = [cpdm_trial_gabor, cpdm_trial_left_high_poly, cpdm_trial_right_high_poly, cpdm_trial_left_low_poly, cpdm_trial_right_low_poly, cpdm_trial_left_high_txt, cpdm_trial_right_high_txt, cpdm_trial_left_low_txt, cpdm_trial_right_low_txt, cpdm_trial_resp]
                for thisComponent in cpdm_trialComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trial" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 2.3:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    # Run 'Each Frame' code from cpdm_trial_code
                    #checks if resp is received for each trial and which key was pressed
                    #depending on which key is pressed, respective box color changes and
                    #correct_resp variable is updated if correct (preassigned to 0)
                    key = cpdm_trial_resp.keys
                    if len(key) == 1:
                        if stop_timer == None:
                            stop_timer = core.Clock() 
                        else:
                            stopped_time = stop_timer.getTime()
                            if stopped_time >= 0.5:
                                continueRoutine = False
                        #Left - High Confidence
                        if key == "q":
                            trial_conf = 1
                            #correct left resp
                            if is_clockwise == False: 
                                #indicates selection without performance feedback
                                left_high_color = "darkgray" 
                                #indicate correct resp for current trial
                                trial_acc = 1 
                            #incorrect left resp
                            else: 
                                left_high_color = "darkgray"
                        #Left - Low Confidence
                        elif key == "a":
                            #correct left resp
                            if is_clockwise == False: 
                                left_low_color = "darkgray"
                                trial_acc = 1
                            else:
                                left_low_color = "darkgray"
                        #Right - High Confidence
                        elif key == "p":
                            trial_conf = 1
                            #correct right resp
                            if is_clockwise == True: 
                                right_high_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_high_color = "darkgray"
                        #Right - Low Confidence
                        elif key == "l": 
                            #correct right resp
                            if is_clockwise == True: 
                                right_low_color = "darkgray"
                                trial_acc = 1
                            #incorrect right resp
                            else: 
                                right_low_color = "darkgray"
                    
                    # *cpdm_trial_gabor* updates
                    
                    # if cpdm_trial_gabor is starting this frame...
                    if cpdm_trial_gabor.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_gabor.frameNStart = frameN  # exact frame index
                        cpdm_trial_gabor.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_gabor.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_gabor, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.started')
                        # update status
                        cpdm_trial_gabor.status = STARTED
                        cpdm_trial_gabor.setAutoDraw(True)
                    
                    # if cpdm_trial_gabor is active this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_gabor is stopping this frame...
                    if cpdm_trial_gabor.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_gabor.tStartRefresh + 0.3-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_gabor.tStop = t  # not accounting for scr refresh
                            cpdm_trial_gabor.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trial_gabor.stopped')
                            # update status
                            cpdm_trial_gabor.status = FINISHED
                            cpdm_trial_gabor.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_poly* updates
                    
                    # if cpdm_trial_left_high_poly is starting this frame...
                    if cpdm_trial_left_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_poly.status = STARTED
                        cpdm_trial_left_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_poly is active this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_high_poly.setFillColor(left_high_color, log=False)
                    
                    # if cpdm_trial_left_high_poly is stopping this frame...
                    if cpdm_trial_left_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_poly.status = FINISHED
                            cpdm_trial_left_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_poly* updates
                    
                    # if cpdm_trial_right_high_poly is starting this frame...
                    if cpdm_trial_right_high_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_poly.status = STARTED
                        cpdm_trial_right_high_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_poly is active this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_high_poly.setFillColor(right_high_color, log=False)
                    
                    # if cpdm_trial_right_high_poly is stopping this frame...
                    if cpdm_trial_right_high_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_poly.status = FINISHED
                            cpdm_trial_right_high_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_poly* updates
                    
                    # if cpdm_trial_left_low_poly is starting this frame...
                    if cpdm_trial_left_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_poly.status = STARTED
                        cpdm_trial_left_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_poly is active this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_left_low_poly.setFillColor(left_low_color, log=False)
                    
                    # if cpdm_trial_left_low_poly is stopping this frame...
                    if cpdm_trial_left_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_poly.status = FINISHED
                            cpdm_trial_left_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_poly* updates
                    
                    # if cpdm_trial_right_low_poly is starting this frame...
                    if cpdm_trial_right_low_poly.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_poly.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_poly, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_poly.status = STARTED
                        cpdm_trial_right_low_poly.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_poly is active this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # update params
                        cpdm_trial_right_low_poly.setFillColor(right_low_color, log=False)
                    
                    # if cpdm_trial_right_low_poly is stopping this frame...
                    if cpdm_trial_right_low_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_poly.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_poly.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_poly.status = FINISHED
                            cpdm_trial_right_low_poly.setAutoDraw(False)
                    
                    # *cpdm_trial_left_high_txt* updates
                    
                    # if cpdm_trial_left_high_txt is starting this frame...
                    if cpdm_trial_left_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_high_txt.status = STARTED
                        cpdm_trial_left_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_high_txt is active this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_high_txt is stopping this frame...
                    if cpdm_trial_left_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_high_txt.status = FINISHED
                            cpdm_trial_left_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_high_txt* updates
                    
                    # if cpdm_trial_right_high_txt is starting this frame...
                    if cpdm_trial_right_high_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_high_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_high_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_high_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_high_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_high_txt.status = STARTED
                        cpdm_trial_right_high_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_high_txt is active this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_high_txt is stopping this frame...
                    if cpdm_trial_right_high_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_high_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_high_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_high_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_high_txt.status = FINISHED
                            cpdm_trial_right_high_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_left_low_txt* updates
                    
                    # if cpdm_trial_left_low_txt is starting this frame...
                    if cpdm_trial_left_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_left_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_left_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_left_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_left_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_left_low_txt.status = STARTED
                        cpdm_trial_left_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_left_low_txt is active this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_left_low_txt is stopping this frame...
                    if cpdm_trial_left_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_left_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_left_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_left_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_left_low_txt.status = FINISHED
                            cpdm_trial_left_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_right_low_txt* updates
                    
                    # if cpdm_trial_right_low_txt is starting this frame...
                    if cpdm_trial_right_low_txt.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_right_low_txt.frameNStart = frameN  # exact frame index
                        cpdm_trial_right_low_txt.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_right_low_txt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_right_low_txt, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_right_low_txt.status = STARTED
                        cpdm_trial_right_low_txt.setAutoDraw(True)
                    
                    # if cpdm_trial_right_low_txt is active this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trial_right_low_txt is stopping this frame...
                    if cpdm_trial_right_low_txt.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_right_low_txt.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_right_low_txt.tStop = t  # not accounting for scr refresh
                            cpdm_trial_right_low_txt.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_right_low_txt.status = FINISHED
                            cpdm_trial_right_low_txt.setAutoDraw(False)
                    
                    # *cpdm_trial_resp* updates
                    waitOnFlip = False
                    
                    # if cpdm_trial_resp is starting this frame...
                    if cpdm_trial_resp.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trial_resp.frameNStart = frameN  # exact frame index
                        cpdm_trial_resp.tStart = t  # local t and not account for scr refresh
                        cpdm_trial_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trial_resp, 'tStartRefresh')  # time at next scr refresh
                        # update status
                        cpdm_trial_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(cpdm_trial_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(cpdm_trial_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    
                    # if cpdm_trial_resp is stopping this frame...
                    if cpdm_trial_resp.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trial_resp.tStartRefresh + 2-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trial_resp.tStop = t  # not accounting for scr refresh
                            cpdm_trial_resp.frameNStop = frameN  # exact frame index
                            # update status
                            cpdm_trial_resp.status = FINISHED
                            cpdm_trial_resp.status = FINISHED
                    if cpdm_trial_resp.status == STARTED and not waitOnFlip:
                        theseKeys = cpdm_trial_resp.getKeys(keyList=['q', 'a', 'p', 'l'], ignoreKeys=["escape"], waitRelease=False)
                        _cpdm_trial_resp_allKeys.extend(theseKeys)
                        if len(_cpdm_trial_resp_allKeys):
                            cpdm_trial_resp.keys = _cpdm_trial_resp_allKeys[0].name  # just the first key pressed
                            cpdm_trial_resp.rt = _cpdm_trial_resp_allKeys[0].rt
                            cpdm_trial_resp.duration = _cpdm_trial_resp_allKeys[0].duration
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trialComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trial" ---
                for thisComponent in cpdm_trialComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trial.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trial_code
                #binary accuracy & confidence
                my_loop.addData("cpdm_acc", trial_acc)
                my_loop.addData("cpdm_conf", trial_conf)
                my_loop.addData("cpdm_trial_type", "task")
                key = cpdm_trial_resp.keys
                if key in ["q", "a", "p", "l"]:
                    run_resps.append(key)
                
                if type(cpdm_trial_resp.rt) is list or cpdm_trial_resp.rt >= 2 - 0.5:
                    delta_time = 0
                else:
                    delta_time = max(0, 2 - (cpdm_trial_resp.rt + stopped_time))
                
                #low risk possible payouts
                if "low_risk" in cpdm_run_dimension: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0: 
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False: 
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #LEFT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 9)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 9, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else: 
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                #high risk possible payouts
                else: 
                    if key == "q":
                        #LEFT - HIGH correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #LEFT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "a":
                        #LEFT - LOW correct
                        if is_clockwise == False:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #Left - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                    elif key == "p":
                        #RIGHT - HIGH correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 13)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 13, "CORRECT", "HIGH")) 
                        #RIGHT - HIGH incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "high")
                            my_loop.addData("cpdm_money", 0)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 0, "INCORRECT", "HIGH")) 
                    elif key == "l":
                        #RIGHT - LOW correct
                        if is_clockwise == True:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 8)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(1)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 8, "CORRECT", "LOW")) 
                        #RIGHT - LOW incorrect
                        else:
                            my_loop.addData("cpdm_conf2", "low")
                            my_loop.addData("cpdm_money", 6)
                            #catch trial performance
                            if cpdm_catch_trial == 1:
                                catch_trials.append(0)
                            #correct response is not random
                            if cpdm_gabor_orient != 0.0:
                                cpdm_trials.append(("CPDM", 6, "INCORRECT", "LOW")) 
                # check responses
                if cpdm_trial_resp.keys in ['', [], None]:  # No response was made
                    cpdm_trial_resp.keys = None
                cpdm_trials3.addData('cpdm_trial_resp.keys',cpdm_trial_resp.keys)
                if cpdm_trial_resp.keys != None:  # we had a response
                    cpdm_trials3.addData('cpdm_trial_resp.rt', cpdm_trial_resp.rt)
                    cpdm_trials3.addData('cpdm_trial_resp.duration', cpdm_trial_resp.duration)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-2.300000)
                
                # --- Prepare to start Routine "cpdm_trials_iti3" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('cpdm_trials_iti3.started', globalClock.getTime())
                # Run 'Begin Routine' code from cpdm_trials_iti3_code
                #variable ITI for non-practice trials
                iti_time = iti_list[my_loop.thisIndex] + delta_time
                #200 CPDM trials per run
                if cpdm_trials3.thisTrialN == 199:
                    continueRoutine = False
                # keep track of which components have finished
                cpdm_trials_iti3Components = [cpdm_trials_iti3_poly]
                for thisComponent in cpdm_trials_iti3Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "cpdm_trials_iti3" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *cpdm_trials_iti3_poly* updates
                    
                    # if cpdm_trials_iti3_poly is starting this frame...
                    if cpdm_trials_iti3_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        cpdm_trials_iti3_poly.frameNStart = frameN  # exact frame index
                        cpdm_trials_iti3_poly.tStart = t  # local t and not account for scr refresh
                        cpdm_trials_iti3_poly.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(cpdm_trials_iti3_poly, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'cpdm_trials_iti3_poly.started')
                        # update status
                        cpdm_trials_iti3_poly.status = STARTED
                        cpdm_trials_iti3_poly.setAutoDraw(True)
                    
                    # if cpdm_trials_iti3_poly is active this frame...
                    if cpdm_trials_iti3_poly.status == STARTED:
                        # update params
                        pass
                    
                    # if cpdm_trials_iti3_poly is stopping this frame...
                    if cpdm_trials_iti3_poly.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > cpdm_trials_iti3_poly.tStartRefresh + cpdm_iti_time-frameTolerance:
                            # keep track of stop time/frame for later
                            cpdm_trials_iti3_poly.tStop = t  # not accounting for scr refresh
                            cpdm_trials_iti3_poly.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'cpdm_trials_iti3_poly.stopped')
                            # update status
                            cpdm_trials_iti3_poly.status = FINISHED
                            cpdm_trials_iti3_poly.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in cpdm_trials_iti3Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "cpdm_trials_iti3" ---
                for thisComponent in cpdm_trials_iti3Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('cpdm_trials_iti3.stopped', globalClock.getTime())
                # Run 'End Routine' code from cpdm_trials_iti3_code
                #record delta time
                my_loop.addData("cpdm_delta_time", delta_time) 
                #record iti time
                my_loop.addData("cpdm_iti_time", iti_time) 
                # the Routine "cpdm_trials_iti3" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 1.0 repeats of 'cpdm_trials3'
            
            
            # --- Prepare to start Routine "cpdm_run_break3" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('cpdm_run_break3.started', globalClock.getTime())
            # Run 'Begin Routine' code from cpdm_run_break3_code
            cpdm_unique_resps = []
            cpdm_unique_count = 0
            for i in run_resps:
                if i not in cpdm_unique_resps:
                    cpdm_unique_count += 1
                    cpdm_unique_resps.append(i)
            
            cpdm_run_break_text = ""
            cpdm_space_text = ""
            #filter for nonresponses
            if len(run_resps) < 190: #95% = 190 trials per block
                cpdm_run_break_text = "You failed to respond to " + str(200-len(run_resps)) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject1", "< 95% resp rate")
                my_loop.addData("cpdm_subReject1_nonresps", 200-len(run_resps))
            #filter for single-button responses
            elif cpdm_unique_count < 2: #same for each exp
                cpdm_run_break_text = "You provided the same response to all " + str(len(run_resps)) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject2", "1key response")
                my_loop.addData("cpdm_subReject2_key", run_resps[0])
            #filter for poor performance on CPDM catch trials for low volatility blocks (14/20 catch trial criterion -- 5.77% of random success on 14/20 trials)
            elif "low_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 14:
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
                cpdm_space_text = "Press SPACE to end."
                exp_proceed = False
                my_loop.addData("cpdm_subReject3LV", "LV catch fail")
                my_loop.addData("cpdm_subReject3LV_fails", 20-sum(cpdm_catch_trials))
            #filter for poor performance on CPDM catch trials for high volatility blocks (6/8 catch trial criterion -- 14.45% of random success on 7/8 trials)
            #elif "high_vol" in cpdm_run_dimension and sum(cpdm_catch_trials) < 6:
            #    cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus."
            #    cpdm_space_text = "Press SPACE to end."
            #    exp_proceed = False
            #    my_loop.addData("subReject3HV", "HV catch fail")
            #    my_loop.addData("subReject3HV_fails", 8-sum(cpdm_catch_trials))
            #all CPDM criterion are met -- good data
            else:
                #final run
                if condition_runs3.thisN == 1: 
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!"
                    cpdm_space_text = "Press SPACE to continue."
                #first three runs
                else: 
                    cpdm_run_break_text = "Please feel free to take a short break. \n \n As you begin Block " + str(run_counter) + ", read the possible monetary values of each option carefully as they may have changed."
                    cpdm_space_text = "Press SPACE to continue."
            cpdm_run_break3_txt.setText(cpdm_run_break_text)
            cpdm_run_break3_space_txt.setText(cpdm_space_text)
            cpdm_run_break3_resp.keys = []
            cpdm_run_break3_resp.rt = []
            _cpdm_run_break3_resp_allKeys = []
            # keep track of which components have finished
            cpdm_run_break3Components = [cpdm_run_break3_title_txt, cpdm_run_break3_txt, cpdm_run_break3_space_txt, cpdm_run_break3_resp]
            for thisComponent in cpdm_run_break3Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "cpdm_run_break3" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *cpdm_run_break3_title_txt* updates
                
                # if cpdm_run_break3_title_txt is starting this frame...
                if cpdm_run_break3_title_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break3_title_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break3_title_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break3_title_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break3_title_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break3_title_txt.status = STARTED
                    cpdm_run_break3_title_txt.setAutoDraw(True)
                
                # if cpdm_run_break3_title_txt is active this frame...
                if cpdm_run_break3_title_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break3_txt* updates
                
                # if cpdm_run_break3_txt is starting this frame...
                if cpdm_run_break3_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break3_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break3_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break3_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break3_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break3_txt.status = STARTED
                    cpdm_run_break3_txt.setAutoDraw(True)
                
                # if cpdm_run_break3_txt is active this frame...
                if cpdm_run_break3_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break3_space_txt* updates
                
                # if cpdm_run_break3_space_txt is starting this frame...
                if cpdm_run_break3_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break3_space_txt.frameNStart = frameN  # exact frame index
                    cpdm_run_break3_space_txt.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break3_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break3_space_txt, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break3_space_txt.status = STARTED
                    cpdm_run_break3_space_txt.setAutoDraw(True)
                
                # if cpdm_run_break3_space_txt is active this frame...
                if cpdm_run_break3_space_txt.status == STARTED:
                    # update params
                    pass
                
                # *cpdm_run_break3_resp* updates
                waitOnFlip = False
                
                # if cpdm_run_break3_resp is starting this frame...
                if cpdm_run_break3_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    cpdm_run_break3_resp.frameNStart = frameN  # exact frame index
                    cpdm_run_break3_resp.tStart = t  # local t and not account for scr refresh
                    cpdm_run_break3_resp.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(cpdm_run_break3_resp, 'tStartRefresh')  # time at next scr refresh
                    # update status
                    cpdm_run_break3_resp.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(cpdm_run_break3_resp.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(cpdm_run_break3_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if cpdm_run_break3_resp.status == STARTED and not waitOnFlip:
                    theseKeys = cpdm_run_break3_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                    _cpdm_run_break3_resp_allKeys.extend(theseKeys)
                    if len(_cpdm_run_break3_resp_allKeys):
                        cpdm_run_break3_resp.keys = _cpdm_run_break3_resp_allKeys[-1].name  # just the last key pressed
                        cpdm_run_break3_resp.rt = _cpdm_run_break3_resp_allKeys[-1].rt
                        cpdm_run_break3_resp.duration = _cpdm_run_break3_resp_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in cpdm_run_break3Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "cpdm_run_break3" ---
            for thisComponent in cpdm_run_break3Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('cpdm_run_break3.stopped', globalClock.getTime())
            # the Routine "cpdm_run_break3" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "idm_term_check" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('idm_term_check.started', globalClock.getTime())
            # Run 'Begin Routine' code from idm_term_check_code
            if exp_proceed == False:
                core.quit()
            # keep track of which components have finished
            idm_term_checkComponents = []
            for thisComponent in idm_term_checkComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "idm_term_check" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in idm_term_checkComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "idm_term_check" ---
            for thisComponent in idm_term_checkComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('idm_term_check.stopped', globalClock.getTime())
            # the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'condition_runs3'
        
    # completed loop7 repeats of 'should_run7'
    
    
    # --- Prepare to start Routine "idm_rand_select" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_rand_select.started', globalClock.getTime())
    # Run 'Begin Routine' code from idm_rand_select_code
    exps = ["cpdm", "crdm", "cdd"]
    rand_idx = random.randint(0,2)
    random_exp = exps[rand_idx]
    my_loop.addData("idm_bonus_exp", random_exp)
    # keep track of which components have finished
    idm_rand_selectComponents = []
    for thisComponent in idm_rand_selectComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_rand_select" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_rand_selectComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_rand_select" ---
    for thisComponent in idm_rand_selectComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_rand_select.stopped', globalClock.getTime())
    # the Routine "idm_rand_select" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "cpdm_bonus" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('cpdm_bonus.started', globalClock.getTime())
    # Run 'Begin Routine' code from cpdm_bonus_code
    if random_exp == "cpdm":
        continueRoutine = True
    else:
        continueRoutine = False
    
    exp = []
    money = [] 
    acc = []
    conf = []
    acc_color = [0,0,0]
    idx = int(random.random() * len(cpdm_bonus_trials)) 
    #indexing example ("CPDM", 0, "INCORRECT", "HIGH")
    exp, money, acc, conf = cpdm_bonus_trials[idx]
    if random_exp == "cpdm":
        my_loop.addData("cpdm_bonus_amt", money)
        my_loop.addData("cpdm_bonus_acc", acc)
        my_loop.addData("cpdm_bonus_conf", conf)
    
    if acc == "CORRECT":
        acc_color = [0.1216, 0.4745, 0.1216]
    else:
        acc_color = [0.9608, 0.0039, -0.1059]
    cpdm_bonus_earnings_txt.setText('In this trial, you earned:')
    cpdm_bonus_amt_txt.setText(str("$"+str(format(money))))
    cpdm_bonus_acc_txt.setColor(acc_color, colorSpace='rgb')
    cpdm_bonus_acc_txt.setText(acc)
    cpdm_bonus_conf_txt.setText(conf + " CONFIDENCE")
    cpdm_bonus_resp.keys = []
    cpdm_bonus_resp.rt = []
    _cpdm_bonus_resp_allKeys = []
    # keep track of which components have finished
    cpdm_bonusComponents = [cpdm_bonus_thanks_txt, cpdm_bonus_earnings_txt, cpdm_bonus_amt_txt, cpdm_bonus_answer_txt, cpdm_bonus_acc_txt, cpdm_bonus_and_txt, cpdm_bonus_conf_txt, cpdm_bonus_space_txt, cpdm_bonus_resp]
    for thisComponent in cpdm_bonusComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "cpdm_bonus" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *cpdm_bonus_thanks_txt* updates
        
        # if cpdm_bonus_thanks_txt is starting this frame...
        if cpdm_bonus_thanks_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_thanks_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_thanks_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_thanks_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_thanks_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_thanks_txt.status = STARTED
            cpdm_bonus_thanks_txt.setAutoDraw(True)
        
        # if cpdm_bonus_thanks_txt is active this frame...
        if cpdm_bonus_thanks_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_earnings_txt* updates
        
        # if cpdm_bonus_earnings_txt is starting this frame...
        if cpdm_bonus_earnings_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_earnings_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_earnings_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_earnings_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_earnings_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_earnings_txt.status = STARTED
            cpdm_bonus_earnings_txt.setAutoDraw(True)
        
        # if cpdm_bonus_earnings_txt is active this frame...
        if cpdm_bonus_earnings_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_amt_txt* updates
        
        # if cpdm_bonus_amt_txt is starting this frame...
        if cpdm_bonus_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_amt_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_amt_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_amt_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_amt_txt.status = STARTED
            cpdm_bonus_amt_txt.setAutoDraw(True)
        
        # if cpdm_bonus_amt_txt is active this frame...
        if cpdm_bonus_amt_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_answer_txt* updates
        
        # if cpdm_bonus_answer_txt is starting this frame...
        if cpdm_bonus_answer_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_answer_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_answer_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_answer_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_answer_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_answer_txt.status = STARTED
            cpdm_bonus_answer_txt.setAutoDraw(True)
        
        # if cpdm_bonus_answer_txt is active this frame...
        if cpdm_bonus_answer_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_acc_txt* updates
        
        # if cpdm_bonus_acc_txt is starting this frame...
        if cpdm_bonus_acc_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_acc_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_acc_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_acc_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_acc_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_acc_txt.status = STARTED
            cpdm_bonus_acc_txt.setAutoDraw(True)
        
        # if cpdm_bonus_acc_txt is active this frame...
        if cpdm_bonus_acc_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_and_txt* updates
        
        # if cpdm_bonus_and_txt is starting this frame...
        if cpdm_bonus_and_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_and_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_and_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_and_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_and_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_and_txt.status = STARTED
            cpdm_bonus_and_txt.setAutoDraw(True)
        
        # if cpdm_bonus_and_txt is active this frame...
        if cpdm_bonus_and_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_conf_txt* updates
        
        # if cpdm_bonus_conf_txt is starting this frame...
        if cpdm_bonus_conf_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_conf_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_conf_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_conf_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_conf_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_conf_txt.status = STARTED
            cpdm_bonus_conf_txt.setAutoDraw(True)
        
        # if cpdm_bonus_conf_txt is active this frame...
        if cpdm_bonus_conf_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_space_txt* updates
        
        # if cpdm_bonus_space_txt is starting this frame...
        if cpdm_bonus_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_space_txt.frameNStart = frameN  # exact frame index
            cpdm_bonus_space_txt.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_space_txt.status = STARTED
            cpdm_bonus_space_txt.setAutoDraw(True)
        
        # if cpdm_bonus_space_txt is active this frame...
        if cpdm_bonus_space_txt.status == STARTED:
            # update params
            pass
        
        # *cpdm_bonus_resp* updates
        waitOnFlip = False
        
        # if cpdm_bonus_resp is starting this frame...
        if cpdm_bonus_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cpdm_bonus_resp.frameNStart = frameN  # exact frame index
            cpdm_bonus_resp.tStart = t  # local t and not account for scr refresh
            cpdm_bonus_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cpdm_bonus_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            cpdm_bonus_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(cpdm_bonus_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(cpdm_bonus_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if cpdm_bonus_resp.status == STARTED and not waitOnFlip:
            theseKeys = cpdm_bonus_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _cpdm_bonus_resp_allKeys.extend(theseKeys)
            if len(_cpdm_bonus_resp_allKeys):
                cpdm_bonus_resp.keys = _cpdm_bonus_resp_allKeys[-1].name  # just the last key pressed
                cpdm_bonus_resp.rt = _cpdm_bonus_resp_allKeys[-1].rt
                cpdm_bonus_resp.duration = _cpdm_bonus_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in cpdm_bonusComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "cpdm_bonus" ---
    for thisComponent in cpdm_bonusComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('cpdm_bonus.stopped', globalClock.getTime())
    # the Routine "cpdm_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "crdm_bonus" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('crdm_bonus.started', globalClock.getTime())
    # Run 'Begin Routine' code from crdm_bonus_code
    if random_exp == "crdm":
        continueRoutine = True
    else:
        continueRoutine = False
    
    exp = []
    choice = []
    money = [] 
    trial_img = []
    top = [] 
    bottom = [] 
    outcome = [] 
    nonzero_side = []
    domain = []
    sure_amt = ""
    earnings_text = ""
    choice_text = ""
    outcome_color = [0,0,0]
    chip_color = [0,0,0]
    chip_text = ""
    choice_outcome = ""
    money_outcome = ""
    
    #indexing examples
    #certain chosen - ["CRDM", "sure", crdm_sure_amt, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, (- 1), crdm_nonzero_side, crdm_domain]
    #lotto chosen, win top - ["CRDM", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]
    #lotto chosen, win bottom - ["CRDM", "lott", crdm_lott_bot, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]
    #lotto chosen, lose top - ["CRDM", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]
    idx = int(random.random() * len(crdm_bonus_trials)) 
    exp, choice, money, sure_amt, trial_img, top, bottom, outcome, nonzero_side, domain = crdm_bonus_trials[idx]
    if random_exp == "crdm":
        my_loop.addData("crdm_bonus_choice", choice)
        my_loop.addData("crdm_bonus_amt", money)
    
    red_nonzero = False
    #top is always red, bottom is always blue
    if nonzero_side == "top": 
        red_nonzero = True
    
    #text for bonus payment screen
    if choice == "sure": #Ss chose sure amt
        choice_text = "*CERTAIN*"
        outcome_color = [0.7098, 0.2941, -0.7490]
        chip_color = [0,0,0]
        chip_text = ""
        choice_outcome = "$" + str(money)
        money_outcome = "" 
    else: #Ss chose lottery
        choice_text = "*PLAY THE LOTTERY*"
        if red_nonzero == True: #red (top) is nonzero side
            if outcome == 1 and domain == "gain": #Ss won the lotto on gain trial
                outcome_color = [0.9608, 0.0039, -0.1059]
                chip_color = [0.9608, 0.0039, -0.1059]
                choice_outcome = "A red chip" #blue chip is drawn and is winning side (+$ == win some money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 1 and domain == "loss": #Ss won the lotto on loss trial
                outcome_color = [-0.2157, 0.1686, 0.8588]
                chip_color = [-0.2157, 0.1686, 0.8588]
                choice_outcome = "A blue chip" #blue chip is drawn and is winning side ($0 == lose no money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 0 and domain == "gain": #Ss lost lotto on gain trial
                outcome_color = [-0.2157, 0.1686, 0.8588]
                chip_color = [-0.2157, 0.1686, 0.8588]
                choice_outcome = "A blue chip" #blue chip is drawn and is losing side ($0 == win no money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 0 and domain == "loss": #Ss lost lotto on gloss trial
                outcome_color = [0.9608, 0.0039, -0.1059]
                chip_color = [0.9608, 0.0039, -0.1059]
                choice_outcome = "A red chip" #red chip is drawn and is losing side (-$ == lose some money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
        else: #blue (bottom) is nonzero side
            if outcome == 1 and domain == "gain": #Ss won the lotto on gain trial
                outcome_color = [-0.2157, 0.1686, 0.8588]
                chip_color = [-0.2157, 0.1686, 0.8588]
                choice_outcome = "A blue chip" #blue chip is drawn and is winning side (+$ == win some money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 1 and domain == "loss": #Ss won the lotto on loss trial
                outcome_color = [0.9608, 0.0039, -0.1059]
                chip_color = [0.9608, 0.0039, -0.1059]
                choice_outcome = "A red chip" #red chip is drawn and is winning side ($0 == lose no money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 0 and domain == "gain": #Ss lost lotto on gain trial
                outcome_color = [0.9608, 0.0039, -0.1059]
                chip_color = [0.9608, 0.0039, -0.1059]
                choice_outcome = "A red chip" #red chip is drawn and is losing side ($0 == win no money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
            elif outcome == 0 and domain == "loss": #Ss lost lotto on gloss trial
                outcome_color = [-0.2157, 0.1686, 0.8588]
                chip_color = [-0.2157, 0.1686, 0.8588]
                choice_outcome = "A blue chip" #blue chip is drawn and is losing side (-$ == lose some money)
                chip_text = "was drawn and the outcome was"
                money_outcome = "$"+str(money)
    crdm_bonus_lott_top.setText(str("$"+str(format(top))))
    crdm_bonus_img.setImage("crdm/" + trial_img)
    crdm_bonus_lott_bot.setText(str("$"+str(format(bottom))))
    crdm_bonus_sure_amt_txt.setText(str("$"+str(format(sure_amt))))
    crdm_bonus_choice_text_txt.setText(choice_text)
    crdm_bonus_choice_outcome_txt.setColor(outcome_color, colorSpace='rgb')
    crdm_bonus_choice_outcome_txt.setText(choice_outcome)
    crdm_bonus_drawn_txt.setText(chip_text)
    crdm_bonus_chip_poly.setFillColor(chip_color)
    crdm_bonus_chip_poly.setLineColor(chip_color)
    crdm_bonus_winnings_txt.setText(money_outcome)
    crdm_bonus_resp.keys = []
    crdm_bonus_resp.rt = []
    _crdm_bonus_resp_allKeys = []
    # keep track of which components have finished
    crdm_bonusComponents = [crdm_bonus_thanks_txt, crdm_bonus_lott_top, crdm_bonus_img, crdm_bonus_lott_bot, crdm_bonus_sure_amt_txt, crdm_bonus_prompt_txt, crdm_bonus_choice_text_txt, crdm_bonus_choice_outcome_txt, crdm_bonus_drawn_txt, crdm_bonus_chip_poly, crdm_bonus_winnings_txt, crdm_bonus_space_txt, crdm_bonus_resp]
    for thisComponent in crdm_bonusComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "crdm_bonus" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *crdm_bonus_thanks_txt* updates
        
        # if crdm_bonus_thanks_txt is starting this frame...
        if crdm_bonus_thanks_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_thanks_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_thanks_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_thanks_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_thanks_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_thanks_txt.status = STARTED
            crdm_bonus_thanks_txt.setAutoDraw(True)
        
        # if crdm_bonus_thanks_txt is active this frame...
        if crdm_bonus_thanks_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_lott_top* updates
        
        # if crdm_bonus_lott_top is starting this frame...
        if crdm_bonus_lott_top.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_lott_top.frameNStart = frameN  # exact frame index
            crdm_bonus_lott_top.tStart = t  # local t and not account for scr refresh
            crdm_bonus_lott_top.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_lott_top, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_lott_top.status = STARTED
            crdm_bonus_lott_top.setAutoDraw(True)
        
        # if crdm_bonus_lott_top is active this frame...
        if crdm_bonus_lott_top.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_img* updates
        
        # if crdm_bonus_img is starting this frame...
        if crdm_bonus_img.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_img.frameNStart = frameN  # exact frame index
            crdm_bonus_img.tStart = t  # local t and not account for scr refresh
            crdm_bonus_img.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_img, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_img.status = STARTED
            crdm_bonus_img.setAutoDraw(True)
        
        # if crdm_bonus_img is active this frame...
        if crdm_bonus_img.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_lott_bot* updates
        
        # if crdm_bonus_lott_bot is starting this frame...
        if crdm_bonus_lott_bot.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_lott_bot.frameNStart = frameN  # exact frame index
            crdm_bonus_lott_bot.tStart = t  # local t and not account for scr refresh
            crdm_bonus_lott_bot.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_lott_bot, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_lott_bot.status = STARTED
            crdm_bonus_lott_bot.setAutoDraw(True)
        
        # if crdm_bonus_lott_bot is active this frame...
        if crdm_bonus_lott_bot.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_sure_amt_txt* updates
        
        # if crdm_bonus_sure_amt_txt is starting this frame...
        if crdm_bonus_sure_amt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_sure_amt_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_sure_amt_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_sure_amt_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_sure_amt_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_sure_amt_txt.status = STARTED
            crdm_bonus_sure_amt_txt.setAutoDraw(True)
        
        # if crdm_bonus_sure_amt_txt is active this frame...
        if crdm_bonus_sure_amt_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_prompt_txt* updates
        
        # if crdm_bonus_prompt_txt is starting this frame...
        if crdm_bonus_prompt_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_prompt_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_prompt_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_prompt_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_prompt_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_prompt_txt.status = STARTED
            crdm_bonus_prompt_txt.setAutoDraw(True)
        
        # if crdm_bonus_prompt_txt is active this frame...
        if crdm_bonus_prompt_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_choice_text_txt* updates
        
        # if crdm_bonus_choice_text_txt is starting this frame...
        if crdm_bonus_choice_text_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_choice_text_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_choice_text_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_choice_text_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_choice_text_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_choice_text_txt.status = STARTED
            crdm_bonus_choice_text_txt.setAutoDraw(True)
        
        # if crdm_bonus_choice_text_txt is active this frame...
        if crdm_bonus_choice_text_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_choice_outcome_txt* updates
        
        # if crdm_bonus_choice_outcome_txt is starting this frame...
        if crdm_bonus_choice_outcome_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_choice_outcome_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_choice_outcome_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_choice_outcome_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_choice_outcome_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_choice_outcome_txt.status = STARTED
            crdm_bonus_choice_outcome_txt.setAutoDraw(True)
        
        # if crdm_bonus_choice_outcome_txt is active this frame...
        if crdm_bonus_choice_outcome_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_drawn_txt* updates
        
        # if crdm_bonus_drawn_txt is starting this frame...
        if crdm_bonus_drawn_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_drawn_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_drawn_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_drawn_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_drawn_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_drawn_txt.status = STARTED
            crdm_bonus_drawn_txt.setAutoDraw(True)
        
        # if crdm_bonus_drawn_txt is active this frame...
        if crdm_bonus_drawn_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_chip_poly* updates
        
        # if crdm_bonus_chip_poly is starting this frame...
        if crdm_bonus_chip_poly.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_chip_poly.frameNStart = frameN  # exact frame index
            crdm_bonus_chip_poly.tStart = t  # local t and not account for scr refresh
            crdm_bonus_chip_poly.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_chip_poly, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_chip_poly.status = STARTED
            crdm_bonus_chip_poly.setAutoDraw(True)
        
        # if crdm_bonus_chip_poly is active this frame...
        if crdm_bonus_chip_poly.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_winnings_txt* updates
        
        # if crdm_bonus_winnings_txt is starting this frame...
        if crdm_bonus_winnings_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_winnings_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_winnings_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_winnings_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_winnings_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_winnings_txt.status = STARTED
            crdm_bonus_winnings_txt.setAutoDraw(True)
        
        # if crdm_bonus_winnings_txt is active this frame...
        if crdm_bonus_winnings_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_space_txt* updates
        
        # if crdm_bonus_space_txt is starting this frame...
        if crdm_bonus_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_space_txt.frameNStart = frameN  # exact frame index
            crdm_bonus_space_txt.tStart = t  # local t and not account for scr refresh
            crdm_bonus_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_space_txt.status = STARTED
            crdm_bonus_space_txt.setAutoDraw(True)
        
        # if crdm_bonus_space_txt is active this frame...
        if crdm_bonus_space_txt.status == STARTED:
            # update params
            pass
        
        # *crdm_bonus_resp* updates
        waitOnFlip = False
        
        # if crdm_bonus_resp is starting this frame...
        if crdm_bonus_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            crdm_bonus_resp.frameNStart = frameN  # exact frame index
            crdm_bonus_resp.tStart = t  # local t and not account for scr refresh
            crdm_bonus_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(crdm_bonus_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            crdm_bonus_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(crdm_bonus_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(crdm_bonus_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if crdm_bonus_resp.status == STARTED and not waitOnFlip:
            theseKeys = crdm_bonus_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _crdm_bonus_resp_allKeys.extend(theseKeys)
            if len(_crdm_bonus_resp_allKeys):
                crdm_bonus_resp.keys = _crdm_bonus_resp_allKeys[-1].name  # just the last key pressed
                crdm_bonus_resp.rt = _crdm_bonus_resp_allKeys[-1].rt
                crdm_bonus_resp.duration = _crdm_bonus_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in crdm_bonusComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "crdm_bonus" ---
    for thisComponent in crdm_bonusComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('crdm_bonus.stopped', globalClock.getTime())
    # the Routine "crdm_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "cdd_bonus" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('cdd_bonus.started', globalClock.getTime())
    # Run 'Begin Routine' code from cdd_bonus_code
    if random_exp == "cdd":
        continueRoutine = True
    else:
        continueRoutine = False
    
    exp = []
    choice = []
    choice_amt = []
    choice_wait = []
    other_amt = []
    other_wait = []
    choice_text = ""
    other_text = ""
    
    idx = int(random.random() * len(cdd_bonus_trials)) 
    #("CDD", "immed", immed_amt, immed_wait, delay_amt, delay_wait) 
    #Ss chose immediate amount on selected bonus trial
    if cdd_trials[idx][1] == "immed":
        exp, choice, choice_amt, choice_wait, other_amt, other_wait = cdd_bonus_trials[idx]
        choice_text = "$" + str(choice_amt) + " TODAY"
        other_text = "$" + str(other_amt) + " in " + str(other_wait) + " DAYS"
        if random_exp == "cdd":
            my_loop.addData("cdd_bonus_choice", choice)
            my_loop.addData("cdd_bonus_amt", choice_amt)
            my_loop.addData("cdd_bonus_delay", choice_wait)
    #Ss chose delay amount on selected bonus trial
    else:
        exp, choice, other_amt, other_wait, choice_amt, choice_wait = cdd_bonus_trials[idx]
        choice_text = "$" + str(choice_amt) + " in " + str(choice_wait) + " DAYS"
        other_text = "$" + str(other_amt) + " TODAY"
        if random_exp == "cdd":
            my_loop.addData("cdd_bonus_choice", choice)
            my_loop.addData("cdd_bonus_amt", choice_amt)
            my_loop.addData("cdd_bonus_delay", choice_wait)
    cdd_bonus_box.setText('In this trial, you chose to receive:')
    cdd_bonus_choice_txt.setText(choice_text)
    cdd_bonus_other_txt.setText(other_text)
    cdd_bonus_resp.keys = []
    cdd_bonus_resp.rt = []
    _cdd_bonus_resp_allKeys = []
    # keep track of which components have finished
    cdd_bonusComponents = [cdd_bonus_thanks_txt, cdd_bonus_box, cdd_bonus_choice_txt, cdd_bonus_rather_txt, cdd_bonus_other_txt, cdd_bonus_space_txt, cdd_bonus_resp]
    for thisComponent in cdd_bonusComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "cdd_bonus" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *cdd_bonus_thanks_txt* updates
        
        # if cdd_bonus_thanks_txt is starting this frame...
        if cdd_bonus_thanks_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_thanks_txt.frameNStart = frameN  # exact frame index
            cdd_bonus_thanks_txt.tStart = t  # local t and not account for scr refresh
            cdd_bonus_thanks_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_thanks_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_thanks_txt.status = STARTED
            cdd_bonus_thanks_txt.setAutoDraw(True)
        
        # if cdd_bonus_thanks_txt is active this frame...
        if cdd_bonus_thanks_txt.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_box* updates
        
        # if cdd_bonus_box is starting this frame...
        if cdd_bonus_box.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_box.frameNStart = frameN  # exact frame index
            cdd_bonus_box.tStart = t  # local t and not account for scr refresh
            cdd_bonus_box.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_box, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_box.status = STARTED
            cdd_bonus_box.setAutoDraw(True)
        
        # if cdd_bonus_box is active this frame...
        if cdd_bonus_box.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_choice_txt* updates
        
        # if cdd_bonus_choice_txt is starting this frame...
        if cdd_bonus_choice_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_choice_txt.frameNStart = frameN  # exact frame index
            cdd_bonus_choice_txt.tStart = t  # local t and not account for scr refresh
            cdd_bonus_choice_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_choice_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_choice_txt.status = STARTED
            cdd_bonus_choice_txt.setAutoDraw(True)
        
        # if cdd_bonus_choice_txt is active this frame...
        if cdd_bonus_choice_txt.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_rather_txt* updates
        
        # if cdd_bonus_rather_txt is starting this frame...
        if cdd_bonus_rather_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_rather_txt.frameNStart = frameN  # exact frame index
            cdd_bonus_rather_txt.tStart = t  # local t and not account for scr refresh
            cdd_bonus_rather_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_rather_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_rather_txt.status = STARTED
            cdd_bonus_rather_txt.setAutoDraw(True)
        
        # if cdd_bonus_rather_txt is active this frame...
        if cdd_bonus_rather_txt.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_other_txt* updates
        
        # if cdd_bonus_other_txt is starting this frame...
        if cdd_bonus_other_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_other_txt.frameNStart = frameN  # exact frame index
            cdd_bonus_other_txt.tStart = t  # local t and not account for scr refresh
            cdd_bonus_other_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_other_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_other_txt.status = STARTED
            cdd_bonus_other_txt.setAutoDraw(True)
        
        # if cdd_bonus_other_txt is active this frame...
        if cdd_bonus_other_txt.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_space_txt* updates
        
        # if cdd_bonus_space_txt is starting this frame...
        if cdd_bonus_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_space_txt.frameNStart = frameN  # exact frame index
            cdd_bonus_space_txt.tStart = t  # local t and not account for scr refresh
            cdd_bonus_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_space_txt.status = STARTED
            cdd_bonus_space_txt.setAutoDraw(True)
        
        # if cdd_bonus_space_txt is active this frame...
        if cdd_bonus_space_txt.status == STARTED:
            # update params
            pass
        
        # *cdd_bonus_resp* updates
        waitOnFlip = False
        
        # if cdd_bonus_resp is starting this frame...
        if cdd_bonus_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cdd_bonus_resp.frameNStart = frameN  # exact frame index
            cdd_bonus_resp.tStart = t  # local t and not account for scr refresh
            cdd_bonus_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cdd_bonus_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            cdd_bonus_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(cdd_bonus_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(cdd_bonus_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if cdd_bonus_resp.status == STARTED and not waitOnFlip:
            theseKeys = cdd_bonus_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _cdd_bonus_resp_allKeys.extend(theseKeys)
            if len(_cdd_bonus_resp_allKeys):
                cdd_bonus_resp.keys = _cdd_bonus_resp_allKeys[-1].name  # just the last key pressed
                cdd_bonus_resp.rt = _cdd_bonus_resp_allKeys[-1].rt
                cdd_bonus_resp.duration = _cdd_bonus_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in cdd_bonusComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "cdd_bonus" ---
    for thisComponent in cdd_bonusComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('cdd_bonus.stopped', globalClock.getTime())
    # the Routine "cdd_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "idm_comp_code" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('idm_comp_code.started', globalClock.getTime())
    # Run 'Begin Routine' code from idm_code_code
    #completion code origination is now a 6 digit randomized code
    #previously linked to participant ID#
    comp_code = random.randint(100000, 999999)
    my_loop.addData("completion_code", comp_code)
    idm_comp_code_num_txt.setText(comp_code)
    idm_comp_code_key_resp.keys = []
    idm_comp_code_key_resp.rt = []
    _idm_comp_code_key_resp_allKeys = []
    # keep track of which components have finished
    idm_comp_codeComponents = [idm_comp_code_header_txt, idm_comp_code_num_txt, idm_comp_code_instr_txt, idm_comp_code_space_txt, idm_comp_code_key_resp]
    for thisComponent in idm_comp_codeComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "idm_comp_code" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *idm_comp_code_header_txt* updates
        
        # if idm_comp_code_header_txt is starting this frame...
        if idm_comp_code_header_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_comp_code_header_txt.frameNStart = frameN  # exact frame index
            idm_comp_code_header_txt.tStart = t  # local t and not account for scr refresh
            idm_comp_code_header_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_comp_code_header_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_comp_code_header_txt.status = STARTED
            idm_comp_code_header_txt.setAutoDraw(True)
        
        # if idm_comp_code_header_txt is active this frame...
        if idm_comp_code_header_txt.status == STARTED:
            # update params
            pass
        
        # *idm_comp_code_num_txt* updates
        
        # if idm_comp_code_num_txt is starting this frame...
        if idm_comp_code_num_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_comp_code_num_txt.frameNStart = frameN  # exact frame index
            idm_comp_code_num_txt.tStart = t  # local t and not account for scr refresh
            idm_comp_code_num_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_comp_code_num_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_comp_code_num_txt.status = STARTED
            idm_comp_code_num_txt.setAutoDraw(True)
        
        # if idm_comp_code_num_txt is active this frame...
        if idm_comp_code_num_txt.status == STARTED:
            # update params
            pass
        
        # *idm_comp_code_instr_txt* updates
        
        # if idm_comp_code_instr_txt is starting this frame...
        if idm_comp_code_instr_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_comp_code_instr_txt.frameNStart = frameN  # exact frame index
            idm_comp_code_instr_txt.tStart = t  # local t and not account for scr refresh
            idm_comp_code_instr_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_comp_code_instr_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_comp_code_instr_txt.status = STARTED
            idm_comp_code_instr_txt.setAutoDraw(True)
        
        # if idm_comp_code_instr_txt is active this frame...
        if idm_comp_code_instr_txt.status == STARTED:
            # update params
            pass
        
        # *idm_comp_code_space_txt* updates
        
        # if idm_comp_code_space_txt is starting this frame...
        if idm_comp_code_space_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_comp_code_space_txt.frameNStart = frameN  # exact frame index
            idm_comp_code_space_txt.tStart = t  # local t and not account for scr refresh
            idm_comp_code_space_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_comp_code_space_txt, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_comp_code_space_txt.status = STARTED
            idm_comp_code_space_txt.setAutoDraw(True)
        
        # if idm_comp_code_space_txt is active this frame...
        if idm_comp_code_space_txt.status == STARTED:
            # update params
            pass
        
        # *idm_comp_code_key_resp* updates
        waitOnFlip = False
        
        # if idm_comp_code_key_resp is starting this frame...
        if idm_comp_code_key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            idm_comp_code_key_resp.frameNStart = frameN  # exact frame index
            idm_comp_code_key_resp.tStart = t  # local t and not account for scr refresh
            idm_comp_code_key_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(idm_comp_code_key_resp, 'tStartRefresh')  # time at next scr refresh
            # update status
            idm_comp_code_key_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(idm_comp_code_key_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(idm_comp_code_key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if idm_comp_code_key_resp.status == STARTED and not waitOnFlip:
            theseKeys = idm_comp_code_key_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _idm_comp_code_key_resp_allKeys.extend(theseKeys)
            if len(_idm_comp_code_key_resp_allKeys):
                idm_comp_code_key_resp.keys = _idm_comp_code_key_resp_allKeys[-1].name  # just the last key pressed
                idm_comp_code_key_resp.rt = _idm_comp_code_key_resp_allKeys[-1].rt
                idm_comp_code_key_resp.duration = _idm_comp_code_key_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in idm_comp_codeComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "idm_comp_code" ---
    for thisComponent in idm_comp_codeComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('idm_comp_code.stopped', globalClock.getTime())
    # the Routine "idm_comp_code" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # mark experiment as finished
    endExperiment(thisExp, win=win, inputs=inputs)


def saveData(thisExp):
    """
    Save data from this experiment
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    filename = thisExp.dataFileName
    # these shouldn't be strictly necessary (should auto-save)
    thisExp.saveAsWideText(filename + '.csv', delim='auto')
    thisExp.saveAsPickle(filename)


def endExperiment(thisExp, inputs=None, win=None):
    """
    End this experiment, performing final shut down operations.
    
    This function does NOT close the window or end the Python process - use `quit` for this.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    inputs : dict
        Dictionary of input devices by name.
    win : psychopy.visual.Window
        Window for this experiment.
    """
    if win is not None:
        # remove autodraw from all current components
        win.clearAutoDraw()
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed
        win.flip()
    # mark experiment handler as finished
    thisExp.status = FINISHED
    # shut down eyetracker, if there is one
    if inputs is not None:
        if 'eyetracker' in inputs and inputs['eyetracker'] is not None:
            inputs['eyetracker'].setConnectionState(False)
    logging.flush()


def quit(thisExp, win=None, inputs=None, thisSession=None):
    """
    Fully quit, closing the window and ending the Python process.
    
    Parameters
    ==========
    win : psychopy.visual.Window
        Window to close.
    inputs : dict
        Dictionary of input devices by name.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    thisExp.abort()  # or data files will save again on exit
    # make sure everything is closed down
    if win is not None:
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed before quitting
        win.flip()
        win.close()
    if inputs is not None:
        if 'eyetracker' in inputs and inputs['eyetracker'] is not None:
            inputs['eyetracker'].setConnectionState(False)
    logging.flush()
    if thisSession is not None:
        thisSession.stop()
    # terminate Python process
    core.quit()


# if running this experiment as a script...
if __name__ == '__main__':
    # call all functions in order
    expInfo = showExpInfoDlg(expInfo=expInfo)
    thisExp = setupData(expInfo=expInfo)
    logFile = setupLogging(filename=thisExp.dataFileName)
    win = setupWindow(expInfo=expInfo)
    inputs = setupInputs(expInfo=expInfo, thisExp=thisExp, win=win)
    run(
        expInfo=expInfo, 
        thisExp=thisExp, 
        win=win, 
        inputs=inputs
    )
    saveData(thisExp=thisExp)
    quit(thisExp=thisExp, win=win, inputs=inputs)
