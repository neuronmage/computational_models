/******************* 
 * Idm_Ado_V1 *
 *******************/

import { core, data, sound, util, visual, hardware } from './lib/psychojs-2023.2.2.js';
const { PsychoJS } = core;
const { TrialHandler, MultiStairHandler } = data;
const { Scheduler } = util;
//some handy aliases as in the psychopy scripts;
const { abs, sin, cos, PI: pi, sqrt } = Math;
const { round } = util;


// store info about the experiment session:
let expName = 'idm_ado_v1';  // from the Builder filename that created this script
let expInfo = {
    'participant': '',
};

// Start code blocks for 'Before Experiment'
var cdd_conf_resps, cdd_bonus_trials, cpdm_bonus_trials, crdm_bonus_trials, crdm_conf_resps, exp_proceed, loop1, loop2, loop3, loop4, loop5, loop6, loop7, order;
exp_proceed = true;
crdm_conf_resps = [];
cdd_conf_resps = [];
cpdm_bonus_trials = [];
crdm_bonus_trials = [];
cdd_bonus_trials = [];
loop1 = false;
loop2 = false;
loop3 = false;
loop4 = false;
loop5 = false;
loop6 = false;
loop7 = false;
//order = 2;
order = Number.parseInt((Math.random() * 6));
if ((order === 0)) {
    loop1 = true;
    loop2 = true;
    loop3 = true;
} else {
    if ((order === 1)) {
        loop1 = true;
        loop3 = true;
        loop5 = true;
    } else {
        if ((order === 2)) {
            loop3 = true;
            loop4 = true;
            loop5 = true;
        } else {
            if ((order === 3)) {
                loop2 = true;
                loop3 = true;
                loop4 = true;
            } else {
                if ((order === 4)) {
                    loop3 = true;
                    loop5 = true;
                    loop7 = true;
                } else {
                    if ((order === 5)) {
                        loop2 = true;
                        loop4 = true;
                        loop6 = true;
                    }
                }
            }
        }
    }
}
// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: true,
  color: new util.Color([0,0,0]),
  units: 'height',
  waitBlanking: true,
  backgroundImage: '',
  backgroundFit: 'none',
});
// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
flowScheduler.add(idm_consent1RoutineBegin());
flowScheduler.add(idm_consent1RoutineEachFrame());
flowScheduler.add(idm_consent1RoutineEnd());
flowScheduler.add(idm_consent2RoutineBegin());
flowScheduler.add(idm_consent2RoutineEachFrame());
flowScheduler.add(idm_consent2RoutineEnd());
flowScheduler.add(idm_consent3RoutineBegin());
flowScheduler.add(idm_consent3RoutineEachFrame());
flowScheduler.add(idm_consent3RoutineEnd());
flowScheduler.add(idm_consent4RoutineBegin());
flowScheduler.add(idm_consent4RoutineEachFrame());
flowScheduler.add(idm_consent4RoutineEnd());
flowScheduler.add(idm_consent5RoutineBegin());
flowScheduler.add(idm_consent5RoutineEachFrame());
flowScheduler.add(idm_consent5RoutineEnd());
flowScheduler.add(idm_consent6RoutineBegin());
flowScheduler.add(idm_consent6RoutineEachFrame());
flowScheduler.add(idm_consent6RoutineEnd());
flowScheduler.add(idm_consent7RoutineBegin());
flowScheduler.add(idm_consent7RoutineEachFrame());
flowScheduler.add(idm_consent7RoutineEnd());
flowScheduler.add(idm_consent8RoutineBegin());
flowScheduler.add(idm_consent8RoutineEachFrame());
flowScheduler.add(idm_consent8RoutineEnd());
flowScheduler.add(idm_consent9RoutineBegin());
flowScheduler.add(idm_consent9RoutineEachFrame());
flowScheduler.add(idm_consent9RoutineEnd());
flowScheduler.add(idm_thanksRoutineBegin());
flowScheduler.add(idm_thanksRoutineEachFrame());
flowScheduler.add(idm_thanksRoutineEnd());
flowScheduler.add(idm_warn1RoutineBegin());
flowScheduler.add(idm_warn1RoutineEachFrame());
flowScheduler.add(idm_warn1RoutineEnd());
flowScheduler.add(idm_surv1_introRoutineBegin());
flowScheduler.add(idm_surv1_introRoutineEachFrame());
flowScheduler.add(idm_surv1_introRoutineEnd());
const survey1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(survey1LoopBegin(survey1LoopScheduler));
flowScheduler.add(survey1LoopScheduler);
flowScheduler.add(survey1LoopEnd);


flowScheduler.add(idm_surv2_introRoutineBegin());
flowScheduler.add(idm_surv2_introRoutineEachFrame());
flowScheduler.add(idm_surv2_introRoutineEnd());
const survey2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(survey2LoopBegin(survey2LoopScheduler));
flowScheduler.add(survey2LoopScheduler);
flowScheduler.add(survey2LoopEnd);


flowScheduler.add(idm_instr1RoutineBegin());
flowScheduler.add(idm_instr1RoutineEachFrame());
flowScheduler.add(idm_instr1RoutineEnd());
flowScheduler.add(idm_instr2RoutineBegin());
flowScheduler.add(idm_instr2RoutineEachFrame());
flowScheduler.add(idm_instr2RoutineEnd());
flowScheduler.add(idm_warn2RoutineBegin());
flowScheduler.add(idm_warn2RoutineEachFrame());
flowScheduler.add(idm_warn2RoutineEnd());
const should_run1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run1LoopBegin(should_run1LoopScheduler));
flowScheduler.add(should_run1LoopScheduler);
flowScheduler.add(should_run1LoopEnd);

























const should_run2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run2LoopBegin(should_run2LoopScheduler));
flowScheduler.add(should_run2LoopScheduler);
flowScheduler.add(should_run2LoopEnd);








































const should_run3LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run3LoopBegin(should_run3LoopScheduler));
flowScheduler.add(should_run3LoopScheduler);
flowScheduler.add(should_run3LoopEnd);




































const should_run4LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run4LoopBegin(should_run4LoopScheduler));
flowScheduler.add(should_run4LoopScheduler);
flowScheduler.add(should_run4LoopEnd);

























const should_run5LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run5LoopBegin(should_run5LoopScheduler));
flowScheduler.add(should_run5LoopScheduler);
flowScheduler.add(should_run5LoopEnd);








































const should_run6LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run6LoopBegin(should_run6LoopScheduler));
flowScheduler.add(should_run6LoopScheduler);
flowScheduler.add(should_run6LoopEnd);




































const should_run7LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(should_run7LoopBegin(should_run7LoopScheduler));
flowScheduler.add(should_run7LoopScheduler);
flowScheduler.add(should_run7LoopEnd);

























flowScheduler.add(idm_rand_selectRoutineBegin());
flowScheduler.add(idm_rand_selectRoutineEachFrame());
flowScheduler.add(idm_rand_selectRoutineEnd());
flowScheduler.add(cpdm_bonusRoutineBegin());
flowScheduler.add(cpdm_bonusRoutineEachFrame());
flowScheduler.add(cpdm_bonusRoutineEnd());
flowScheduler.add(crdm_bonusRoutineBegin());
flowScheduler.add(crdm_bonusRoutineEachFrame());
flowScheduler.add(crdm_bonusRoutineEnd());
flowScheduler.add(cdd_bonusRoutineBegin());
flowScheduler.add(cdd_bonusRoutineEachFrame());
flowScheduler.add(cdd_bonusRoutineEnd());
flowScheduler.add(idm_comp_codeRoutineBegin());
flowScheduler.add(idm_comp_codeRoutineEachFrame());
flowScheduler.add(idm_comp_codeRoutineEnd());
flowScheduler.add(quitPsychoJS, '', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, '', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  resources: [
    // resources:
    {'name': 'idm_survey1.xlsx', 'path': 'idm_survey1.xlsx'},
    {'name': 'idm_survey2.xlsx', 'path': 'idm_survey2.xlsx'},
    {'name': 'cpdm/cpdm_practice.xlsx', 'path': 'cpdm/cpdm_practice.xlsx'},
    {'name': 'cpdm/cpdm_run_type.xlsx', 'path': 'cpdm/cpdm_run_type.xlsx'},
    {'name': 'cpdm/cpdm-1contrast.xlsx', 'path': 'cpdm/cpdm-1contrast.xlsx'},
    {'name': 'crdm/crdm_practice1.csv', 'path': 'crdm/crdm_practice1.csv'},
    {'name': 'crdm/crdm_questplus_trials.csv', 'path': 'crdm/crdm_questplus_trials.csv'},
    {'name': 'crdm/crdm_practice2.csv', 'path': 'crdm/crdm_practice2.csv'},
    {'name': 'crdm/crdm_gen_trials_idx.csv', 'path': 'crdm/crdm_gen_trials_idx.csv'},
    {'name': 'cdd/cdd_practice1.csv', 'path': 'cdd/cdd_practice1.csv'},
    {'name': 'cdd/cdd_qp_trials.csv', 'path': 'cdd/cdd_qp_trials.csv'},
    {'name': 'cdd/cdd_practice2.csv', 'path': 'cdd/cdd_practice2.csv'},
    {'name': 'cdd/cdd_gen_trials_idx.csv', 'path': 'cdd/cdd_gen_trials_idx.csv'},
    {'name': 'cpdm/cpdm_practice.xlsx', 'path': 'cpdm/cpdm_practice.xlsx'},
    {'name': 'cpdm/cpdm_run_type.xlsx', 'path': 'cpdm/cpdm_run_type.xlsx'},
    {'name': 'cpdm/cpdm-1contrast.xlsx', 'path': 'cpdm/cpdm-1contrast.xlsx'},
    {'name': 'crdm/crdm_practice1.csv', 'path': 'crdm/crdm_practice1.csv'},
    {'name': 'crdm/crdm_questplus_trials.csv', 'path': 'crdm/crdm_questplus_trials.csv'},
    {'name': 'crdm/crdm_practice2.csv', 'path': 'crdm/crdm_practice2.csv'},
    {'name': 'crdm/crdm_gen_trials_idx.csv', 'path': 'crdm/crdm_gen_trials_idx.csv'},
    {'name': 'cdd/cdd_practice1.csv', 'path': 'cdd/cdd_practice1.csv'},
    {'name': 'cdd/cdd_qp_trials.csv', 'path': 'cdd/cdd_qp_trials.csv'},
    {'name': 'cdd/cdd_practice2.csv', 'path': 'cdd/cdd_practice2.csv'},
    {'name': 'cdd/cdd_gen_trials_idx.csv', 'path': 'cdd/cdd_gen_trials_idx.csv'},
    {'name': 'cpdm/cpdm_practice.xlsx', 'path': 'cpdm/cpdm_practice.xlsx'},
    {'name': 'cpdm/cpdm_run_type.xlsx', 'path': 'cpdm/cpdm_run_type.xlsx'},
    {'name': 'cpdm/cpdm-1contrast.xlsx', 'path': 'cpdm/cpdm-1contrast.xlsx'},
    {'name': 'cpdm/cpdm_keys.png', 'path': 'cpdm/cpdm_keys.png'},
    {'name': 'cpdm/arrow.png', 'path': 'cpdm/arrow.png'},
    {'name': 'crdm/risk_blue_75.bmp', 'path': 'crdm/risk_blue_75.bmp'},
    {'name': 'crdm/ambig_50.bmp', 'path': 'crdm/ambig_50.bmp'},
    {'name': 'crdm/crdm_2key.png', 'path': 'crdm/crdm_2key.png'},
    {'name': 'crdm/crdm_4key.png', 'path': 'crdm/crdm_4key.png'},
    {'name': 'default.png', 'path': 'https://pavlovia.org/assets/default/default.png'},
    {'name': 'cdd/cdd_2key.png', 'path': 'cdd/cdd_2key.png'},
    {'name': 'cdd/cdd_4key.png', 'path': 'cdd/cdd_4key.png'},
    {'name': 'idm_survey1.xlsx', 'path': 'idm_survey1.xlsx'},
    {'name': 'idm_survey2.xlsx', 'path': 'idm_survey2.xlsx'},
    {'name': 'cpdm/arrow.png', 'path': 'cpdm/arrow.png'},
    {'name': 'cpdm/cpdm_keys.png', 'path': 'cpdm/cpdm_keys.png'},
    {'name': 'cpdm/cpdm_practice.xlsx', 'path': 'cpdm/cpdm_practice.xlsx'},
    {'name': 'cpdm/cpdm_run_type-high.xlsx', 'path': 'cpdm/cpdm_run_type-high.xlsx'},
    {'name': 'cpdm/cpdm_run_type.xlsx', 'path': 'cpdm/cpdm_run_type.xlsx'},
    {'name': 'cpdm/cpdm-1contrast.xlsx', 'path': 'cpdm/cpdm-1contrast.xlsx'},
    {'name': 'cpdm/cpdm-5contrasts.xlsx', 'path': 'cpdm/cpdm-5contrasts.xlsx'},
    {'name': 'cpdm/cpdm-test1.xlsx', 'path': 'cpdm/cpdm-test1.xlsx'},
    {'name': 'crdm/ambig_24.bmp', 'path': 'crdm/ambig_24.bmp'},
    {'name': 'crdm/ambig_50.bmp', 'path': 'crdm/ambig_50.bmp'},
    {'name': 'crdm/ambig_74.bmp', 'path': 'crdm/ambig_74.bmp'},
    {'name': 'crdm/crdm_2key.png', 'path': 'crdm/crdm_2key.png'},
    {'name': 'crdm/crdm_4key.png', 'path': 'crdm/crdm_4key.png'},
    {'name': 'crdm/crdm_gen_trials_idx.csv', 'path': 'crdm/crdm_gen_trials_idx.csv'},
    {'name': 'crdm/crdm_practice1.csv', 'path': 'crdm/crdm_practice1.csv'},
    {'name': 'crdm/crdm_practice2.csv', 'path': 'crdm/crdm_practice2.csv'},
    {'name': 'crdm/crdm_questplus_trials.csv', 'path': 'crdm/crdm_questplus_trials.csv'},
    {'name': 'crdm/risk_blue_13.bmp', 'path': 'crdm/risk_blue_13.bmp'},
    {'name': 'crdm/risk_blue_25.bmp', 'path': 'crdm/risk_blue_25.bmp'},
    {'name': 'crdm/risk_blue_38.bmp', 'path': 'crdm/risk_blue_38.bmp'},
    {'name': 'crdm/risk_blue_50.bmp', 'path': 'crdm/risk_blue_50.bmp'},
    {'name': 'crdm/risk_blue_75.bmp', 'path': 'crdm/risk_blue_75.bmp'},
    {'name': 'crdm/risk_red_13.bmp', 'path': 'crdm/risk_red_13.bmp'},
    {'name': 'crdm/risk_red_25.bmp', 'path': 'crdm/risk_red_25.bmp'},
    {'name': 'crdm/risk_red_38.bmp', 'path': 'crdm/risk_red_38.bmp'},
    {'name': 'crdm/risk_red_50.bmp', 'path': 'crdm/risk_red_50.bmp'},
    {'name': 'crdm/risk_red_75.bmp', 'path': 'crdm/risk_red_75.bmp'},
    {'name': 'cdd/cdd_2key.png', 'path': 'cdd/cdd_2key.png'},
    {'name': 'cdd/cdd_4key.png', 'path': 'cdd/cdd_4key.png'},
    {'name': 'cdd/cdd_gen_trials_idx.csv', 'path': 'cdd/cdd_gen_trials_idx.csv'},
    {'name': 'cdd/cdd_practice1.csv', 'path': 'cdd/cdd_practice1.csv'},
    {'name': 'cdd/cdd_practice2.csv', 'path': 'cdd/cdd_practice2.csv'},
    {'name': 'cdd/cdd_qp_trials.csv', 'path': 'cdd/cdd_qp_trials.csv'},
  ]
});

psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.EXP);


var currentLoop;
var frameDur;
async function updateInfo() {
  currentLoop = psychoJS.experiment;  // right now there are no loops
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2023.2.2';
  expInfo['OS'] = window.navigator.platform;


  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  

  
  psychoJS.experiment.dataFileName = (("." + "/") + `data/${expInfo["participant"]}_${expInfo["date"]}`);
  psychoJS.experiment.field_separator = '\t';


  return Scheduler.Event.NEXT;
}


var idm_consent1Clock;
var format;
var arange_round;
var random_weighted_choice;
var range;
var arange;
var idm_consent1_welcome_txt;
var idm_consent1_info_txt;
var idm_consent1_space_txt;
var idm_consent1_resp;
var idm_consent2Clock;
var idm_consent2_title_txt;
var idm_consent2_info_txt;
var idm_consent2_space_txt;
var idm_consent2_resp;
var idm_consent3Clock;
var idm_consent3_title_txt;
var idm_consent3_info_txt;
var idm_consent3_space_txt;
var idm_consent3_resp;
var idm_consent4Clock;
var idm_consent4_title_txt;
var idm_consent4_info_txt;
var idm_consent4_space_txt;
var idm_consent4_resp;
var idm_consent5Clock;
var idm_consent5_title_txt;
var idm_consent5_info_txt;
var idm_consent5_space_txt;
var idm_consent5_resp;
var idm_consent6Clock;
var idm_consent6_title_txt;
var idm_consent6_info_txt;
var idm_consent6_space_txt;
var idm_consent6_resp;
var idm_consent7Clock;
var idm_consent7_title_txt;
var idm_consent7_info_txt;
var idm_consent7_space_txt;
var idm_consent7_resp;
var idm_consent8Clock;
var idm_consent8_title_txt;
var idm_consent8_info_txt;
var idm_consent8_space_txt;
var idm_consent8_resp;
var idm_consent9Clock;
var idm_consent9_title_txt;
var idm_consent9_info_txt;
var idm_consent9_resp;
var idm_thanksClock;
var idm_thanks_title_txt;
var idm_thanks_txt;
var idm_thanks_space_txt;
var idm_thanks_resp;
var idm_warn1Clock;
var idm_warn1_title_txt;
var idm_warn1_txt;
var idm_warn1_space_txt;
var idm_warn1_resp;
var idm_surv1_introClock;
var idm_surv1_intro_title_txt;
var idm_surv1_intro_txt;
var idm_surv1_intro_space_txt;
var idm_surv1_intro_resp;
var idm_surv1Clock;
var idm_surv1_question_txt;
var idm_surv1_1;
var idm_surv1_1_txt;
var idm_surv1_2;
var idm_surv1_2_txt;
var idm_surv1_3;
var idm_surv1_3_txt;
var idm_surv1_4;
var idm_surv1_4_txt;
var idm_surv1_5;
var idm_surv1_5_txt;
var idm_surv1_6;
var idm_surv1_6_txt;
var idm_surv1_key1;
var idm_surv1_key2;
var idm_surv1_key3;
var idm_surv1_key4;
var idm_surv1_key5;
var idm_surv1_key6;
var idm_surv1_resp;
var idm_surv2_introClock;
var idm_surv2_intro_title_txt;
var idm_surv2_intro_txt;
var idm_surv2_intro_space_txt;
var idm_surv2_intro_resp;
var idm_surv2Clock;
var idm_surv2_stim_txt;
var idm_surv2_question_txt;
var idm_surv2_1;
var idm_surv2_1_txt;
var idm_surv2_2;
var idm_surv2_2_txt;
var idm_surv2_3;
var idm_surv2_3_txt;
var idm_surv2_4;
var idm_surv2_4_txt;
var idm_surv2_5;
var idm_surv2_5_txt;
var idm_surv2_key1;
var idm_surv2_key2;
var idm_surv2_key3;
var idm_surv2_key4;
var idm_surv2_key5;
var idm_surv2_resp;
var idm_instr1Clock;
var idm_instr1_title_txt;
var idm_instr1_txt;
var idm_instr1_space_txt;
var idm_instr1_resp;
var idm_instr2Clock;
var idm_instr2_title_txt;
var idm_instr2_cursor_txt;
var idm_instr2_space_txt;
var idm_instr2_resp;
var idm_warn2Clock;
var idm_warn2_title_txt;
var idm_warn2_warning_txt;
var idm_warn2_space_txt;
var idm_warn2_resp;
var cpdm_namer1Clock;
var cpdm_instr1Clock;
var cpdm_instr1_img;
var cpdm_instr1_title_txt;
var cpdm_instr1_txt;
var cpdm_instr1_Q_txt;
var cpdm_instr1_P_txt;
var cpdm_instr1_A_txt;
var cpdm_instr1_L_txt;
var cpdm_instr1_space_txt;
var cpdm_instr1_resp;
var cpdm_instr2Clock;
var cpdm_instr2_title_txt;
var cpdm_instr2_instr_txt;
var cpdm_instr2_left_arrow;
var cpdm_instr2_left_gabor;
var cpdm_instr2_left_txt;
var cpdm_instr2_right_arrow;
var cpdm_instr2_right_gabor;
var cpdm_instr2_right_txt;
var cpdm_instr2_space_txt;
var cpdm_instr2_resp;
var cpdm_instr3Clock;
var cpdm_instr3_title_txt;
var cpdm_instr3_txt;
var cpdm_instr3_space_txt;
var cpdm_instr3_resp;
var cpdm_instr4Clock;
var cpdm_instr4_title_txt;
var cpdm_instr4_txt;
var cpdm_instr4_space_txt;
var cpdm_instr4_resp;
var cpdm_warnClock;
var cpdm_warn1_title_txt;
var cpdm_warn1_txt;
var cpdm_warn1_space_txt;
var cpdm_warn1_resp;
var cpdm_pract_instrClock;
var cpdm_pract_instr_title_txt;
var cpdm_pract_instr_txt;
var cpdm_pract_instr_space_txt;
var cpdm_pract_instr_resp;
var cpdm_init_fixClock;
var cpdm_init_fix_poly;
var cpdm_pract_trialClock;
var left_high_color;
var left_low_color;
var right_high_color;
var right_low_color;
var cpdm_rand_num;
var cpdm_pract_trial_gabor;
var cpdm_pract_trial_left_high_poly;
var cpdm_pract_trial_right_high_poly;
var cpdm_pract_trial_left_low_poly;
var cpdm_pract_trial_right_low_poly;
var cpdm_pract_trial_left_high_txt;
var cpdm_pract_trial_right_high_txt;
var cpdm_pract_trial_left_low_txt;
var cpdm_pract_trial_right_low_txt;
var cpdm_pract_trial_resp;
var cpdm_pract_iti1Clock;
var cpdm_pract_iti1_poly;
var cpdm_trial_instrClock;
var cpdm_trial_instr_title_txt;
var cpdm_trial_instr_txt;
var cpdm_trial_instr_space_txt;
var cpdm_trial_instr_resp;
var cpdm_run_setterClock;
var cpdm_loop_instrClock;
var loop_spec_instr;
var run_counter;
var cpdm_loop_instr_code2;
var cpdm_loop_instr_corr_high_poly;
var cpdm_loop_instr_right_high_poly;
var cpdm_loop_instr_left_low_poly;
var cpdm_loop_instr_right_low_poly;
var cpdm_loop_instr_corr_high_txt;
var cpdm_loop_instr_incorr_high_txt;
var cpdm_loop_instr_corr_low_txt;
var cpdm_loop_instr_incorr_low;
var cpdm_loop_instr_space_txt;
var cpdm_loop_instr_resp;
var cpdm_trialClock;
var cpdm_delta_time;
var cpdm_trial_counter;
var cpdm_trial_gabor;
var cpdm_trial_left_high_poly;
var cpdm_trial_right_high_poly;
var cpdm_trial_left_low_poly;
var cpdm_trial_right_low_poly;
var cpdm_trial_left_high_txt;
var cpdm_trial_right_high_txt;
var cpdm_trial_left_low_txt;
var cpdm_trial_right_low_txt;
var cpdm_trial_resp;
var cpdm_trial_iti1Clock;
var cpdm_trials_iti1_poly;
var cpdm_run_break1Clock;
var cpdm_run_break_text;
var cpdm_space_text;
var cpdm_run_break1_title_txt;
var cpdm_run_break1_txt;
var cpdm_run_break1_space_txt;
var cpdm_run_break1_resp;
var idm_term_checkClock;
var crdm_namer1Clock;
var crdm_instr1Clock;
var crdm_instr1_title_txt;
var crdm_instr1_txt;
var crdm_instr1_space_txt;
var crdm_instr1_resp;
var crdm_instr2Clock;
var crdm_instr2_lottname_txt;
var crdm_instr2_txt;
var crdm_instr2_img;
var crdm_instr2_lott0_txt;
var crdm_instr2_lott20_txt;
var crdm_instr2_space_txt;
var crdm_instr2_resp;
var crdm_instr3Clock;
var crdm_instr3_lottname_txt;
var crdm_instr3_txt;
var crdm_instr3_img;
var crdm_instr3_lott0_txt;
var crdm_instr3_lott20_txt;
var crdm_instr3_space_txt;
var crdm_instr3_resp;
var crdm_instr4Clock;
var crdm_instr4_lottname_txt;
var crdm_instr4_txt;
var crdm_instr4_img;
var crdm_instr4_lott0_txt;
var crdm_instr4_lott20_txt;
var crdm_instr4_space_txt;
var crdm_instr4_resp;
var crdm_instr5Clock;
var crdm_instr5_txt;
var crdm_instr5_img;
var crdm_instr5_lott_top_txt;
var crdm_instr5_lott_bot_txt;
var crdm_instr5_sure_txt;
var crdm_instr5_space_txt;
var crdm_instr5_resp;
var crdm_instr6Clock;
var crdm_instr6_title_txt;
var crdm_instr6_txt;
var crdm_instr6_img;
var crdm_instr6_space_txt;
var crdm_instr6_resp;
var crdm_instr7Clock;
var crdm_instr7_title_txt;
var crdm_instr7_txt;
var crdm_instr7_img;
var crdm_instr7_space_txt;
var crdm_instr7_resp;
var crdm_warnClock;
var crdm_warn1_title_txt;
var crdm_warn1_txt;
var crdm_warn1_space_txt;
var crdm_warn1_resp;
var crdm_pract1_instrClock;
var crdm_pract1_instr_name_txt;
var crdm_pract1_instr_txt;
var crdm_pract1_instr_space_txt;
var crdm_pract1_instr_key;
var crdm_init_fixClock;
var crdm_init_fix_poly;
var crdm_pract1_trialClock;
var crdm_sure_pos1;
var crdm_sure_resp1;
var crdm_msg1;
var crdm_pos1;
var crdm_resp1;
var crdm_pract1_trial_img;
var crdm_pract1_trial_lott_top_txt;
var crdm_pract1_trial_lott_bot_txt;
var crdm_pract1_trial_sure_amt_txt;
var GRFX_fix4;
var crdm_pract1_trial_cue;
var crdm_pract1_trial_resp;
var crdm_pract1_feedbackClock;
var crdm_pract1_feedback_txt;
var crdm_qp_instrClock;
var crdm_qp_instr_title_txt;
var crdm_qp_instr_txt;
var crdm_qp_instr_space_txt;
var crdm_qp_instr_resp;
var crdm_questplusClock;
var crdm_sure_pos_qp;
var crdm_sure_resp_qp;
var crdm_msg_qp;
var crdm_pos_qp;
var crdm_resp_qp;
var weighted_avg;
var weighted_sd;
var crdm_value_space;
var crdm_ambiguity_space;
var crdm_probability_space;
var crdm_value_certain;
var crdm_alpha_space;
var crdm_beta_space;
var crdm_gamma_space;
var crdm_i;
var crdm_j;
var crdm_k;
var crdm_stim_space;
var crdm_gain_stim_space;
var crdm_loss_stim_space;
var crdm_params;
var crdm_response;
var crdm_contrast_idx_gain;
var crdm_contrast_idx_loss;
var crdm_func;
var crdm_q_gain;
var crdm_q_loss;
var crdm_questplus_img;
var crdm_questplus_trial_lott_top_txt;
var crdm_questplus_trial_lott_bot_txt;
var crdm_questplus_trial_sure_amt_txt;
var GRFX_fix3;
var crdm_questplus_trial_cue;
var crdm_questplus_trial_resp;
var crdm_qp_feedbackClock;
var crdm_qp_feedback_txt;
var crdm_schedule_genClock;
var crdm_pract2_instrClock;
var crdm_pract2_instr_name_txt;
var crdm_pract2_instr_txt;
var crdm_pract2_instr_space_txt;
var crdm_pract2_instr_key;
var crdm_pract2_trialClock;
var crdm_sure_pos2;
var crdm_sure_resp2;
var crdm_crdm_msg2;
var crdm_pos2;
var crdm_resp2;
var crdm_pract2_trial_img;
var crdm_pract2_trial_lott_top_txt;
var crdm_pract2_trial_lott_bot_txt;
var crdm_pract2_trial_sure_amt_txt;
var GRFX_fix2;
var crdm_pract2_trial_cue;
var crdm_pract2_trial_resp;
var crdm_pract2_feedbackClock;
var crdm_pract2_feedback_txt;
var crdm_pract2_confClock;
var crdm_pract2_conf_txt;
var crdm_pract2_conf1;
var crdm_pract2_conf1_txt;
var crdm_pract2_conf2;
var crdm_pract2_conf2_txt;
var crdm_pract2_conf3;
var crdm_pract2_conf3_txt;
var crdm_pract2_conf4;
var crdm_pract2_conf4_txt;
var crdm_pract2_conf_resp;
var crdm_pract2_iti1Clock;
var crdm_pract2_iti1_poly;
var crdm_trial_instrClock;
var crdm_trial_instr_title_txt;
var crdm_trial_instr_txt;
var crdm_trial_instr_space_txt;
var crdm_trial_instr_resp;
var crdm_trialClock;
var crdm_delta_time;
var crdm_sure_pos;
var crdm_sure_resp;
var crdm_msg;
var crdm_pos;
var crdm_resp;
var crdm_task_nonresp_ct;
var crdm_conf_nonresp_ct;
var crdm_trial_img;
var crdm_trial_lott_top;
var crdm_trial_lott_bot;
var crdm_trial_sure_amt;
var GRFX_fix;
var crdm_trial_cue;
var crdm_trial_resp;
var crdm_feedbackClock;
var crdm_feedback_txt;
var crdm_confClock;
var crdm_conf_txt;
var crdm_conf1;
var crdm_conf1_txt;
var crdm_conf2;
var crdm_conf2_txt;
var crdm_conf3;
var crdm_conf3_txt;
var crdm_conf4;
var crdm_conf4_txt;
var crdm_conf_resp;
var crdm_trials_iti1Clock;
var crdm_trials_iti1_poly;
var crdm_endClock;
var crdm_task_end_text;
var crdm_space_text;
var crdm_end_title_txt;
var crdm_end_txt_ON;
var crdm_end_space_ON;
var crdm_end_resp;
var cdd_namer1Clock;
var cdd_instr1Clock;
var cdd_instr1_title_txt;
var cdd_instr1_txt;
var cdd_instr1_space_txt;
var cdd_instr1_resp;
var cdd_instr2Clock;
var cdd_instr2_title_txt;
var cdd_instr2_txt;
var cdd_instr2_img;
var cdd_instr2_space_txt;
var cdd_instr2_resp;
var cdd_instr3Clock;
var cdd_instr3_title_txt;
var cdd_instr3_txt;
var cdd_instr3_img;
var cdd_instr3_space_txt;
var cdd_instr3_resp;
var cdd_warnClock;
var cdd_warn1_title_txt;
var cdd_warn1_txt;
var cdd_warn1_space_txt;
var cdd_warn1_resp;
var cdd_pract1_instrClock;
var cdd_pract1_instr_left_poly;
var cdd_pract1_instr_right_poly;
var cdd_pract1_instr_txt;
var cdd_pract1_instr_immed_txt;
var cdd_pract1_instr_delay_txt;
var cdd_pract1_instr_or_txt;
var cdd_pract1_instr_space_txt;
var cdd_pract1_instr_resp;
var cdd_init_fixClock;
var cdd_init_fix_polygon;
var cdd_pract1_trialClock;
var cdd_immed_pos1;
var cdd_delay_pos1;
var cdd_immed_resp1;
var cdd_msg1;
var cdd_pos1;
var cdd_resp1;
var cdd_pract1_trial_left_poly;
var cdd_pract1_trial_right_poly;
var cdd_pract1_trial_prompt_txt;
var cdd_pract1_trial_immed_txt;
var cdd_pract1_trial_or_txt;
var cdd_pract1_trial_delay_txt;
var cdd_pract1_trial_cue;
var cdd_pract1_trial_resp;
var cdd_pract1_feedbackClock;
var cdd_pract1_feedback_txt;
var cdd_qp_instrClock;
var cdd_qp_instr_title_txt;
var cdd_qp_instr_txt;
var cdd_qp_instr_space_txt;
var cdd_qp_instr_resp;
var cdd_questplusClock;
var cdd_immed_pos_qp;
var cdd_delay_pos_qp;
var cdd_immed_resp_qp;
var cdd_msg_qp;
var cdd_pos_qp;
var cdd_resp_qp;
var SV_DD;
var cdd_value_space;
var cdd_time_reward_space;
var cdd_value_fixed;
var cdd_alpha_space;
var cdd_kappa_space;
var cdd_gamma_space;
var cdd_stim_space;
var cdd_i;
var cdd_j;
var draw_from;
var cdd_params;
var cdd_func;
var cdd_response;
var cdd_contrast_idx;
var cdd_q;
var cdd_questplus_trial_left_poly;
var cdd_questplus_trial_right_poly;
var cdd_questplus_trial_prompt_txt;
var cdd_questplus_trial_immed_txt;
var cdd_questplus_trial_or_txt;
var cdd_questplus_trial_delay_txt;
var GRFX_fix2_2;
var cdd_questplus_trial_cue;
var cdd_questplus_trial_resp;
var cdd_questplus_fbClock;
var cdd_qp_fb_txt;
var cdd_schedule_genClock;
var clone;
var sum;
var random;
var cdd_pract2_instrClock;
var cdd_pract2_intr_name_txt;
var cdd_pract2_instr_txt;
var cdd_pract_instr_space_txt_2;
var cdd_pract_instr_resp_2;
var cdd_pract2_trialClock;
var cdd_immed_pos2;
var cdd_delay_pos2;
var cdd_immed_resp2;
var cdd_msg2;
var cdd_pos2;
var cdd_resp2;
var cdd_pract2_trial_left_poly;
var cdd_pract2_trial_right_poly;
var cdd_pract2_trial_prompt_txt;
var cdd_pract2_trial_immed_txt;
var cdd_pract2_trial_or_txt;
var cdd_pract2_trial_delay_txt;
var GRFX_fix3_2;
var cdd_pract2_trial_cue;
var cdd_pract2_trial_resp;
var cdd_pract2_feedbackClock;
var cdd_pract2_fb_txt;
var cdd_pract2_confClock;
var cdd_pract2_conf_txt;
var cdd_pract2_conf1;
var cdd_pract2_conf1_txt;
var cdd_pract2_conf2;
var cdd_pract2_conf2_txt;
var cdd_pract2_conf3;
var cdd_pract2_conf3_txt;
var cdd_pract2_conf4;
var cdd_pract2_conf4_txt;
var cdd_pract2_conf_resp;
var cdd_pract2_iti1Clock;
var cdd_pract2_iti1_poly;
var cdd_trial_instrClock;
var cdd_trial_instr_title_txt;
var cdd_trial_instr_txt;
var cdd_trial_instr_space_txt;
var cdd_trial_instr_resp;
var cdd_trialClock;
var cdd_delta_time;
var cdd_immed_pos;
var cdd_delay_pos;
var cdd_immed_resp;
var cdd_msg;
var cdd_pos;
var cdd_resp;
var cdd_task_nonresp_ct;
var cdd_conf_nonresp_ct;
var cdd_trial_left_poly;
var cdd_trial_right_poly;
var cdd_trial_prompt_txt;
var cdd_trial_immed_txt;
var cdd_trial_or_txt;
var cdd_trial_delay_txt;
var cdd_trial_cue;
var cdd_trial_resp;
var cdd_feedbackClock;
var cdd_feedback_txt;
var cdd_confClock;
var cdd_conf_txt;
var cdd_conf1;
var cdd_conf1_txt;
var cdd_conf2;
var cdd_conf2_txt;
var cdd_conf3;
var cdd_conf3_txt;
var cdd_conf4;
var cdd_conf4_txt;
var cdd_conf_resp;
var cdd_trial_iti1Clock;
var cdd_trial_iti1_poly;
var cdd_endClock;
var cdd_task_end_text;
var cdd_space_text;
var cdd_end_title_txt;
var cdd_end_txt_ON;
var cdd_end_space_ON;
var cdd_end_resp;
var cpdm_namer2Clock;
var cpdm_pract_iti2Clock;
var cpdm_pract_iti_poly_2;
var cpdm_trials_iti2Clock;
var cpdm_trials_iti2_poly;
var cpdm_run_break2Clock;
var cpdm_run_break2_title_txt;
var cpdm_run_break2_txt;
var cpdm_run_break2_space_txt;
var cpdm_run_break2_resp;
var crdm_namer2Clock;
var crdm_pract2_iti2Clock;
var crdm_pract2_iti2_poly;
var crdm_trials_iti2Clock;
var crdm_trials_iti2_poly;
var cdd_namer2Clock;
var cdd_pract2_iti2Clock;
var cdd_pract2_iti2_poly;
var cdd_trial_iti2Clock;
var cdd_trial_iti2_poly;
var cpdm_namer3Clock;
var cpdm_pract_iti3Clock;
var cpdm_pract_iti3_poly;
var cpdm_trials_iti3Clock;
var cpdm_trials_iti3_poly;
var cpdm_run_break3Clock;
var cpdm_run_break3_title_txt;
var cpdm_run_break3_txt;
var cpdm_run_break3_space_txt;
var cpdm_run_break3_resp;
var idm_rand_selectClock;
var cpdm_bonusClock;
var cpdm_bonus_thanks_txt;
var cpdm_bonus_earnings_txt;
var cpdm_bonus_amt_txt;
var cpdm_bonus_answer_txt;
var cpdm_bonus_acc_txt;
var cpdm_bonus_and_txt;
var cpdm_bonus_conf_txt;
var cpdm_bonus_space_txt;
var cpdm_bonus_resp;
var crdm_bonusClock;
var crdm_bonus_thanks_txt;
var crdm_bonus_lott_top;
var crdm_bonus_img;
var crdm_bonus_lott_bot;
var crdm_bonus_sure_amt_txt;
var crdm_bonus_prompt_txt;
var crdm_bonus_choice_text_txt;
var crdm_bonus_choice_outcome_txt;
var crdm_bonus_drawn_txt;
var crdm_bonus_chip_poly;
var crdm_bonus_winnings_txt;
var crdm_bonus_space_txt;
var crdm_bonus_resp;
var cdd_bonusClock;
var cdd_bonus_thanks_txt;
var cdd_bonus_box;
var cdd_bonus_choice_txt;
var cdd_bonus_rather_txt;
var cdd_bonus_other_txt;
var cdd_bonus_space_txt;
var cdd_bonus_resp;
var idm_comp_codeClock;
var comp_code;
var idm_comp_code_header_txt;
var idm_comp_code_num_txt;
var idm_comp_code_instr_txt;
var idm_comp_code_space_txt;
var idm_comp_code_key_resp;
var globalClock;
var routineTimer;
async function experimentInit() {
  // Initialize components for Routine "idm_consent1"
  idm_consent1Clock = new util.Clock();
  //function for random.random used in python
  
  const formatter = new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });
  format = formatter.format;
  
  
  arange_round = function(start,end,step=null) {
      if (step === null)
          step = 1;
      var arr = [];
      if (end > start) {
          for (var i=start; Math.round(i*10)/10 < end; i+=step) {
              arr.push(Math.round(i*10)/10);
          }
      } else {
          for (var i=start; Math.round(i*10)/10 > end; i+=step) {
              arr.push(Math.round(i*10)/10);
          }
      }
      return arr;
  }
  
  random_weighted_choice = function(items, weights){
      var i; 
      for (i = 0; i < weights.length; i++)
          weights[i] += weights[i - 1] || 0;
      var random = Math.random() * weights[weights.length - 1];
      for (i = 0; i < weights.length; i++)
          if (weights[i] > random)
              break;
      return items[i] 
  }
  
  
  range = function(start_stop, post_stop, step=1) {
      //# create a list sequence with a starting point, stopping point, and step size
      //#  the step size is assumed 1 if not provided
      //#  the first value is considered the stopping point if the second value is not given,
      //#   in which case the starting point is assumed to be 0.
      //#  post_stop is the non-inclusive end point.
      var arr = [];
      if (post_stop != undefined) {
          for (var i = start_stop; i < post_stop; i += step) {
              arr.push(i);
          }
      } else {
          for (var i = 0; i < start_stop; i += step) {
              arr.push(i);
          }
      }
      return arr;
  }
  
  arange = function(start_stop, post_stop, step=1, rounding=2) {
      //# same as range(), but with rounding built-in
      //# create a list sequence with a starting point, stopping point, and step size
      //#  the step size is assumed 1 if not provided
      //#  the first value is considered the stopping point if the second value is not given,
      //#   in which case the starting point is assumed to be 0.
      //#  post_stop is the non-inclusive end point.
      var arr = [];
      if (post_stop != undefined) {
          if (post_stop < start_stop) {
              for (var i = start_stop; i > post_stop; i += step) {
                  arr.push(round(i, rounding))
              } 
          } else {
              for (var i = start_stop; i < post_stop; i += step) {
                  arr.push(round(i, rounding))
              } 
          }
      } else {
          if (start_stop < 0) {
              for (var i = 0; i > start_stop; i += step) {
                  arr.push(round(i, rounding))
              }
          } else {
              for (var i = 0; i < start_stop; i += step) {
                  arr.push(round(i, rounding))
              }
          }
      }
      return arr;
  }
  idm_consent1_welcome_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent1_welcome_txt',
    text: 'Welcome to the Introspection and Decision Making Study ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent1_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent1_info_txt',
    text: 'The Introspection and Decision Making research study is intended for the scientific purpose of furthering our understanding of how people make decisions and their confidence regarding those choices. \n\nThe following consent information describes the study and is intended to help inform your choice to participate. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  idm_consent1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent2"
  idm_consent2Clock = new util.Clock();
  idm_consent2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent2_title_txt',
    text: 'Information on this Research',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent2_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent2_info_txt',
    text: 'The Introspection and Decision Making (IDM) study is conducted by the Computational Decision Neuroscience laboratory (CDN; Principal Investigator Dr. Silvia Lopez-Guzman) at the National Institute of Mental Health.  \n\nParticipation in the IDM study is entirely voluntary. You are not required to participate and refusal to do so will in no way affect access to any services or benefits. \n\nIf you choose to participate, you may quit at any time without penalty.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent3"
  idm_consent3Clock = new util.Clock();
  idm_consent3_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent3_title_txt',
    text: 'Why are we conducting this study?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent3_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent3_info_txt',
    text: 'Decision making is a complex process in which individuals evaluate and select between different options and/or courses of action. Understanding these principles and how our brain supports decision making is important not only for learning about healthy cognition and behavior, but also informs treatment to help those with certain mental health conditions. \n\nHere, we are investigating the relationship between decision making and value-based judgments. Additionally, we are interested in how people reflect upon, and the degree to which they are confident in, these choices.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent3_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent3_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent3_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent4"
  idm_consent4Clock = new util.Clock();
  idm_consent4_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent4_title_txt',
    text: 'What will I be asked to do and how long will it take?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent4_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent4_info_txt',
    text: 'In total, your participation is expected to take approximately 1 hours and 15 minutes: 2-3 minutes to complete 2 surveys, and 70 minutes to complete 3 computer-based tasks. \n\nThe first survey includes questions about demographic information, mental health history, and past/present substance use. The second survey assesses your ability to detect and recognize certain internal body states (e.g., hunger, thirst). ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent4_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent4_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent4_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent5"
  idm_consent5Clock = new util.Clock();
  idm_consent5_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent5_title_txt',
    text: 'What will I be asked to do and how long will it take?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent5_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent5_info_txt',
    text: 'The 3 computer-based tasks include:\n\n1. Visual Decision Making Task (~38 minutes). Make judgments about the tilt of an oriented pattern and your confidence about your decision.\n\n2. Risk & Ambiguity Task (~14 minutes). Choose between (1) receiving a certain smaller amount of money, or (2) playing a lottery for the chance to win a larger amount. Then rate how confidently you feel your choice truly reflects your preference.\n\n3. Delay Discounting Task (~18 minutes). Choose between (1) a smaller amount of money received today, or (2) a larger amount of money received in the future. Then rate how confidently you feel your choice truly reflects your preference.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent5_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent5_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent5_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent6"
  idm_consent6Clock = new util.Clock();
  idm_consent6_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent6_title_txt',
    text: 'What are the benefits and risks of participating in the study?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent6_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent6_info_txt',
    text: 'There are no direct benefits from participating in this research study. In addition, this study involves minimal risk to participants. However, the potential loss or compromise of confidentiality is a risk for all research in which data is collected from human participants. Loss or compromise of confidentiality involves the unauthorized access and/or use of participant data.\n\nTo minimize risk of data loss or compromise of confidentiality, Amazon Mechanical Turk (MTurk) will not collect any experimental data and CDN researchers will not have access to any personal identifiable information MTurk collects for the creation of your account. All tasks and questionnaires will be conducted on Pavlovia, a secure website separate from MTurk. Data you provide on Pavlovia will only be linked to your worker ID temporarily to ensure credit/compensation. Once data collection is complete, information linking your MTurk worker ID to data collected through Pavlovia will be destroyed. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent6_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent6_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent6_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent7"
  idm_consent7Clock = new util.Clock();
  idm_consent7_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent7_title_txt',
    text: 'Will I receive compensation for participating in this research study?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent7_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent7_info_txt',
    text: 'Your participation and earnest performance completing the two surveys and three computer-based tasks will entitle you to a fixed, standard compensation.\n\nIn addition, you may also receive a variable bonus. A single trial will be randomly-selected from one of three computer-based tasks. You will receive the monetary value associated with your specific choice on that trial, as per task instructions. The variable bonus encourages you to make each choice based on your true preference, as any trial has the chance to be made real with actual money. \n\n**IMPORTANT**\n\n1. Missing too many trials or responding in a manner that indicates you are not engaged with the task or do not understand instructions will result in the experiment terminating prematurely. You will not be compensated if the experiment is terminated for these reasons.\n\n2. You can only be paid for completing this study once. If you complete the IDM study a second time, you will not receive additional compensation.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent7_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent7_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent7_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent8"
  idm_consent8Clock = new util.Clock();
  idm_consent8_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent8_title_txt',
    text: 'Who can I talk to if I have questions?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent8_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent8_info_txt',
    text: 'If you have any questions or concerns regarding participation, contact the principal investigator:\n\nDr. Silvia Lopez-Guzman \nNIMHCDN@mail.nih.gov',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent8_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent8_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_consent8_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_consent9"
  idm_consent9Clock = new util.Clock();
  idm_consent9_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent9_title_txt',
    text: 'Consent to Participate',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_consent9_info_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_consent9_info_txt',
    text: 'If, after reading and understanding this consent information, you...\n\n\n\n*AGREE TO PARTICIPATE* \nPress the SPACE button on your keyboard to continue the IDM study. \nBy doing so, you indicate you (1) are at least 18 years old, (2) have read and understand the provided consent information, and (3) agree to participate in the IDM study. \n\n\n\n*DO NOT AGREE TO PARTICIPATE* \nPress the "ESC" button on your keyboard twice to exit the IDM study.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_consent9_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_thanks"
  idm_thanksClock = new util.Clock();
  idm_thanks_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_thanks_title_txt',
    text: '* Introspection and Decision Making Study *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_thanks_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_thanks_txt',
    text: 'Thank you for your decision to participate in the IDM study.\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_thanks_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_thanks_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_thanks_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_warn1"
  idm_warn1Clock = new util.Clock();
  idm_warn1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn1_title_txt',
    text: '*Warning*',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.8824, 0.0039, 0.0039]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_warn1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn1_txt',
    text: 'Please note if you do not respond to at least 95% of task trials, or provide responses which indicate you are not following task instructions, the EXPERIMENT WILL END and you will not receive any form of bonus payment.\n \nIf you do not wish to continue, you may quit at any time by pressing the ESC button twice.\n\nYour ability to follow task instructions will be assessed at each stage of the experiment. Please pay attention to all instructions. Read each screen carefully to ensure you understand what to do. Practice trials are provided to teach you how each task is performed. \n\nPlease do your best and remain engaged throughout the entire experiment.  ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_warn1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_warn1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_surv1_intro"
  idm_surv1_introClock = new util.Clock();
  idm_surv1_intro_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_intro_title_txt',
    text: '* Demographics Survey *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.1216, 0.4745, 0.1216]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_surv1_intro_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_intro_txt',
    text: 'The following survey contains 11 multiple choice questions and should take less than 5 minutes to complete.\n\nPlease use the number keys at the top of your keyboard to indicate your response. \n\nThe number associated with each response is displayed to the left.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_surv1_intro_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_intro_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_surv1_intro_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_surv1"
  idm_surv1Clock = new util.Clock();
  idm_surv1_question_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_question_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), 0.0], height: 0.04,  wrapWidth: 0.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_surv1_1 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_1', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0.35],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  idm_surv1_1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_1_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.35], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  idm_surv1_2 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_2', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0.2],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  idm_surv1_2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_2_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.2], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  idm_surv1_3 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_3', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0.05],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  idm_surv1_3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_3_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.05], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  idm_surv1_4 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_4', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, (- 0.1)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  idm_surv1_4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_4_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.1)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  idm_surv1_5 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_5', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, (- 0.25)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -10, interpolate: true,
  });
  
  idm_surv1_5_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_5_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.25)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -11.0 
  });
  
  idm_surv1_6 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv1_6', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, (- 0.4)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -12, interpolate: true,
  });
  
  idm_surv1_6_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_6_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -13.0 
  });
  
  idm_surv1_key1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0.35], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -14.0 
  });
  
  idm_surv1_key2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0.2], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -15.0 
  });
  
  idm_surv1_key3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0.05], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -16.0 
  });
  
  idm_surv1_key4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.1)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -17.0 
  });
  
  idm_surv1_key5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -18.0 
  });
  
  idm_surv1_key6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv1_key6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.4)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -19.0 
  });
  
  idm_surv1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_surv2_intro"
  idm_surv2_introClock = new util.Clock();
  idm_surv2_intro_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_intro_title_txt',
    text: '* Interoceptive Accuracy Scale *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.1216, 0.4745, 0.1216]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_surv2_intro_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_intro_txt',
    text: 'The following survey consists of 21 five-point scale questions about your ability to perceive internal physiological states and should take less than 5 minutes to complete.\n\nPlease use the number keys at the top of your keyboard to indicate your response. \n\nThe number associated with each response is displayed to the left.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_surv2_intro_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_intro_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_surv2_intro_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_surv2"
  idm_surv2Clock = new util.Clock();
  idm_surv2_stim_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_stim_txt',
    text: 'I can always accurately \nperceive when',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), 0.1], height: 0.05,  wrapWidth: 1.0, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_surv2_question_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_question_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), (- 0.05)], height: 0.05,  wrapWidth: 0.7, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_surv2_1 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv2_1', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0.3],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -3, interpolate: true,
  });
  
  idm_surv2_1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_1_txt',
    text: 'Strongly Agree',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.3], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  idm_surv2_2 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv2_2', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0.15],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  idm_surv2_2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_2_txt',
    text: 'Agree',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.15], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  idm_surv2_3 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv2_3', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  idm_surv2_3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_3_txt',
    text: 'Neither Agree or Disagree',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  idm_surv2_4 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv2_4', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, (- 0.15)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -9, interpolate: true,
  });
  
  idm_surv2_4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_4_txt',
    text: 'Disagree',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.15)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -10.0 
  });
  
  idm_surv2_5 = new visual.Rect ({
    win: psychoJS.window, name: 'idm_surv2_5', 
    width: [0.6, 0.1][0], height: [0.6, 0.1][1],
    ori: 0.0, pos: [0.3, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -11, interpolate: true,
  });
  
  idm_surv2_5_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_5_txt',
    text: 'Strongly Disagree',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.3)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -12.0 
  });
  
  idm_surv2_key1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_key1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0.3], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -13.0 
  });
  
  idm_surv2_key2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_key2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0.15], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -14.0 
  });
  
  idm_surv2_key3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_key3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -15.0 
  });
  
  idm_surv2_key4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_key4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.15)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -16.0 
  });
  
  idm_surv2_key5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_surv2_key5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -17.0 
  });
  
  idm_surv2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_instr1"
  idm_instr1Clock = new util.Clock();
  idm_instr1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr1_title_txt',
    text: '* Introspection and Decision Making Study *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_instr1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr1_txt',
    text: 'The computer-based decision making tasks will now begin. These tasks will be presented in random order. Opportunities will be provided for you to take breaks. Importantly, the IDM study must be completed in a single session. Do not close your browser until after you have received your *IDM Task Completion Code*\n\nAt the end of the experiment, a single trial will be randomly-selected from one of the computer-based tasks. This trial is your "bonus earnings trial" and will determine the amount of your variable bonus. How much money you receive will depend on the choice you made on that specific trial, as per task instructions.\n \nIn other words, each decision you make has a chance of actually happening! So make sure every choice *truly* reflects your preference.  \n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_instr1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_instr1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_instr2"
  idm_instr2Clock = new util.Clock();
  idm_instr2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr2_title_txt',
    text: '* Introspection and Decision Making Study *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_instr2_cursor_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr2_cursor_txt',
    text: 'During this experiment, all responses will be made using your keyboard.\n\nBefore you begin, please take this moment to move your mouse cursor to the edge of the screen. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_instr2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_instr2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_instr2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_warn2"
  idm_warn2Clock = new util.Clock();
  idm_warn2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn2_title_txt',
    text: '*Reminder*',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.8824, 0.0039, 0.0039]),  opacity: undefined,
    depth: 0.0 
  });
  
  idm_warn2_warning_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn2_warning_txt',
    text: 'Please remember if you respond to fewer than 95% of trials, or provide responses which indicate you are not following task instructions, the EXPERIMENT WILL END and you will not receive any form of payment or bonus. \n\nIf you do not wish to continue, you can end the task at any time by pressing the ESC button twice.\n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Remember, your choices could help you walk away with an additional bonus ranging from $2 to $65, depending on the seleced *bonus earnings trial*!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_warn2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_warn2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_warn2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_namer1"
  cpdm_namer1Clock = new util.Clock();
  // Initialize components for Routine "cpdm_instr1"
  cpdm_instr1Clock = new util.Clock();
  cpdm_instr1_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'cpdm_instr1_img', units : undefined, 
    image : 'cpdm/cpdm_keys.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.06)], size : [0.65, 0.25],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : 0.0 
  });
  cpdm_instr1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_instr1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_txt',
    text: 'You will be presented with a series of oriented patterns across multiple trials. Your job is to decide if the pattern is tilting to the left or right. In your response, you will also indicate how confident you are in your decision. \nThere are four possible response combinations:\n\n\n\n\n\n\n\n\n\n\nFor each trial, you will have 2 seconds to respond. \n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.0325,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_instr1_Q_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_Q_txt',
    text: 'Press Q for LEFT tilt and HIGH confidence\n',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), 0.07], height: 0.025,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([1.0, 0.6863, (- 1.0)]),  opacity: undefined,
    depth: -3.0 
  });
  
  cpdm_instr1_P_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_P_txt',
    text: 'Press P for RIGHT tilt and HIGH confidence\n',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.07], height: 0.025,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([1.0, 0.6863, (- 1.0)]),  opacity: undefined,
    depth: -4.0 
  });
  
  cpdm_instr1_A_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_A_txt',
    text: 'Press A for LEFT tilt and LOW confidence\n',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), (- 0.225)], height: 0.025,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([1.0, 0.6863, (- 1.0)]),  opacity: undefined,
    depth: -5.0 
  });
  
  cpdm_instr1_L_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_L_txt',
    text: 'Press L for RIGHT tilt and LOW confidence\n',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.225)], height: 0.025,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([1.0, 0.6863, (- 1.0)]),  opacity: undefined,
    depth: -6.0 
  });
  
  cpdm_instr1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_instr1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_instr2"
  cpdm_instr2Clock = new util.Clock();
  cpdm_instr2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr2_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_instr2_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr2_instr_txt',
    text: 'You can tell "tilt" by which direction the top of the pattern is pointing:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.2], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_instr2_left_arrow = new visual.ImageStim({
    win : psychoJS.window,
    name : 'cpdm_instr2_left_arrow', units : undefined, 
    image : 'cpdm/arrow.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [(- 0.4), 0.05], size : [0.15, 0.05],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  cpdm_instr2_left_gabor = new visual.GratingStim({
    win : psychoJS.window,
    name : 'cpdm_instr2_left_gabor', units : undefined, 
    tex : undefined, mask : 'gauss',
    ori : -5.0, pos : [(- 0.4), (- 0.1)],
    anchor : 'center',
    sf : 6.0, phase : 0.0,
    size : [0.25, 0.25],
    color : new util.Color([1,1,1]), opacity : undefined,
    contrast : 0.2, blendmode : 'avg',
    texRes : 128.0, interpolate : true, depth : -3.0 
  });
  cpdm_instr2_left_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr2_left_txt',
    text: 'This pattern tilts LEFT',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), (- 0.25)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cpdm_instr2_right_arrow = new visual.ImageStim({
    win : psychoJS.window,
    name : 'cpdm_instr2_right_arrow', units : undefined, 
    image : 'cpdm/arrow.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0.4, 0.05], size : [0.15, 0.05],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : true, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -5.0 
  });
  cpdm_instr2_right_gabor = new visual.GratingStim({
    win : psychoJS.window,
    name : 'cpdm_instr2_right_gabor', units : undefined, 
    tex : undefined, mask : 'gauss',
    ori : 5.0, pos : [0.4, (- 0.1)],
    anchor : 'center',
    sf : 6.0, phase : 0.0,
    size : [0.25, 0.25],
    color : new util.Color([1,1,1]), opacity : undefined,
    contrast : 0.2, blendmode : 'avg',
    texRes : 128.0, interpolate : true, depth : -6.0 
  });
  cpdm_instr2_right_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr2_right_txt',
    text: 'This pattern tilts RIGHT',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.25)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_instr2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  cpdm_instr2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_instr3"
  cpdm_instr3Clock = new util.Clock();
  cpdm_instr3_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr3_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_instr3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr3_txt',
    text: 'There are four (4) blocks of 200 trials. \n\nYour choice for each trial will determine how much money you could earn if that trial is randomly selected as your *bonus earnings* trial. The monetary values for each of the four responses may change from block to block. These values will be provided before each block, so pay careful attention.  ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_instr3_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr3_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_instr3_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_instr4"
  cpdm_instr4Clock = new util.Clock();
  cpdm_instr4_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr4_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_instr4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr4_txt',
    text: 'As you provide your responses, please note some pattern tilts will be harder to determine than others. On these trials, you may be less confident than on trials where the tilt is more obvious.\n\nPlease remember to distiguish between trials in which you feel high and low confidence regarding the tilt of the pattern.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_instr4_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_instr4_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_instr4_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_warn"
  cpdm_warnClock = new util.Clock();
  cpdm_warn1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_warn1_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_warn1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_warn1_txt',
    text: 'IMPORTANT: The experiment will end if you (1) miss more than 5% of trials per block, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_warn1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_warn1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_warn1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_pract_instr"
  cpdm_pract_instrClock = new util.Clock();
  cpdm_pract_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_instr_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_pract_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_instr_txt',
    text: "Let's practice!\n\nIn these example trials, the box you select will turn green if you make the correct choice regarding tilt of the pattern. If you are incorrect, the box you select will turn red. Feedback about performance during the practice trials is to help you understand the task, but will not be given during the actual experiment. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_pract_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_pract_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_init_fix"
  cpdm_init_fixClock = new util.Clock();
  cpdm_init_fix_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_init_fix_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: 0, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_pract_trial"
  cpdm_pract_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_pract_trial_code
  left_high_color = [0, 0, 0];
  left_low_color = [0, 0, 0];
  right_high_color = [0, 0, 0];
  right_low_color = [0, 0, 0];
  
  cpdm_rand_num = 0;
  cpdm_pract_trial_gabor = new visual.GratingStim({
    win : psychoJS.window,
    name : 'cpdm_pract_trial_gabor', units : undefined, 
    tex : undefined, mask : 'gauss',
    ori : 1.0, pos : [0, 0],
    anchor : 'center',
    sf : 6.0, phase : 0.0,
    size : [0.25, 0.25],
    color : new util.Color([1,1,1]), opacity : undefined,
    contrast : 1.0, blendmode : 'avg',
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  cpdm_pract_trial_left_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_pract_trial_left_high_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [(- 0.45), 0.25],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cpdm_pract_trial_right_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_pract_trial_right_high_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [0.45, 0.25],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -3, interpolate: true,
  });
  
  cpdm_pract_trial_left_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_pract_trial_left_low_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [(- 0.45), (- 0.25)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  cpdm_pract_trial_right_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_pract_trial_right_low_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [0.45, (- 0.25)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  cpdm_pract_trial_left_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_trial_left_high_txt',
    text: 'LEFT\n\nHIGH Confidence\n\n$9 or $0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.45), 0.25], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cpdm_pract_trial_right_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_trial_right_high_txt',
    text: 'RIGHT\n\nHIGH Confidence\n\n$9 or $0',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, 0.25], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_pract_trial_left_low_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_trial_left_low_txt',
    text: 'LEFT\n\nLOW Confidence\n\n$8 or $6',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.45), (- 0.25)], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  cpdm_pract_trial_right_low_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_pract_trial_right_low_txt',
    text: 'RIGHT\n\nLOW Confidence\n\n$8 or $6',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.25)], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  cpdm_pract_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_pract_iti1"
  cpdm_pract_iti1Clock = new util.Clock();
  cpdm_pract_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_pract_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_trial_instr"
  cpdm_trial_instrClock = new util.Clock();
  cpdm_trial_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_instr_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cpdm_trial_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_instr_txt',
    text: 'Now that you have practiced, the actual task will begin.\n\nIn the following four sections, you will be presented with a series of trials similar to those you just practiced. Here, you will not receive feedback about your performance. The option you select will turn light gray to indicate your choice. For each trial, you have 2 seconds to make your decision.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_trial_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_trial_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_run_setter"
  cpdm_run_setterClock = new util.Clock();
  // Initialize components for Routine "cpdm_loop_instr"
  cpdm_loop_instrClock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_loop_instr_code
  loop_spec_instr = "";
  run_counter = 1;
  
  cpdm_loop_instr_code2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_code2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_loop_instr_corr_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_loop_instr_corr_high_poly', 
    width: [0.25, 0.25][0], height: [0.25, 0.25][1],
    ori: 0.0, pos: [(- 0.125), 0.125],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0.0, 0.0, 0.0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cpdm_loop_instr_right_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_loop_instr_right_high_poly', 
    width: [0.25, 0.25][0], height: [0.25, 0.25][1],
    ori: 0.0, pos: [0.125, 0.125],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0.0, 0.0, 0.0]),
    opacity: undefined, depth: -3, interpolate: true,
  });
  
  cpdm_loop_instr_left_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_loop_instr_left_low_poly', 
    width: [0.25, 0.25][0], height: [0.25, 0.25][1],
    ori: 0.0, pos: [(- 0.125), (- 0.125)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0.0, 0.0, 0.0]),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  cpdm_loop_instr_right_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_loop_instr_right_low_poly', 
    width: [0.25, 0.25][0], height: [0.25, 0.25][1],
    ori: 0.0, pos: [0.125, (- 0.125)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0.0, 0.0, 0.0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  cpdm_loop_instr_corr_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_corr_high_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.125), 0.125], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.1216, 0.4745, 0.1216]),  opacity: undefined,
    depth: -6.0 
  });
  
  cpdm_loop_instr_incorr_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_incorr_high_txt',
    text: 'Incorrect\nHigh Confidence\n$0',
    font: 'Arial',
    units: undefined, 
    pos: [0.125, 0.125], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('salmon'),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_loop_instr_corr_low_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_corr_low_txt',
    text: 'Correct\nLow Confidence\n$8',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.125), (- 0.125)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('darkseagreen'),  opacity: undefined,
    depth: -8.0 
  });
  
  cpdm_loop_instr_incorr_low = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_incorr_low',
    text: 'Incorrect\nLow Confidence\n$6',
    font: 'Arial',
    units: undefined, 
    pos: [0.125, (- 0.125)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('salmon'),  opacity: undefined,
    depth: -9.0 
  });
  
  cpdm_loop_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_loop_instr_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -10.0 
  });
  
  cpdm_loop_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_trial"
  cpdm_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_trial_code
  cpdm_delta_time = 0;
  cpdm_trial_counter = 1;
  cpdm_trial_gabor = new visual.GratingStim({
    win : psychoJS.window,
    name : 'cpdm_trial_gabor', units : undefined, 
    tex : undefined, mask : 'gauss',
    ori : 1.0, pos : [0, 0],
    anchor : 'center',
    sf : 6.0, phase : 0.0,
    size : [0.25, 0.25],
    color : new util.Color([1,1,1]), opacity : undefined,
    contrast : 1.0, blendmode : 'avg',
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  cpdm_trial_left_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_trial_left_high_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [(- 0.45), 0.25],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cpdm_trial_right_high_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_trial_right_high_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [0.45, 0.25],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -3, interpolate: true,
  });
  
  cpdm_trial_left_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_trial_left_low_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [(- 0.45), (- 0.25)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  cpdm_trial_right_low_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cpdm_trial_right_low_poly', 
    width: [0.35, 0.35][0], height: [0.35, 0.35][1],
    ori: 0.0, pos: [0.45, (- 0.25)],
    anchor: 'center',
    lineWidth: 15.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  cpdm_trial_left_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_left_high_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.45), 0.25], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cpdm_trial_right_high_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_right_high_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, 0.25], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_trial_left_low_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_left_low_txt',
    text: 'LEFT\n\nLOW Confidence\n\n$8 or $6',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.45), (- 0.25)], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  cpdm_trial_right_low_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_trial_right_low_txt',
    text: 'RIGHT\n\nLOW Confidence\n\n$8 or $6',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.25)], height: 0.035,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  cpdm_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_trial_iti1"
  cpdm_trial_iti1Clock = new util.Clock();
  cpdm_trials_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_trials_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_run_break1"
  cpdm_run_break1Clock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_run_break1_code
  cpdm_run_break_text = "";
  cpdm_space_text = "";
  
  cpdm_run_break1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break1_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_run_break1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break1_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_run_break1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break1_space_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cpdm_run_break1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_term_check"
  idm_term_checkClock = new util.Clock();
  // Initialize components for Routine "crdm_namer1"
  crdm_namer1Clock = new util.Clock();
  // Initialize components for Routine "crdm_instr1"
  crdm_instr1Clock = new util.Clock();
  crdm_instr1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr1_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr1_txt',
    text: 'In this decision making task, you will be asked to make economic choices between: \n\n- Receiving a certain, smaller amount of money \nOR\n- Playing a lottery for the chance to win a larger amount of money \n\nYour choice for each trial will determine how much money you could earn if randomly selected as your bonus earnings trial. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_instr1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr2"
  crdm_instr2Clock = new util.Clock();
  crdm_instr2_lottname_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr2_lottname_txt',
    text: '*Playing the Lottery*',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr2_txt',
    text: 'The lottery consists of an imaginary bag containing 100 poker chips, some red and some blue. To play, you pull a random chip from the bag.  \n\nThe figure on the left represents the proportion of blue and red chips in the imaginary bag. \n\nHere, most chips are blue (75 of 100) and fewer are red (25 of 100).',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr2_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr2_img', units : 'height', 
    image : 'crdm/risk_blue_75.bmp', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0.6, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  crdm_instr2_lott0_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr2_lott0_txt',
    text: '$0',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, 0.3], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr2_lott20_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr2_lott20_txt',
    text: '$20',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  crdm_instr2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_instr2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr3"
  crdm_instr3Clock = new util.Clock();
  crdm_instr3_lottname_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr3_lottname_txt',
    text: '*Playing the Lottery*',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr3_txt',
    text: 'Given information about the number of blue and red chips in the bag, you can decide whether you would prefer a certain monetary outcome or if you would rather play the lottery for a chance to win a different amount.\n\nIn this example, you have a 75% chance of pulling a blue chip and winning $20. Conversely, you have a 25% chance of pulling a red chip and receiving $0.\n\nThe value for each color will change from bag to bag. Read the $ amounts above the red and below the blue to know the value of each chip color.',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0], height: 0.03,  wrapWidth: 1.0, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr3_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr3_img', units : undefined, 
    image : 'crdm/risk_blue_75.bmp', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0.6, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  crdm_instr3_lott0_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr3_lott0_txt',
    text: '$0',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, 0.3], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr3_lott20_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr3_lott20_txt',
    text: '$20',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  crdm_instr3_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr3_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_instr3_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr4"
  crdm_instr4Clock = new util.Clock();
  crdm_instr4_lottname_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr4_lottname_txt',
    text: '*Playing the Lottery*',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr4_txt',
    text: 'For some lotteries, information about the bag contents may be partially hidden. \n\nIn this example, at least 25 chips are blue and 25 chips are red. However, the color of the remaining 50 chips is unknown. The remaining 50 could be all red, all blue, or a combination of the two. ',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr4_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr4_img', units : undefined, 
    image : 'crdm/ambig_50.bmp', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0.6, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  crdm_instr4_lott0_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr4_lott0_txt',
    text: '$0',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, 0.3], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr4_lott20_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr4_lott20_txt',
    text: '$20',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  crdm_instr4_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr4_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_instr4_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr5"
  crdm_instr5Clock = new util.Clock();
  crdm_instr5_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr5_txt',
    text: 'The lottery bag will appear at the center of the screen. The certain dollar amount will be presented on either the right or left side of the bag. Here, a certain $5 would be the left option, and lottery would be the right option:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.03,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr5_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr5_img', units : undefined, 
    image : 'crdm/risk_blue_75.bmp', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.05)], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  crdm_instr5_lott_top_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr5_lott_top_txt',
    text: '$0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_instr5_lott_bot_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr5_lott_bot_txt',
    text: '$20',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr5_sure_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr5_sure_txt',
    text: '$5',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), (- 0.05)], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  crdm_instr5_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr5_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_instr5_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr6"
  crdm_instr6Clock = new util.Clock();
  crdm_instr6_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr6_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr6_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr6_txt',
    text: 'When the green circle appears, use the number keys at the top of your keyboard to indicate your choice:\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr6_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr6_img', units : undefined, 
    image : 'crdm/crdm_2key.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.1)], size : [0.6, 0.2],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  crdm_instr6_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr6_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr6_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_instr7"
  crdm_instr7Clock = new util.Clock();
  crdm_instr7_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr7_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_instr7_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr7_txt',
    text: "After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_instr7_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_instr7_img', units : undefined, 
    image : 'crdm/crdm_4key.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.15)], size : [0.6, 0.2],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  crdm_instr7_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_instr7_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_instr7_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_warn"
  crdm_warnClock = new util.Clock();
  crdm_warn1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_warn1_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_warn1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_warn1_txt',
    text: 'IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_warn1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_warn1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_warn1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_pract1_instr"
  crdm_pract1_instrClock = new util.Clock();
  crdm_pract1_instr_name_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_instr_name_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_pract1_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_instr_txt',
    text: "In this first section, you will only be asked to indicate your choice between the certain outcome and the lottery. You will not be asked to rate your choice confidence.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. \n\nLet's practice!",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_pract1_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_pract1_instr_key = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_init_fix"
  crdm_init_fixClock = new util.Clock();
  crdm_init_fix_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'crdm_init_fix_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: 0, interpolate: true,
  });
  
  // Initialize components for Routine "crdm_pract1_trial"
  crdm_pract1_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from crdm_pract1_trial_code
  crdm_sure_pos1 = [];
  crdm_sure_resp1 = [];
  crdm_msg1 = "";
  crdm_pos1 = [[(- 0.5), 0], [0.5, 0]];
  crdm_resp1 = ["1", "2"];
  
  crdm_pract1_trial_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_pract1_trial_img', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  crdm_pract1_trial_lott_top_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_trial_lott_top_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_pract1_trial_lott_bot_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_trial_lott_bot_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_pract1_trial_sure_amt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_trial_sure_amt_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  GRFX_fix4 = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix4', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  crdm_pract1_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'crdm_pract1_trial_cue', 
    edges: 100, size:[0.04, 0.04],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_pract1_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_pract1_feedback"
  crdm_pract1_feedbackClock = new util.Clock();
  crdm_pract1_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract1_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "crdm_qp_instr"
  crdm_qp_instrClock = new util.Clock();
  crdm_qp_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_qp_instr_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_qp_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_qp_instr_txt',
    text: "Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_qp_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_qp_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_qp_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_questplus"
  crdm_questplusClock = new util.Clock();
  // Run 'Begin Experiment' code from crdm_questplus_JS
  crdm_sure_pos_qp = [];
  crdm_sure_resp_qp = [];
  crdm_msg_qp = "";
  crdm_pos_qp = [[(- 0.5), 0], [0.5, 0]];
  crdm_resp_qp = ["1", "2"];
  
  weighted_avg = function(q) {
      var fits = [];
      var weight = 0;
      // q.param_domain, q.posterior
      var i, l;
      l = q.param_domain[0].length;
      while (fits.length < l) {
          fits.push(0);
      }
      for (i = 0; i < q.posterior.length; i++) {
          for (l = 0; l < fits.length; l++) {
              fits[l] += q.param_domain[i][l] * q.posterior[i];
          }
          weight += q.posterior[i];
      }
      for (l = 0; l < fits.length; l++) {
          fits[l] /= weight;
      }
      return fits;
  }
  
  // Sqrt(sum(w * (x - wm)^2) / sum(w))
  weighted_sd = function(q) {
      var fits = [];
      var weight = 0;
      var i, l;
      var wm = weighted_avg(q);
      l = q.param_domain[0].length;
      while (fits.length < l) {
          fits.push(0);
      }
      for (i = 0; i < q.posterior.length; i++) {
          for (l = 0; l < fits.length; l++) {
              fits[l] += q.posterior[i] * Math.pow((q.param_domain[i][l] - wm[l]), 2);
          }
          weight += q.posterior[i];
      }
      for (l = 0; l < fits.length; l++) {
          fits[l] /= weight;
          fits[l] = Math.sqrt(fits[l])
      }
      return fits;
  }
  
  crdm_value_space = [5, 8, 20, 40, 50];
  crdm_ambiguity_space = [0, 0.24, 0.5, 0.74];
  crdm_probability_space = [0.13, 0.25, 0.38, 0.5, 0.75];
  crdm_value_certain = 5;
  
  // parameter space 
  crdm_alpha_space = arange_round(0.1, 3.1, 0.1);
  crdm_beta_space =  arange_round(-1.3, 1.31, 0.1);
  crdm_gamma_space =  arange_round(0.5, 5.1, 0.5);
  
  crdm_i = 0;
  crdm_j = 0;
  crdm_k = 0;
  crdm_stim_space = []; // set for gain domain
  for (crdm_i = 0; crdm_i < crdm_value_space.length; crdm_i++) {
      for (crdm_j = 0; crdm_j < crdm_ambiguity_space.length; crdm_j++) {
          for (crdm_k = 0; crdm_k < crdm_probability_space.length; crdm_k++) {
              if (!crdm_ambiguity_space[crdm_j] || crdm_probability_space[crdm_k] == 0.5) {
                  crdm_stim_space.push([crdm_value_space[crdm_i], crdm_ambiguity_space[crdm_j], crdm_probability_space[crdm_k], crdm_value_certain]);
              }
          }
      }
  }
  crdm_gain_stim_space = crdm_stim_space;
  
  crdm_stim_space = []; // reset for loss domain
  for (crdm_i = 0; crdm_i < crdm_value_space.length; crdm_i++) {
      for (crdm_j = 0; crdm_j < crdm_ambiguity_space.length; crdm_j++) {
          for (crdm_k = 0; crdm_k < crdm_probability_space.length; crdm_k++) {
              if (!crdm_ambiguity_space[crdm_j] || crdm_probability_space[crdm_k] == 0.5) {
                  crdm_stim_space.push([-crdm_value_space[crdm_i], crdm_ambiguity_space[crdm_j], crdm_probability_space[crdm_k], -crdm_value_certain]);
              }
          }
      }
  }
  crdm_loss_stim_space = crdm_stim_space;
  
  crdm_params = [crdm_alpha_space, crdm_beta_space, crdm_gamma_space];
  crdm_response = true;
  
  // risk and ambiguity model
  function SV_option_RA(stimulus_values, params) {
      var prob;
      var objective_value = stimulus_values[0];
      var ambiguity = stimulus_values[1];
      var probability = stimulus_values[2];
      var value_certain = stimulus_values[3];
      var alpha_subject_risk_aversion = params[0];
      var beta_ambiguity_aversion = params[1];
      var sv_reward, sv_null, tmp;
      sv_reward = Math.sign(objective_value) * (probability - beta_ambiguity_aversion * (ambiguity/2)) * Math.pow(Math.abs(objective_value), alpha_subject_risk_aversion);
      sv_null = Math.sign(objective_value) * Math.pow(Math.abs(value_certain), alpha_subject_risk_aversion);
      var gamma = params[2];
      prob = 1. / (1 + Math.exp(-gamma * (sv_reward - sv_null)));
      return prob;
  }
  
  // subjective value decision
  function draw_from(stimulus_value, params, func) {
      var prob = func(stimulus_value, params);
      if (Math.random() < prob)
          return 1;
      else
          return 0;
  }
  
  // # uses contrast_idx instead of contrast for efficiency
  crdm_contrast_idx_gain = parseInt(Math.random() * crdm_stim_space.length);
  crdm_contrast_idx_loss = parseInt(Math.random() * crdm_stim_space.length);
  
  crdm_func = SV_option_RA;
  crdm_q_gain = new QuestPlus(crdm_stim_space, crdm_params, crdm_func);
  crdm_q_loss = new QuestPlus(crdm_stim_space, crdm_params, crdm_func);
  crdm_questplus_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_questplus_img', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  crdm_questplus_trial_lott_top_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_questplus_trial_lott_top_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_questplus_trial_lott_bot_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_questplus_trial_lott_bot_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_questplus_trial_sure_amt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_questplus_trial_sure_amt_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  GRFX_fix3 = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix3', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  crdm_questplus_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'crdm_questplus_trial_cue', 
    edges: 100, size:[0.04, 0.04],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_questplus_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_qp_feedback"
  crdm_qp_feedbackClock = new util.Clock();
  crdm_qp_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_qp_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "crdm_schedule_gen"
  crdm_schedule_genClock = new util.Clock();
  // Initialize components for Routine "crdm_pract2_instr"
  crdm_pract2_instrClock = new util.Clock();
  crdm_pract2_instr_name_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_instr_name_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  crdm_pract2_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_instr_txt',
    text: "In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_pract2_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_pract2_instr_key = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_pract2_trial"
  crdm_pract2_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from crdm_pract2_trial_code
  crdm_sure_pos2 = [];
  crdm_sure_resp2 = [];
  crdm_crdm_msg2 = "";
  crdm_pos2 = [[(- 0.5), 0], [0.5, 0]];
  crdm_resp2 = ["1", "2"];
  
  crdm_pract2_trial_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_pract2_trial_img', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  crdm_pract2_trial_lott_top_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_trial_lott_top_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_pract2_trial_lott_bot_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_trial_lott_bot_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_pract2_trial_sure_amt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_trial_sure_amt_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  GRFX_fix2 = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix2', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  crdm_pract2_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'crdm_pract2_trial_cue', 
    edges: 100, size:[0.04, 0.04],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_pract2_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_pract2_feedback"
  crdm_pract2_feedbackClock = new util.Clock();
  crdm_pract2_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "crdm_pract2_conf"
  crdm_pract2_confClock = new util.Clock();
  crdm_pract2_conf_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_conf_txt',
    text: 'How confident are you in your choice?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_pract2_conf1 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_pract2_conf1', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.6), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  crdm_pract2_conf1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_conf1_txt',
    text: 'Not at all\nconfident\n\n1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.6), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_pract2_conf2 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_pract2_conf2', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.2), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  crdm_pract2_conf2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_conf2_txt',
    text: 'Less\nconfident\n\n2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_pract2_conf3 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_pract2_conf3', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.2, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_pract2_conf3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_conf3_txt',
    text: 'Somewhat\nconfident\n\n3',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  crdm_pract2_conf4 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_pract2_conf4', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.6, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  crdm_pract2_conf4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_pract2_conf4_txt',
    text: 'Very\nconfident\n\n4',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  crdm_pract2_conf_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_pract2_iti1"
  crdm_pract2_iti1Clock = new util.Clock();
  crdm_pract2_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'crdm_pract2_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "crdm_trial_instr"
  crdm_trial_instrClock = new util.Clock();
  crdm_trial_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_instr_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_trial_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_instr_txt',
    text: 'Now that you have practiced, the actual task will begin.\n\nMake your choice between the certain outcome and lottery as soon as you see the green circle. You will have 3 seconds to consider and 2 seconds to respond. You will then have an additional 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_trial_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_trial_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_trial"
  crdm_trialClock = new util.Clock();
  //var crdm_sure_amt, crdm_sure_p, crdm_lott_top, crdm_lott_bot, crdm_lott_p, crdm_amb_lev, crdm_domain, crdm_img;
  //var delta_time, sure_pos, sure_resp, crdm_msg, pos, resp, task_nonresp_ct, conf_nonresp_ct;
  
  crdm_delta_time = 0; //used in variable ITI
  crdm_sure_pos = []; //position of certain option
  crdm_sure_resp = []; //response key for certain option
  crdm_msg = ""; //feedback message string
  crdm_pos = [[(- 0.5), 0], [0.5, 0]]; //left/right screen locations
  crdm_resp = ["1", "2"]; //1 = left, 2 = right
  crdm_task_nonresp_ct = 0;
  crdm_conf_nonresp_ct = 0;
  crdm_trial_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_trial_img', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, 0], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  crdm_trial_lott_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_lott_top',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_trial_lott_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_lott_bot',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_trial_sure_amt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_trial_sure_amt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  GRFX_fix = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -5, interpolate: true,
  });
  
  crdm_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'crdm_trial_cue', 
    edges: 100, size:[0.04, 0.04],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_feedback"
  crdm_feedbackClock = new util.Clock();
  crdm_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "crdm_conf"
  crdm_confClock = new util.Clock();
  crdm_conf_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_conf_txt',
    text: 'How confident are you in your choice?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_conf1 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_conf1', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.6), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  crdm_conf1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_conf1_txt',
    text: 'Not at all\nconfident\n\n1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.6), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_conf2 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_conf2', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.2), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  crdm_conf2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_conf2_txt',
    text: 'Less\nconfident\n\n2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_conf3 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_conf3', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.2, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  crdm_conf3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_conf3_txt',
    text: 'Somewhat\nconfident\n\n3',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  crdm_conf4 = new visual.Rect ({
    win: psychoJS.window, name: 'crdm_conf4', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.6, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  crdm_conf4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_conf4_txt',
    text: 'Very\nconfident\n\n4',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  crdm_conf_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_trials_iti1"
  crdm_trials_iti1Clock = new util.Clock();
  crdm_trials_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'crdm_trials_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "crdm_end"
  crdm_endClock = new util.Clock();
  // Run 'Begin Experiment' code from crdm_end_code
  crdm_task_end_text = "";
  crdm_space_text = "";
  
  crdm_end_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_end_title_txt',
    text: '* Risk & Ambiguity Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_end_txt_ON = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_end_txt_ON',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_end_space_ON = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_end_space_ON',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  crdm_end_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_namer1"
  cdd_namer1Clock = new util.Clock();
  // Initialize components for Routine "cdd_instr1"
  cdd_instr1Clock = new util.Clock();
  cdd_instr1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr1_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_instr1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr1_txt',
    text: 'In this decision making task, you will be asked indicate your preference between: \n\n- An amount of money you could receive today \nOR\n- An amount of money you could receive in the future \n\nThe value of each option and the length of delay will change across trials. One of your choices in this section may be randomly selected as your *bonus earnings trial* at the end of the experiment.\n\nExample: \n- If you chose $25 dollars immediately, you would receive $25 today.   \n- If you chose $50 in 15 days, you would receive $50 in 15 days. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_instr1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_instr1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_instr2"
  cdd_instr2Clock = new util.Clock();
  cdd_instr2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr2_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_instr2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr2_txt',
    text: 'Please read each options carefully. The immediate and delayed choices may switch sides.\n\nPress 1 to select the left option\nPress 2 to select the right option \n\n\n\n\n\n\n\n\nWhen the green circle appears, you will have 2 seconds to choose.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_instr2_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'cdd_instr2_img', units : undefined, 
    image : 'cdd/cdd_2key.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.05)], size : [0.6, 0.2],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  cdd_instr2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr2_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_instr2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_instr3"
  cdd_instr3Clock = new util.Clock();
  cdd_instr3_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr3_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_instr3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr3_txt',
    text: "After each choice, you will be asked to rate your choice confidence. \n1 indicates you couldn't decide which option you preferred and chose at random, while 4 indicates total certainty in your choice. Use the number keys at the top of your keyboard to indicate your confidence: \n\nPress 1 - Not at all confident\nPress 2 - Less confident\nPress 3 - Somewhat confident\nPress 4 - Very confident\n\n\n\n\n\n\n",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_instr3_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'cdd_instr3_img', units : undefined, 
    image : 'cdd/cdd_4key.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0, (- 0.15)], size : [0.6, 0.2],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  cdd_instr3_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_instr3_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_instr3_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_warn"
  cdd_warnClock = new util.Clock();
  cdd_warn1_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_warn1_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_warn1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_warn1_txt',
    text: 'IMPORTANT: You must answer both the choice and confidence prompts to complete each trial. The experiment will end if you (1) miss more than 5% of trials, or (2) provide responses which indicate you did not understand, or are not following, task instructions. If this happens, you will not be eligible to receive payment or a bonus. \n\nPlease remain engaged throughout the experiment and provide earnest, sincere responses for each trial. Thank you for your participation!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_warn1_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_warn1_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_warn1_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_pract1_instr"
  cdd_pract1_instrClock = new util.Clock();
  cdd_pract1_instr_left_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract1_instr_left_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.5), 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: 0, interpolate: true,
  });
  
  cdd_pract1_instr_right_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract1_instr_right_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.5, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  cdd_pract1_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_instr_txt',
    text: "*EXAMPLE TRIAL*\n\nWhich would you prefer?\n\n\n\n\n\n\n\n\nLet's practice!",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], height: 0.05,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_pract1_instr_immed_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_instr_immed_txt',
    text: '$10\n\nTODAY',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_pract1_instr_delay_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_instr_delay_txt',
    text: '$50 \n\n9 DAYS',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_pract1_instr_or_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_instr_or_txt',
    text: 'OR',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_pract1_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_instr_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cdd_pract1_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_init_fix"
  cdd_init_fixClock = new util.Clock();
  cdd_init_fix_polygon = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cdd_init_fix_polygon', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: 0, interpolate: true,
  });
  
  // Initialize components for Routine "cdd_pract1_trial"
  cdd_pract1_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from cdd_pract1_trial_code
  cdd_immed_pos1 = [];
  cdd_delay_pos1 = [];
  cdd_immed_resp1 = [];
  cdd_msg1 = "";
  cdd_pos1 = [[(- 0.5), 0], [0.5, 0]];
  cdd_resp1 = ["1", "2"];
  cdd_pract1_trial_left_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract1_trial_left_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.5), 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  cdd_pract1_trial_right_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract1_trial_right_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.5, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_pract1_trial_prompt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_trial_prompt_txt',
    text: 'Which would you prefer?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_pract1_trial_immed_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_trial_immed_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_pract1_trial_or_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_trial_or_txt',
    text: 'OR',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_pract1_trial_delay_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_trial_delay_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cdd_pract1_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'cdd_pract1_trial_cue', 
    edges: 100, size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  cdd_pract1_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_pract1_feedback"
  cdd_pract1_feedbackClock = new util.Clock();
  cdd_pract1_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract1_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "cdd_qp_instr"
  cdd_qp_instrClock = new util.Clock();
  cdd_qp_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_qp_instr_title_txt',
    text: '* Delayed Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_qp_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_qp_instr_txt',
    text: "Now that you've practiced, we'll begin the first section of the task. You will have 3 seconds to consider and 2 seconds to respond for each trial. Please make your choice when the green circle appears on the screen. \n\nIt is very important for you to answer each of the following trials.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_qp_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_qp_instr_space_txt',
    text: 'Press SPACE to begin.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_qp_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_questplus"
  cdd_questplusClock = new util.Clock();
  cdd_immed_pos_qp = [];
  cdd_delay_pos_qp = [];
  cdd_immed_resp_qp = [];
  cdd_msg_qp = "";
  cdd_pos_qp = [[(- 0.5), 0], [0.5, 0]];
  cdd_resp_qp = ["1", "2"];
  
  arange_round = function(start,end,step=null) {
              if (step === null)
                  step = 1;
              var arr = [];
              if (end > start) {
                  for (var i=start; Math.round(i*10)/10 < end; i+=step) {
                      arr.push(Math.round(i*10)/10);
                  }
              } else {
                  for (var i=start; Math.round(i*10)/10 > end; i+=step) {
                      arr.push(Math.round(i*10)/10);
                  }
              }
              return arr;
          }
  
  weighted_avg = function(q) {
      var fits = [];
      var weight = 0;
      // q.param_domain, q.posterior
      var i, l;
      l = q.param_domain[0].length;
      while (fits.length < l) {
          fits.push(0);
      }
      for (i = 0; i < q.posterior.length; i++) {
          for (l = 0; l < fits.length; l++) {
              fits[l] += q.param_domain[i][l] * q.posterior[i];
          }
          weight += q.posterior[i];
      }
      for (l = 0; l < fits.length; l++) {
          fits[l] /= weight;
      }
      return fits;
  }
  
  // Sqrt(sum(w * (x - wm)^2) / sum(w))
  weighted_sd = function(q) {
      var fits = [];
      var weight = 0;
      var i, l;
      var wm = weighted_avg(q);
      l = q.param_domain[0].length;
      while (fits.length < l) {
          fits.push(0);
      }
      for (i = 0; i < q.posterior.length; i++) {
          for (l = 0; l < fits.length; l++) {
              fits[l] += q.posterior[i] * Math.pow((q.param_domain[i][l] - wm[l]), 2);
          }
          weight += q.posterior[i];
      }
      for (l = 0; l < fits.length; l++) {
          fits[l] /= weight;
          fits[l] = Math.sqrt(fits[l])
      }
      return fits;
  }
  
  // delayed discounting
  SV_DD = function(stimulus_values, params) {
      var objective_value = stimulus_values[0];
      var delay_days = stimulus_values[1];
      var value_immed = stimulus_values[2];
      
      var alpha = params[0]; //#Ss risk aversion parameter
      var kappa = params[1]; //#discount_rate parameter
      var gamma = params[2]; //#curvature shape for decision boundary
      
      var sv_delay = Math.pow(objective_value, alpha)/(1+kappa*delay_days);
      var sv_immed = Math.pow(value_immed, alpha);
      var prob = 1./(1 + Math.exp(-gamma*(sv_delay-sv_immed)));
      return prob;
  }
  
  // gains value space
  cdd_value_space = [7, 14, 21, 30, 41, 50, 65];
  cdd_time_reward_space = [5, 10, 30, 60, 90, 150];
  cdd_value_fixed = 5; //previously 10, which is higher than the lowest possible delay amt
  cdd_alpha_space = arange_round(0.0, 3.1, 0.1); //# participant parameter space
  // discount rate
  cdd_kappa_space = [1e-05, 1.2648552168552958e-05, 1.5998587196060572e-05, 2.0235896477251556e-05, 2.559547922699533e-05, 3.237457542817647e-05, 4.094915062380427e-05, 5.1794746792312125e-05, 6.55128556859551e-05, 8.286427728546843e-05, 0.00010481131341546853, 0.00013257113655901095, 0.00016768329368110083, 0.00021209508879201905, 0.0002682695795279727, 0.000339322177189533, 0.00042919342601287783, 0.0005428675439323859, 0.0006866488450042998, 0.000868511373751353, 0.0010985411419875584, 0.0013894954943731374, 0.001757510624854793, 0.0022229964825261957, 0.002811768697974231, 0.0035564803062231283, 0.004498432668969444, 0.005689866029018299, 0.0071968567300115215, 0.009102981779915217, 0.011513953993264481, 0.014563484775012445, 0.018420699693267165, 0.023299518105153717, 0.029470517025518096, 0.037275937203149416, 0.04714866363457394, 0.05963623316594643, 0.07543120063354623, 0.09540954763499944, 0.1206792640639329, 0.15264179671752334, 0.19306977288832497, 0.244205309454865, 0.30888435964774846, 0.3906939937054621, 0.49417133613238384, 0.6250551925273976, 0.7906043210907702, 1.0];
  cdd_gamma_space =  arange_round(0.5, 5.1, 0.5);
  cdd_stim_space = [];
  cdd_i = 0;
  cdd_j = 0;
  for (cdd_i = 0; cdd_i < cdd_value_space.length; cdd_i++) {
      for (cdd_j = 0; cdd_j < cdd_time_reward_space.length; cdd_j++) {
          cdd_stim_space.push([cdd_value_space[cdd_i], cdd_time_reward_space[cdd_j], cdd_value_fixed]);
      }
  }
  
  // subjective value decision?
  draw_from = function(stimulus_value, params, func){
      var prob = func(stimulus_value, params);
      if (Math.random() < prob)
          return 1;
      else
          return 0;
  }
  
  cdd_params = [cdd_alpha_space, cdd_kappa_space, cdd_gamma_space];
  cdd_func = SV_DD;
  cdd_contrast_idx;
  cdd_response = true;
  cdd_contrast_idx = parseInt(Math.random() * cdd_stim_space.length);//parseInt(stim_space.length/2);
  cdd_q = new QuestPlus(cdd_stim_space, cdd_params, cdd_func);
  cdd_questplus_trial_left_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_questplus_trial_left_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.5), 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  cdd_questplus_trial_right_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_questplus_trial_right_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.5, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_questplus_trial_prompt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_questplus_trial_prompt_txt',
    text: 'Which would you prefer?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_questplus_trial_immed_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_questplus_trial_immed_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_questplus_trial_or_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_questplus_trial_or_txt',
    text: 'OR',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_questplus_trial_delay_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_questplus_trial_delay_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  GRFX_fix2_2 = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix2_2', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  cdd_questplus_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'cdd_questplus_trial_cue', 
    edges: 100, size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  cdd_questplus_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_questplus_fb"
  cdd_questplus_fbClock = new util.Clock();
  cdd_qp_fb_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_qp_fb_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "cdd_schedule_gen"
  cdd_schedule_genClock = new util.Clock();
  //# because Pavlovia doesn't auto-convert append or extend to push, 
  //#  make the same functions work for any javascript array by affecting the prototype
  Array.prototype.append = Array.prototype.push
  Array.prototype.extend = function(arr){this.push(...arr)};
  
  //# avoid using the "function name(){}" syntax
  //#  to account for Pavlovia's scope problems.
  
  range = function(start_stop, post_stop, step=1) {
      //# create a list sequence with a starting point, stopping point, and step size
      //#  the step size is assumed 1 if not provided
      //#  the first value is considered the stopping point if the second value is not given,
      //#   in which case the starting point is assumed to be 0.
      //#  post_stop is the non-inclusive end point.
      var arr = [];
      if (post_stop != undefined) {
          for (var i = start_stop; i < post_stop; i += step) {
              arr.push(i);
          }
      } else {
          for (var i = 0; i < start_stop; i += step) {
              arr.push(i);
          }
      }
      return arr;
  }
  
  arange = function(start_stop, post_stop, step=1, rounding=2) {
      //# same as range(), but with rounding built-in
      //# create a list sequence with a starting point, stopping point, and step size
      //#  the step size is assumed 1 if not provided
      //#  the first value is considered the stopping point if the second value is not given,
      //#   in which case the starting point is assumed to be 0.
      //#  post_stop is the non-inclusive end point.
      var arr = [];
      if (post_stop != undefined) {
          if (post_stop < start_stop) {
              for (var i = start_stop; i > post_stop; i += step) {
                  arr.push(round(i, rounding))
              } 
          } else {
              for (var i = start_stop; i < post_stop; i += step) {
                  arr.push(round(i, rounding))
              } 
          }
      } else {
          if (start_stop < 0) {
              for (var i = 0; i > start_stop; i += step) {
                  arr.push(round(i, rounding))
              }
          } else {
              for (var i = 0; i < start_stop; i += step) {
                  arr.push(round(i, rounding))
              }
          }
      }
      return arr;
  }
  
  clone = function(arr) {
      //# recursive function to deep copy arrays and dictionaries    
      var loops, tmp;
      //# see if it is an array
      //#  check a couple of things to try to avoid objects with these keys
      if (Array.isArray(arr)) {
          loops = arr;
          tmp = [];
      } else {
          loops = Object.keys(arr);
          tmp = {};
      }
      loops.forEach(function(val) {
          var value;
          //# if the looped items are the array, push() to a list
          if (loops === arr) {
              value = val;
              if (typeof(value) == "object") {
                  //# if the subelement is another complex object, 
                  //#  then clone it as well.
                  tmp.push(clone(value));
              } else {
                  tmp.push(value);
              }
          } else { //# if the looped items are the dictionary
                   //#  add them with the key
              value = arr[val];
              if (typeof(value) == "object") {
                  //# if the subelement is another complex object, 
                  //#  then clone it as well.
                  tmp[val] = clone(value);
              } else {
                  tmp[val] = value;
              }
          }
      })
      return tmp;
  }
  
  sum = function(arr){return arr.reduce((partialSum, a) => partialSum + a, 0)}
  
  
  random = {
      //# contains useful random number generation functions
      "random" : function(start_stop=1, post_stop=undefined, count=1) {
          var results = [];
          range(count).forEach(function() {
              if (post_stop != undefined) {
                  if (post_stop < start_stop) {
                      var tmp = post_stop;
                      post_stop = start_stop;
                      start_stop = tmp;
                  }
                  results.push((start_stop + Math.random() * (post_stop - start_stop)));
              } else {
                  //# if post_stop is not defined, start_stop is the non-inclusive max value.
                  results.push((Math.random() * start_stop));
              }
          });
          if (count == 1)
              return results[0];
              return results;       
      },
      
      "randint" : function(start_stop, post_stop, count=1) {
          var results = [];
          range(count).forEach(function() {
              //# Math.random() never gives exactly 1, so it
              //#  never reaches the provided max value.
              if (post_stop != undefined) {
                  if (post_stop < start_stop) {
                      var tmp = post_stop;
                      post_stop = start_stop;
                      start_stop = tmp;
                  }
                  results.push(parseInt(start_stop + Math.random() * (post_stop - start_stop)));
              } else {
                  //# if post_stop is not defined, start_stop is non-inclusive max value
                  results.push(parseInt(Math.random() * start_stop));
              }
          });
          if (count == 1)
              return results[0];
              return results;
      },
      
      "choice" : function(arr, count=1, with_replacement=true) {
          var results = [];
          if (with_replacement) {
              range(count).forEach(function() {
                  results.push(arr[random.randint(arr.length)]);
              });
          } else {
              //# make shallow copy to choose from.
              //#  you can always clone returned result if you want unique copies,
              //#  and it makes no difference for arrays of primitives 
              //#  (like numeric indices or string keys).
              var tmp = [...arr];
              range(count).forEach(function() {
                  if (tmp.length == 0)
                      //# refill array
                      tmp = [...arr];
                      results.push(tmp.splice(random.randint(tmp.length), 1));
              });
          }
          if (count == 1)
              return results[0];
              return results;
      }
  }
  // Initialize components for Routine "cdd_pract2_instr"
  cdd_pract2_instrClock = new util.Clock();
  cdd_pract2_intr_name_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_intr_name_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: 0.0 
  });
  
  cdd_pract2_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_instr_txt',
    text: "In this second section, you will now be asked to provide a confidence rating after your choice.\n\nWhen the green circle appears, indicate your decision by pressing 1 for the left option and 2 for the right option. Next, you will rate your choice confidence. Please be sure to answer both the task and confidence questions!\n\nLet's practice!",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_pract_instr_space_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract_instr_space_txt_2',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_pract_instr_resp_2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_pract2_trial"
  cdd_pract2_trialClock = new util.Clock();
  // Run 'Begin Experiment' code from cdd_pract2_trial_code
  cdd_immed_pos2 = [];
  cdd_delay_pos2 = [];
  cdd_immed_resp2 = [];
  cdd_msg2 = "";
  cdd_pos2 = [[(- 0.5), 0], [0.5, 0]];
  cdd_resp2 = ["1", "2"];
  
  cdd_pract2_trial_left_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_trial_left_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.5), 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  cdd_pract2_trial_right_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_trial_right_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.5, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_pract2_trial_prompt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_trial_prompt_txt',
    text: 'Which would you prefer?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_pract2_trial_immed_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_trial_immed_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_pract2_trial_or_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_trial_or_txt',
    text: 'OR',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_pract2_trial_delay_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_trial_delay_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  GRFX_fix3_2 = new visual.Rect ({
    win: psychoJS.window, name: 'GRFX_fix3_2', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([0, 0, 0]),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  cdd_pract2_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'cdd_pract2_trial_cue', 
    edges: 100, size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  cdd_pract2_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_pract2_feedback"
  cdd_pract2_feedbackClock = new util.Clock();
  cdd_pract2_fb_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_fb_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "cdd_pract2_conf"
  cdd_pract2_confClock = new util.Clock();
  cdd_pract2_conf_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_conf_txt',
    text: 'How confident are you in your choice?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_pract2_conf1 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_conf1', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.6), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_pract2_conf1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_conf1_txt',
    text: 'Not at all\nconfident\n\n1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.6), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_pract2_conf2 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_conf2', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.2), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  cdd_pract2_conf2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_conf2_txt',
    text: 'Less\nconfident\n\n2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_pract2_conf3 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_conf3', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.2, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  cdd_pract2_conf3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_conf3_txt',
    text: 'Somewhat\nconfident\n\n3',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cdd_pract2_conf4 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_pract2_conf4', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.6, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  cdd_pract2_conf4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_pract2_conf4_txt',
    text: 'Very\nconfident\n\n4',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  cdd_pract2_conf_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_pract2_iti1"
  cdd_pract2_iti1Clock = new util.Clock();
  cdd_pract2_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cdd_pract2_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cdd_trial_instr"
  cdd_trial_instrClock = new util.Clock();
  cdd_trial_instr_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_instr_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_trial_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_instr_txt',
    text: 'Now that you have practiced, the actual task will begin.\n\nRemember to make your choice between the immediate and delayed amounts when you see the green circle. You will have 3 seconds to consider both options and 2 seconds to make your choice. After each choice, you will be given 2 seconds to rate your choice confidence.\n\nWhen a white cross appears, please focus your attention on the center of the screen. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], height: 0.03,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_trial_instr_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_instr_space_txt',
    text: 'Press SPACE to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_trial_instr_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_trial"
  cdd_trialClock = new util.Clock();
  cdd_delta_time = 0;
  cdd_immed_pos = [];
  cdd_delay_pos = [];
  cdd_immed_resp = [];
  cdd_msg = "";
  cdd_pos = [[(- 0.5), 0], [0.5, 0]];
  cdd_resp = ["1", "2"];
  
  cdd_task_nonresp_ct = 0;
  cdd_conf_nonresp_ct = 0;
  cdd_trial_left_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_trial_left_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.5), 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  cdd_trial_right_poly = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_trial_right_poly', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.5, 0],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color([0, 0, 0]),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_trial_prompt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_prompt_txt',
    text: 'Which would you prefer?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_trial_immed_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_immed_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_trial_or_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_or_txt',
    text: 'OR',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_trial_delay_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_trial_delay_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cdd_trial_cue = new visual.Polygon({
    win: psychoJS.window, name: 'cdd_trial_cue', 
    edges: 100, size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    fillColor: new util.Color([(- 1.0), 1.0, (- 1.0)]),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  cdd_trial_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_feedback"
  cdd_feedbackClock = new util.Clock();
  cdd_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_feedback_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "cdd_conf"
  cdd_confClock = new util.Clock();
  cdd_conf_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_conf_txt',
    text: 'How confident are you in your choice?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.06,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_conf1 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_conf1', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.6), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -2, interpolate: true,
  });
  
  cdd_conf1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_conf1_txt',
    text: 'Not at all\nconfident\n\n1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.6), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_conf2 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_conf2', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [(- 0.2), (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -4, interpolate: true,
  });
  
  cdd_conf2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_conf2_txt',
    text: 'Less\nconfident\n\n2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_conf3 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_conf3', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.2, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -6, interpolate: true,
  });
  
  cdd_conf3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_conf3_txt',
    text: 'Somewhat\nconfident\n\n3',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  cdd_conf4 = new visual.Rect ({
    win: psychoJS.window, name: 'cdd_conf4', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0.0, pos: [0.6, (- 0.3)],
    anchor: 'center',
    lineWidth: 10.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -8, interpolate: true,
  });
  
  cdd_conf4_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_conf4_txt',
    text: 'Very\nconfident\n\n4',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.3)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  cdd_conf_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_trial_iti1"
  cdd_trial_iti1Clock = new util.Clock();
  cdd_trial_iti1_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cdd_trial_iti1_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([1.0, 1.0, 1.0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cdd_end"
  cdd_endClock = new util.Clock();
  // Run 'Begin Experiment' code from cdd_end_code
  cdd_task_end_text = "";
  cdd_space_text = "";
  
  cdd_end_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_end_title_txt',
    text: '* Delay Discounting Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_end_txt_ON = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_end_txt_ON',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_end_space_ON = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_end_space_ON',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_end_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cpdm_namer2"
  cpdm_namer2Clock = new util.Clock();
  // Initialize components for Routine "cpdm_pract_iti2"
  cpdm_pract_iti2Clock = new util.Clock();
  cpdm_pract_iti_poly_2 = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_pract_iti_poly_2', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_trials_iti2"
  cpdm_trials_iti2Clock = new util.Clock();
  cpdm_trials_iti2_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_trials_iti2_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_run_break2"
  cpdm_run_break2Clock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_run_break2_code
  cpdm_run_break_text = "";
  cpdm_space_text = "";
  
  cpdm_run_break2_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break2_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_run_break2_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break2_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 1.0,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_run_break2_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break2_space_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cpdm_run_break2_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_namer2"
  crdm_namer2Clock = new util.Clock();
  // Initialize components for Routine "crdm_pract2_iti2"
  crdm_pract2_iti2Clock = new util.Clock();
  crdm_pract2_iti2_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'crdm_pract2_iti2_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "crdm_trials_iti2"
  crdm_trials_iti2Clock = new util.Clock();
  crdm_trials_iti2_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'crdm_trials_iti2_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cdd_namer2"
  cdd_namer2Clock = new util.Clock();
  // Initialize components for Routine "cdd_pract2_iti2"
  cdd_pract2_iti2Clock = new util.Clock();
  cdd_pract2_iti2_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cdd_pract2_iti2_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cdd_trial_iti2"
  cdd_trial_iti2Clock = new util.Clock();
  cdd_trial_iti2_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cdd_trial_iti2_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([1.0, 1.0, 1.0]),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_namer3"
  cpdm_namer3Clock = new util.Clock();
  // Initialize components for Routine "cpdm_pract_iti3"
  cpdm_pract_iti3Clock = new util.Clock();
  cpdm_pract_iti3_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_pract_iti3_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_trials_iti3"
  cpdm_trials_iti3Clock = new util.Clock();
  cpdm_trials_iti3_poly = new visual.ShapeStim ({
    win: psychoJS.window, name: 'cpdm_trials_iti3_poly', 
    vertices: 'cross', size:[0.05, 0.05],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  // Initialize components for Routine "cpdm_run_break3"
  cpdm_run_break3Clock = new util.Clock();
  // Run 'Begin Experiment' code from cpdm_run_break3_code
  cpdm_run_break_text = "";
  cpdm_space_text = "";
  
  cpdm_run_break3_title_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break3_title_txt',
    text: '* Visual Decision Making Task *',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_run_break3_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break3_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_run_break3_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_run_break3_space_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  cpdm_run_break3_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_rand_select"
  idm_rand_selectClock = new util.Clock();
  // Initialize components for Routine "cpdm_bonus"
  cpdm_bonusClock = new util.Clock();
  cpdm_bonus_thanks_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_thanks_txt',
    text: 'Your randomly selected *bonus earnings trial* is from the\nVisual Decision Making Task!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cpdm_bonus_earnings_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_earnings_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.04,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cpdm_bonus_amt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_amt_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.08,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -3.0 
  });
  
  cpdm_bonus_answer_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_answer_txt',
    text: 'Your answer was',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cpdm_bonus_acc_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_acc_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  cpdm_bonus_and_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_and_txt',
    text: 'and',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cpdm_bonus_conf_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_conf_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.0588, 0.6157, 0.9608]),  opacity: undefined,
    depth: -7.0 
  });
  
  cpdm_bonus_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cpdm_bonus_space_txt',
    text: 'Press SPACE to receive your *COMPLETION CODE*',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  cpdm_bonus_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "crdm_bonus"
  crdm_bonusClock = new util.Clock();
  crdm_bonus_thanks_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_thanks_txt',
    text: 'Your randomly selected *bonus earnings trial* is from the\nRisk & Ambiguity Task!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], height: 0.05,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  crdm_bonus_lott_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_lott_top',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, 0.2], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  crdm_bonus_img = new visual.ImageStim({
    win : psychoJS.window,
    name : 'crdm_bonus_img', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0.0, pos : [0.6, (- 0.1)], size : [0.3, 0.5],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -3.0 
  });
  crdm_bonus_lott_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_lott_bot',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.6, (- 0.4)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  crdm_bonus_sure_amt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_sure_amt_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.35, (- 0.1)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  crdm_bonus_prompt_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_prompt_txt',
    text: 'In this trial, you chose:',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.2], height: 0.04,  wrapWidth: 1.0, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  crdm_bonus_choice_text_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_choice_text_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.1], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -7.0 
  });
  
  crdm_bonus_choice_outcome_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_choice_outcome_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0], height: 0.06,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -8.0 
  });
  
  crdm_bonus_drawn_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_drawn_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.1)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -9.0 
  });
  
  crdm_bonus_chip_poly = new visual.Polygon({
    win: psychoJS.window, name: 'crdm_bonus_chip_poly', 
    edges: 100, size:[0.075, 0.075],
    ori: 0.0, pos: [0, 0],
    anchor: 'center',
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -10, interpolate: true,
  });
  
  crdm_bonus_winnings_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_winnings_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.2)], height: 0.08,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -11.0 
  });
  
  crdm_bonus_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'crdm_bonus_space_txt',
    text: 'Press SPACE to receive your *COMPLETION CODE*',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -12.0 
  });
  
  crdm_bonus_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "cdd_bonus"
  cdd_bonusClock = new util.Clock();
  cdd_bonus_thanks_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_thanks_txt',
    text: 'Your randomly selected *bonus earnings trial* is from the\nDelay Discounting Task!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: 1.35, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -1.0 
  });
  
  cdd_bonus_box = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_box',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.15], height: 0.04,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  cdd_bonus_choice_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_choice_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.08,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.7098, 0.2941, (- 0.749)]),  opacity: undefined,
    depth: -3.0 
  });
  
  cdd_bonus_rather_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_rather_txt',
    text: 'rather than',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.125)], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  cdd_bonus_other_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_other_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.225)], height: 0.055,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.9608, 0.0039, (- 0.1059)]),  opacity: undefined,
    depth: -5.0 
  });
  
  cdd_bonus_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'cdd_bonus_space_txt',
    text: 'Press SPACE to receive your *COMPLETION CODE*',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -6.0 
  });
  
  cdd_bonus_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "idm_comp_code"
  idm_comp_codeClock = new util.Clock();
  // Run 'Begin Experiment' code from idm_code_code
  comp_code = "";
  
  idm_comp_code_header_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_comp_code_header_txt',
    text: 'Thank you for your participation!\nYour IDM Task Completion Code is:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  idm_comp_code_num_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_comp_code_num_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.08,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([0.1216, 0.4745, 0.1216]),  opacity: undefined,
    depth: -2.0 
  });
  
  idm_comp_code_instr_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_comp_code_instr_txt',
    text: 'Return to Amazon Mechanical Turk and enter the completion code to receive credit for your participation and ensure payment.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], height: 0.04,  wrapWidth: 1.25, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  idm_comp_code_space_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'idm_comp_code_space_txt',
    text: 'Press SPACE to exit session.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  idm_comp_code_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}


var t;
var frameN;
var continueRoutine;
var _idm_consent1_resp_allKeys;
var idm_consent1Components;
function idm_consent1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent1' ---
    t = 0;
    idm_consent1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent1.started', globalClock.getTime());
    idm_consent1_resp.keys = undefined;
    idm_consent1_resp.rt = undefined;
    _idm_consent1_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent1Components = [];
    idm_consent1Components.push(idm_consent1_welcome_txt);
    idm_consent1Components.push(idm_consent1_info_txt);
    idm_consent1Components.push(idm_consent1_space_txt);
    idm_consent1Components.push(idm_consent1_resp);
    
    for (const thisComponent of idm_consent1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent1' ---
    // get current time
    t = idm_consent1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent1_welcome_txt* updates
    if (t >= 0.0 && idm_consent1_welcome_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent1_welcome_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent1_welcome_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent1_welcome_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent1_info_txt* updates
    if (t >= 0.0 && idm_consent1_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent1_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent1_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent1_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent1_space_txt* updates
    if (t >= 0.0 && idm_consent1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent1_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent1_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent1_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent1_resp* updates
    if (t >= 0.0 && idm_consent1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent1_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent1_resp.clearEvents(); });
    }
    
    if (idm_consent1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent1_resp_allKeys = _idm_consent1_resp_allKeys.concat(theseKeys);
      if (_idm_consent1_resp_allKeys.length > 0) {
        idm_consent1_resp.keys = _idm_consent1_resp_allKeys[_idm_consent1_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent1_resp.rt = _idm_consent1_resp_allKeys[_idm_consent1_resp_allKeys.length - 1].rt;
        idm_consent1_resp.duration = _idm_consent1_resp_allKeys[_idm_consent1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent1' ---
    for (const thisComponent of idm_consent1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent1.stopped', globalClock.getTime());
    idm_consent1_resp.stop();
    // the Routine "idm_consent1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent2_resp_allKeys;
var idm_consent2Components;
function idm_consent2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent2' ---
    t = 0;
    idm_consent2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent2.started', globalClock.getTime());
    idm_consent2_resp.keys = undefined;
    idm_consent2_resp.rt = undefined;
    _idm_consent2_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent2Components = [];
    idm_consent2Components.push(idm_consent2_title_txt);
    idm_consent2Components.push(idm_consent2_info_txt);
    idm_consent2Components.push(idm_consent2_space_txt);
    idm_consent2Components.push(idm_consent2_resp);
    
    for (const thisComponent of idm_consent2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent2' ---
    // get current time
    t = idm_consent2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent2_title_txt* updates
    if (t >= 0.0 && idm_consent2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent2_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent2_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent2_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent2_info_txt* updates
    if (t >= 0.0 && idm_consent2_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent2_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent2_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent2_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent2_space_txt* updates
    if (t >= 0.0 && idm_consent2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent2_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent2_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent2_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent2_resp* updates
    if (t >= 0.0 && idm_consent2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent2_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent2_resp.clearEvents(); });
    }
    
    if (idm_consent2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent2_resp_allKeys = _idm_consent2_resp_allKeys.concat(theseKeys);
      if (_idm_consent2_resp_allKeys.length > 0) {
        idm_consent2_resp.keys = _idm_consent2_resp_allKeys[_idm_consent2_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent2_resp.rt = _idm_consent2_resp_allKeys[_idm_consent2_resp_allKeys.length - 1].rt;
        idm_consent2_resp.duration = _idm_consent2_resp_allKeys[_idm_consent2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent2' ---
    for (const thisComponent of idm_consent2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent2.stopped', globalClock.getTime());
    idm_consent2_resp.stop();
    // the Routine "idm_consent2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent3_resp_allKeys;
var idm_consent3Components;
function idm_consent3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent3' ---
    t = 0;
    idm_consent3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent3.started', globalClock.getTime());
    idm_consent3_resp.keys = undefined;
    idm_consent3_resp.rt = undefined;
    _idm_consent3_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent3Components = [];
    idm_consent3Components.push(idm_consent3_title_txt);
    idm_consent3Components.push(idm_consent3_info_txt);
    idm_consent3Components.push(idm_consent3_space_txt);
    idm_consent3Components.push(idm_consent3_resp);
    
    for (const thisComponent of idm_consent3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent3' ---
    // get current time
    t = idm_consent3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent3_title_txt* updates
    if (t >= 0.0 && idm_consent3_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent3_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent3_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent3_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent3_info_txt* updates
    if (t >= 0.0 && idm_consent3_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent3_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent3_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent3_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent3_space_txt* updates
    if (t >= 0.0 && idm_consent3_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent3_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent3_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent3_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent3_resp* updates
    if (t >= 0.0 && idm_consent3_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent3_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent3_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent3_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent3_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent3_resp.clearEvents(); });
    }
    
    if (idm_consent3_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent3_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent3_resp_allKeys = _idm_consent3_resp_allKeys.concat(theseKeys);
      if (_idm_consent3_resp_allKeys.length > 0) {
        idm_consent3_resp.keys = _idm_consent3_resp_allKeys[_idm_consent3_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent3_resp.rt = _idm_consent3_resp_allKeys[_idm_consent3_resp_allKeys.length - 1].rt;
        idm_consent3_resp.duration = _idm_consent3_resp_allKeys[_idm_consent3_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent3' ---
    for (const thisComponent of idm_consent3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent3.stopped', globalClock.getTime());
    idm_consent3_resp.stop();
    // the Routine "idm_consent3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent4_resp_allKeys;
var idm_consent4Components;
function idm_consent4RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent4' ---
    t = 0;
    idm_consent4Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent4.started', globalClock.getTime());
    idm_consent4_resp.keys = undefined;
    idm_consent4_resp.rt = undefined;
    _idm_consent4_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent4Components = [];
    idm_consent4Components.push(idm_consent4_title_txt);
    idm_consent4Components.push(idm_consent4_info_txt);
    idm_consent4Components.push(idm_consent4_space_txt);
    idm_consent4Components.push(idm_consent4_resp);
    
    for (const thisComponent of idm_consent4Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent4RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent4' ---
    // get current time
    t = idm_consent4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent4_title_txt* updates
    if (t >= 0.0 && idm_consent4_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent4_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent4_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent4_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent4_info_txt* updates
    if (t >= 0.0 && idm_consent4_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent4_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent4_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent4_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent4_space_txt* updates
    if (t >= 0.0 && idm_consent4_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent4_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent4_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent4_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent4_resp* updates
    if (t >= 0.0 && idm_consent4_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent4_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent4_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent4_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent4_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent4_resp.clearEvents(); });
    }
    
    if (idm_consent4_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent4_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent4_resp_allKeys = _idm_consent4_resp_allKeys.concat(theseKeys);
      if (_idm_consent4_resp_allKeys.length > 0) {
        idm_consent4_resp.keys = _idm_consent4_resp_allKeys[_idm_consent4_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent4_resp.rt = _idm_consent4_resp_allKeys[_idm_consent4_resp_allKeys.length - 1].rt;
        idm_consent4_resp.duration = _idm_consent4_resp_allKeys[_idm_consent4_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent4Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent4RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent4' ---
    for (const thisComponent of idm_consent4Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent4.stopped', globalClock.getTime());
    idm_consent4_resp.stop();
    // the Routine "idm_consent4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent5_resp_allKeys;
var idm_consent5Components;
function idm_consent5RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent5' ---
    t = 0;
    idm_consent5Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent5.started', globalClock.getTime());
    idm_consent5_resp.keys = undefined;
    idm_consent5_resp.rt = undefined;
    _idm_consent5_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent5Components = [];
    idm_consent5Components.push(idm_consent5_title_txt);
    idm_consent5Components.push(idm_consent5_info_txt);
    idm_consent5Components.push(idm_consent5_space_txt);
    idm_consent5Components.push(idm_consent5_resp);
    
    for (const thisComponent of idm_consent5Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent5RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent5' ---
    // get current time
    t = idm_consent5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent5_title_txt* updates
    if (t >= 0.0 && idm_consent5_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent5_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent5_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent5_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent5_info_txt* updates
    if (t >= 0.0 && idm_consent5_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent5_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent5_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent5_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent5_space_txt* updates
    if (t >= 0.0 && idm_consent5_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent5_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent5_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent5_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent5_resp* updates
    if (t >= 0.0 && idm_consent5_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent5_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent5_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent5_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent5_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent5_resp.clearEvents(); });
    }
    
    if (idm_consent5_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent5_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent5_resp_allKeys = _idm_consent5_resp_allKeys.concat(theseKeys);
      if (_idm_consent5_resp_allKeys.length > 0) {
        idm_consent5_resp.keys = _idm_consent5_resp_allKeys[_idm_consent5_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent5_resp.rt = _idm_consent5_resp_allKeys[_idm_consent5_resp_allKeys.length - 1].rt;
        idm_consent5_resp.duration = _idm_consent5_resp_allKeys[_idm_consent5_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent5Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent5RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent5' ---
    for (const thisComponent of idm_consent5Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent5.stopped', globalClock.getTime());
    idm_consent5_resp.stop();
    // the Routine "idm_consent5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent6_resp_allKeys;
var idm_consent6Components;
function idm_consent6RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent6' ---
    t = 0;
    idm_consent6Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent6.started', globalClock.getTime());
    idm_consent6_resp.keys = undefined;
    idm_consent6_resp.rt = undefined;
    _idm_consent6_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent6Components = [];
    idm_consent6Components.push(idm_consent6_title_txt);
    idm_consent6Components.push(idm_consent6_info_txt);
    idm_consent6Components.push(idm_consent6_space_txt);
    idm_consent6Components.push(idm_consent6_resp);
    
    for (const thisComponent of idm_consent6Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent6RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent6' ---
    // get current time
    t = idm_consent6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent6_title_txt* updates
    if (t >= 0.0 && idm_consent6_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent6_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent6_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent6_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent6_info_txt* updates
    if (t >= 0.0 && idm_consent6_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent6_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent6_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent6_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent6_space_txt* updates
    if (t >= 0.0 && idm_consent6_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent6_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent6_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent6_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent6_resp* updates
    if (t >= 0.0 && idm_consent6_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent6_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent6_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent6_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent6_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent6_resp.clearEvents(); });
    }
    
    if (idm_consent6_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent6_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent6_resp_allKeys = _idm_consent6_resp_allKeys.concat(theseKeys);
      if (_idm_consent6_resp_allKeys.length > 0) {
        idm_consent6_resp.keys = _idm_consent6_resp_allKeys[_idm_consent6_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent6_resp.rt = _idm_consent6_resp_allKeys[_idm_consent6_resp_allKeys.length - 1].rt;
        idm_consent6_resp.duration = _idm_consent6_resp_allKeys[_idm_consent6_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent6Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent6RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent6' ---
    for (const thisComponent of idm_consent6Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent6.stopped', globalClock.getTime());
    idm_consent6_resp.stop();
    // the Routine "idm_consent6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent7_resp_allKeys;
var idm_consent7Components;
function idm_consent7RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent7' ---
    t = 0;
    idm_consent7Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent7.started', globalClock.getTime());
    idm_consent7_resp.keys = undefined;
    idm_consent7_resp.rt = undefined;
    _idm_consent7_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent7Components = [];
    idm_consent7Components.push(idm_consent7_title_txt);
    idm_consent7Components.push(idm_consent7_info_txt);
    idm_consent7Components.push(idm_consent7_space_txt);
    idm_consent7Components.push(idm_consent7_resp);
    
    for (const thisComponent of idm_consent7Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent7RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent7' ---
    // get current time
    t = idm_consent7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent7_title_txt* updates
    if (t >= 0.0 && idm_consent7_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent7_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent7_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent7_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent7_info_txt* updates
    if (t >= 0.0 && idm_consent7_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent7_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent7_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent7_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent7_space_txt* updates
    if (t >= 0.0 && idm_consent7_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent7_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent7_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent7_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent7_resp* updates
    if (t >= 0.0 && idm_consent7_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent7_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent7_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent7_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent7_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent7_resp.clearEvents(); });
    }
    
    if (idm_consent7_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent7_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent7_resp_allKeys = _idm_consent7_resp_allKeys.concat(theseKeys);
      if (_idm_consent7_resp_allKeys.length > 0) {
        idm_consent7_resp.keys = _idm_consent7_resp_allKeys[_idm_consent7_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent7_resp.rt = _idm_consent7_resp_allKeys[_idm_consent7_resp_allKeys.length - 1].rt;
        idm_consent7_resp.duration = _idm_consent7_resp_allKeys[_idm_consent7_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent7Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent7RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent7' ---
    for (const thisComponent of idm_consent7Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent7.stopped', globalClock.getTime());
    idm_consent7_resp.stop();
    // the Routine "idm_consent7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent8_resp_allKeys;
var idm_consent8Components;
function idm_consent8RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent8' ---
    t = 0;
    idm_consent8Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent8.started', globalClock.getTime());
    idm_consent8_resp.keys = undefined;
    idm_consent8_resp.rt = undefined;
    _idm_consent8_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent8Components = [];
    idm_consent8Components.push(idm_consent8_title_txt);
    idm_consent8Components.push(idm_consent8_info_txt);
    idm_consent8Components.push(idm_consent8_space_txt);
    idm_consent8Components.push(idm_consent8_resp);
    
    for (const thisComponent of idm_consent8Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent8RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent8' ---
    // get current time
    t = idm_consent8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent8_title_txt* updates
    if (t >= 0.0 && idm_consent8_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent8_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent8_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent8_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent8_info_txt* updates
    if (t >= 0.0 && idm_consent8_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent8_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent8_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent8_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent8_space_txt* updates
    if (t >= 0.0 && idm_consent8_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent8_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent8_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent8_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent8_resp* updates
    if (t >= 0.0 && idm_consent8_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent8_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent8_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent8_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent8_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent8_resp.clearEvents(); });
    }
    
    if (idm_consent8_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent8_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent8_resp_allKeys = _idm_consent8_resp_allKeys.concat(theseKeys);
      if (_idm_consent8_resp_allKeys.length > 0) {
        idm_consent8_resp.keys = _idm_consent8_resp_allKeys[_idm_consent8_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent8_resp.rt = _idm_consent8_resp_allKeys[_idm_consent8_resp_allKeys.length - 1].rt;
        idm_consent8_resp.duration = _idm_consent8_resp_allKeys[_idm_consent8_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent8Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent8RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent8' ---
    for (const thisComponent of idm_consent8Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent8.stopped', globalClock.getTime());
    idm_consent8_resp.stop();
    // the Routine "idm_consent8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_consent9_resp_allKeys;
var idm_consent9Components;
function idm_consent9RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_consent9' ---
    t = 0;
    idm_consent9Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_consent9.started', globalClock.getTime());
    idm_consent9_resp.keys = undefined;
    idm_consent9_resp.rt = undefined;
    _idm_consent9_resp_allKeys = [];
    // keep track of which components have finished
    idm_consent9Components = [];
    idm_consent9Components.push(idm_consent9_title_txt);
    idm_consent9Components.push(idm_consent9_info_txt);
    idm_consent9Components.push(idm_consent9_resp);
    
    for (const thisComponent of idm_consent9Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_consent9RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_consent9' ---
    // get current time
    t = idm_consent9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_consent9_title_txt* updates
    if (t >= 0.0 && idm_consent9_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent9_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent9_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent9_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent9_info_txt* updates
    if (t >= 0.0 && idm_consent9_info_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent9_info_txt.tStart = t;  // (not accounting for frame time here)
      idm_consent9_info_txt.frameNStart = frameN;  // exact frame index
      
      idm_consent9_info_txt.setAutoDraw(true);
    }
    
    
    // *idm_consent9_resp* updates
    if (t >= 0.0 && idm_consent9_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_consent9_resp.tStart = t;  // (not accounting for frame time here)
      idm_consent9_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_consent9_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_consent9_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_consent9_resp.clearEvents(); });
    }
    
    if (idm_consent9_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_consent9_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_consent9_resp_allKeys = _idm_consent9_resp_allKeys.concat(theseKeys);
      if (_idm_consent9_resp_allKeys.length > 0) {
        idm_consent9_resp.keys = _idm_consent9_resp_allKeys[_idm_consent9_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_consent9_resp.rt = _idm_consent9_resp_allKeys[_idm_consent9_resp_allKeys.length - 1].rt;
        idm_consent9_resp.duration = _idm_consent9_resp_allKeys[_idm_consent9_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_consent9Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_consent9RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_consent9' ---
    for (const thisComponent of idm_consent9Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_consent9.stopped', globalClock.getTime());
    idm_consent9_resp.stop();
    // the Routine "idm_consent9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_thanks_resp_allKeys;
var idm_thanksComponents;
function idm_thanksRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_thanks' ---
    t = 0;
    idm_thanksClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_thanks.started', globalClock.getTime());
    idm_thanks_resp.keys = undefined;
    idm_thanks_resp.rt = undefined;
    _idm_thanks_resp_allKeys = [];
    // keep track of which components have finished
    idm_thanksComponents = [];
    idm_thanksComponents.push(idm_thanks_title_txt);
    idm_thanksComponents.push(idm_thanks_txt);
    idm_thanksComponents.push(idm_thanks_space_txt);
    idm_thanksComponents.push(idm_thanks_resp);
    
    for (const thisComponent of idm_thanksComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_thanksRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_thanks' ---
    // get current time
    t = idm_thanksClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_thanks_title_txt* updates
    if (t >= 0.0 && idm_thanks_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_thanks_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_thanks_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_thanks_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_thanks_txt* updates
    if (t >= 0.0 && idm_thanks_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_thanks_txt.tStart = t;  // (not accounting for frame time here)
      idm_thanks_txt.frameNStart = frameN;  // exact frame index
      
      idm_thanks_txt.setAutoDraw(true);
    }
    
    
    // *idm_thanks_space_txt* updates
    if (t >= 0.0 && idm_thanks_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_thanks_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_thanks_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_thanks_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_thanks_resp* updates
    if (t >= 0.0 && idm_thanks_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_thanks_resp.tStart = t;  // (not accounting for frame time here)
      idm_thanks_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_thanks_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_thanks_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_thanks_resp.clearEvents(); });
    }
    
    if (idm_thanks_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_thanks_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_thanks_resp_allKeys = _idm_thanks_resp_allKeys.concat(theseKeys);
      if (_idm_thanks_resp_allKeys.length > 0) {
        idm_thanks_resp.keys = _idm_thanks_resp_allKeys[_idm_thanks_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_thanks_resp.rt = _idm_thanks_resp_allKeys[_idm_thanks_resp_allKeys.length - 1].rt;
        idm_thanks_resp.duration = _idm_thanks_resp_allKeys[_idm_thanks_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_thanksComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_thanksRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_thanks' ---
    for (const thisComponent of idm_thanksComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_thanks.stopped', globalClock.getTime());
    idm_thanks_resp.stop();
    // the Routine "idm_thanks" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_warn1_resp_allKeys;
var idm_warn1Components;
function idm_warn1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_warn1' ---
    t = 0;
    idm_warn1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_warn1.started', globalClock.getTime());
    idm_warn1_resp.keys = undefined;
    idm_warn1_resp.rt = undefined;
    _idm_warn1_resp_allKeys = [];
    // keep track of which components have finished
    idm_warn1Components = [];
    idm_warn1Components.push(idm_warn1_title_txt);
    idm_warn1Components.push(idm_warn1_txt);
    idm_warn1Components.push(idm_warn1_space_txt);
    idm_warn1Components.push(idm_warn1_resp);
    
    for (const thisComponent of idm_warn1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_warn1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_warn1' ---
    // get current time
    t = idm_warn1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_warn1_title_txt* updates
    if (t >= 0.0 && idm_warn1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn1_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn1_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn1_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn1_txt* updates
    if (t >= 0.0 && idm_warn1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn1_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn1_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn1_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn1_space_txt* updates
    if (t >= 0.0 && idm_warn1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn1_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn1_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn1_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn1_resp* updates
    if (t >= 0.0 && idm_warn1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn1_resp.tStart = t;  // (not accounting for frame time here)
      idm_warn1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_warn1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_warn1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_warn1_resp.clearEvents(); });
    }
    
    if (idm_warn1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_warn1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_warn1_resp_allKeys = _idm_warn1_resp_allKeys.concat(theseKeys);
      if (_idm_warn1_resp_allKeys.length > 0) {
        idm_warn1_resp.keys = _idm_warn1_resp_allKeys[_idm_warn1_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_warn1_resp.rt = _idm_warn1_resp_allKeys[_idm_warn1_resp_allKeys.length - 1].rt;
        idm_warn1_resp.duration = _idm_warn1_resp_allKeys[_idm_warn1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_warn1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_warn1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_warn1' ---
    for (const thisComponent of idm_warn1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_warn1.stopped', globalClock.getTime());
    idm_warn1_resp.stop();
    // the Routine "idm_warn1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_surv1_intro_resp_allKeys;
var idm_surv1_introComponents;
function idm_surv1_introRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_surv1_intro' ---
    t = 0;
    idm_surv1_introClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_surv1_intro.started', globalClock.getTime());
    idm_surv1_intro_resp.keys = undefined;
    idm_surv1_intro_resp.rt = undefined;
    _idm_surv1_intro_resp_allKeys = [];
    // keep track of which components have finished
    idm_surv1_introComponents = [];
    idm_surv1_introComponents.push(idm_surv1_intro_title_txt);
    idm_surv1_introComponents.push(idm_surv1_intro_txt);
    idm_surv1_introComponents.push(idm_surv1_intro_space_txt);
    idm_surv1_introComponents.push(idm_surv1_intro_resp);
    
    for (const thisComponent of idm_surv1_introComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_surv1_introRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_surv1_intro' ---
    // get current time
    t = idm_surv1_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_surv1_intro_title_txt* updates
    if (t >= 0.0 && idm_surv1_intro_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_intro_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_intro_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_intro_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_intro_txt* updates
    if (t >= 0.0 && idm_surv1_intro_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_intro_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_intro_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_intro_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_intro_space_txt* updates
    if (t >= 0.0 && idm_surv1_intro_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_intro_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_intro_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_intro_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_intro_resp* updates
    if (t >= 0.0 && idm_surv1_intro_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_intro_resp.tStart = t;  // (not accounting for frame time here)
      idm_surv1_intro_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_surv1_intro_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_surv1_intro_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_surv1_intro_resp.clearEvents(); });
    }
    
    if (idm_surv1_intro_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_surv1_intro_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_surv1_intro_resp_allKeys = _idm_surv1_intro_resp_allKeys.concat(theseKeys);
      if (_idm_surv1_intro_resp_allKeys.length > 0) {
        idm_surv1_intro_resp.keys = _idm_surv1_intro_resp_allKeys[_idm_surv1_intro_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_surv1_intro_resp.rt = _idm_surv1_intro_resp_allKeys[_idm_surv1_intro_resp_allKeys.length - 1].rt;
        idm_surv1_intro_resp.duration = _idm_surv1_intro_resp_allKeys[_idm_surv1_intro_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_surv1_introComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_surv1_introRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_surv1_intro' ---
    for (const thisComponent of idm_surv1_introComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_surv1_intro.stopped', globalClock.getTime());
    idm_surv1_intro_resp.stop();
    // the Routine "idm_surv1_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var survey1;
function survey1LoopBegin(survey1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    survey1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'idm_survey1.xlsx',
      seed: undefined, name: 'survey1'
    });
    psychoJS.experiment.addLoop(survey1); // add the loop to the experiment
    currentLoop = survey1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisSurvey1 of survey1) {
      snapshot = survey1.getSnapshot();
      survey1LoopScheduler.add(importConditions(snapshot));
      survey1LoopScheduler.add(idm_surv1RoutineBegin(snapshot));
      survey1LoopScheduler.add(idm_surv1RoutineEachFrame());
      survey1LoopScheduler.add(idm_surv1RoutineEnd(snapshot));
      survey1LoopScheduler.add(survey1LoopEndIteration(survey1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function survey1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(survey1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function survey1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var survey2;
function survey2LoopBegin(survey2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    survey2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'idm_survey2.xlsx',
      seed: undefined, name: 'survey2'
    });
    psychoJS.experiment.addLoop(survey2); // add the loop to the experiment
    currentLoop = survey2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisSurvey2 of survey2) {
      snapshot = survey2.getSnapshot();
      survey2LoopScheduler.add(importConditions(snapshot));
      survey2LoopScheduler.add(idm_surv2RoutineBegin(snapshot));
      survey2LoopScheduler.add(idm_surv2RoutineEachFrame());
      survey2LoopScheduler.add(idm_surv2RoutineEnd(snapshot));
      survey2LoopScheduler.add(survey2LoopEndIteration(survey2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function survey2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(survey2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function survey2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run1;
function should_run1LoopBegin(should_run1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run1'
    });
    psychoJS.experiment.addLoop(should_run1); // add the loop to the experiment
    currentLoop = should_run1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run1 of should_run1) {
      snapshot = should_run1.getSnapshot();
      should_run1LoopScheduler.add(importConditions(snapshot));
      should_run1LoopScheduler.add(cpdm_namer1RoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_namer1RoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_namer1RoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_instr1RoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_instr1RoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_instr1RoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_instr2RoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_instr2RoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_instr2RoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_instr3RoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_instr3RoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_instr3RoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_instr4RoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_instr4RoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_instr4RoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_warnRoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_warnRoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_warnRoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_pract_instrRoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_pract_instrRoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_pract_instrRoutineEnd(snapshot));
      should_run1LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_pract_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run1LoopScheduler.add(cpdm_pract_trials1LoopBegin(cpdm_pract_trials1LoopScheduler, snapshot));
      should_run1LoopScheduler.add(cpdm_pract_trials1LoopScheduler);
      should_run1LoopScheduler.add(cpdm_pract_trials1LoopEnd);
      should_run1LoopScheduler.add(cpdm_trial_instrRoutineBegin(snapshot));
      should_run1LoopScheduler.add(cpdm_trial_instrRoutineEachFrame());
      should_run1LoopScheduler.add(cpdm_trial_instrRoutineEnd(snapshot));
      const condition_runs1LoopScheduler = new Scheduler(psychoJS);
      should_run1LoopScheduler.add(condition_runs1LoopBegin(condition_runs1LoopScheduler, snapshot));
      should_run1LoopScheduler.add(condition_runs1LoopScheduler);
      should_run1LoopScheduler.add(condition_runs1LoopEnd);
      should_run1LoopScheduler.add(should_run1LoopEndIteration(should_run1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_trials1;
function cpdm_pract_trials1LoopBegin(cpdm_pract_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_pract_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_practice.xlsx',
      seed: undefined, name: 'cpdm_pract_trials1'
    });
    psychoJS.experiment.addLoop(cpdm_pract_trials1); // add the loop to the experiment
    currentLoop = cpdm_pract_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_pract_trials1 of cpdm_pract_trials1) {
      snapshot = cpdm_pract_trials1.getSnapshot();
      cpdm_pract_trials1LoopScheduler.add(importConditions(snapshot));
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_trialRoutineBegin(snapshot));
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_trialRoutineEachFrame());
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_trialRoutineEnd(snapshot));
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_iti1RoutineBegin(snapshot));
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_iti1RoutineEachFrame());
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_iti1RoutineEnd(snapshot));
      cpdm_pract_trials1LoopScheduler.add(cpdm_pract_trials1LoopEndIteration(cpdm_pract_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_pract_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_pract_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_pract_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var condition_runs1;
function condition_runs1LoopBegin(condition_runs1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    condition_runs1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_run_type.xlsx',
      seed: undefined, name: 'condition_runs1'
    });
    psychoJS.experiment.addLoop(condition_runs1); // add the loop to the experiment
    currentLoop = condition_runs1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCondition_runs1 of condition_runs1) {
      snapshot = condition_runs1.getSnapshot();
      condition_runs1LoopScheduler.add(importConditions(snapshot));
      condition_runs1LoopScheduler.add(cpdm_run_setterRoutineBegin(snapshot));
      condition_runs1LoopScheduler.add(cpdm_run_setterRoutineEachFrame());
      condition_runs1LoopScheduler.add(cpdm_run_setterRoutineEnd(snapshot));
      condition_runs1LoopScheduler.add(cpdm_loop_instrRoutineBegin(snapshot));
      condition_runs1LoopScheduler.add(cpdm_loop_instrRoutineEachFrame());
      condition_runs1LoopScheduler.add(cpdm_loop_instrRoutineEnd(snapshot));
      condition_runs1LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      condition_runs1LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      condition_runs1LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_trials1LoopScheduler = new Scheduler(psychoJS);
      condition_runs1LoopScheduler.add(cpdm_trials1LoopBegin(cpdm_trials1LoopScheduler, snapshot));
      condition_runs1LoopScheduler.add(cpdm_trials1LoopScheduler);
      condition_runs1LoopScheduler.add(cpdm_trials1LoopEnd);
      condition_runs1LoopScheduler.add(cpdm_run_break1RoutineBegin(snapshot));
      condition_runs1LoopScheduler.add(cpdm_run_break1RoutineEachFrame());
      condition_runs1LoopScheduler.add(cpdm_run_break1RoutineEnd(snapshot));
      condition_runs1LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      condition_runs1LoopScheduler.add(idm_term_checkRoutineEachFrame());
      condition_runs1LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      condition_runs1LoopScheduler.add(condition_runs1LoopEndIteration(condition_runs1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_trials1;
function cpdm_trials1LoopBegin(cpdm_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm-1contrast.xlsx',
      seed: undefined, name: 'cpdm_trials1'
    });
    psychoJS.experiment.addLoop(cpdm_trials1); // add the loop to the experiment
    currentLoop = cpdm_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_trials1 of cpdm_trials1) {
      snapshot = cpdm_trials1.getSnapshot();
      cpdm_trials1LoopScheduler.add(importConditions(snapshot));
      cpdm_trials1LoopScheduler.add(cpdm_trialRoutineBegin(snapshot));
      cpdm_trials1LoopScheduler.add(cpdm_trialRoutineEachFrame());
      cpdm_trials1LoopScheduler.add(cpdm_trialRoutineEnd(snapshot));
      cpdm_trials1LoopScheduler.add(cpdm_trial_iti1RoutineBegin(snapshot));
      cpdm_trials1LoopScheduler.add(cpdm_trial_iti1RoutineEachFrame());
      cpdm_trials1LoopScheduler.add(cpdm_trial_iti1RoutineEnd(snapshot));
      cpdm_trials1LoopScheduler.add(cpdm_trials1LoopEndIteration(cpdm_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function condition_runs1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(condition_runs1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function condition_runs1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run2;
function should_run2LoopBegin(should_run2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop2, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run2'
    });
    psychoJS.experiment.addLoop(should_run2); // add the loop to the experiment
    currentLoop = should_run2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run2 of should_run2) {
      snapshot = should_run2.getSnapshot();
      should_run2LoopScheduler.add(importConditions(snapshot));
      should_run2LoopScheduler.add(crdm_namer1RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_namer1RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_namer1RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr1RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr1RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr1RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr2RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr2RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr2RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr3RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr3RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr3RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr4RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr4RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr4RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr5RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr5RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr5RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr6RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr6RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr6RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_instr7RoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_instr7RoutineEachFrame());
      should_run2LoopScheduler.add(crdm_instr7RoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_warnRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_warnRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_warnRoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_pract1_instrRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_pract1_instrRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_pract1_instrRoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_pract1_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run2LoopScheduler.add(crdm_pract1_trials1LoopBegin(crdm_pract1_trials1LoopScheduler, snapshot));
      should_run2LoopScheduler.add(crdm_pract1_trials1LoopScheduler);
      should_run2LoopScheduler.add(crdm_pract1_trials1LoopEnd);
      should_run2LoopScheduler.add(crdm_qp_instrRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_qp_instrRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_qp_instrRoutineEnd(snapshot));
      const crdm_qp_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run2LoopScheduler.add(crdm_qp_trials1LoopBegin(crdm_qp_trials1LoopScheduler, snapshot));
      should_run2LoopScheduler.add(crdm_qp_trials1LoopScheduler);
      should_run2LoopScheduler.add(crdm_qp_trials1LoopEnd);
      should_run2LoopScheduler.add(crdm_schedule_genRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_schedule_genRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_schedule_genRoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_pract2_instrRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_pract2_instrRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_pract2_instrRoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_pract2_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run2LoopScheduler.add(crdm_pract2_trials1LoopBegin(crdm_pract2_trials1LoopScheduler, snapshot));
      should_run2LoopScheduler.add(crdm_pract2_trials1LoopScheduler);
      should_run2LoopScheduler.add(crdm_pract2_trials1LoopEnd);
      should_run2LoopScheduler.add(crdm_trial_instrRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_trial_instrRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_trial_instrRoutineEnd(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run2LoopScheduler.add(crdm_trials1LoopBegin(crdm_trials1LoopScheduler, snapshot));
      should_run2LoopScheduler.add(crdm_trials1LoopScheduler);
      should_run2LoopScheduler.add(crdm_trials1LoopEnd);
      should_run2LoopScheduler.add(crdm_endRoutineBegin(snapshot));
      should_run2LoopScheduler.add(crdm_endRoutineEachFrame());
      should_run2LoopScheduler.add(crdm_endRoutineEnd(snapshot));
      should_run2LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      should_run2LoopScheduler.add(idm_term_checkRoutineEachFrame());
      should_run2LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      should_run2LoopScheduler.add(should_run2LoopEndIteration(should_run2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract1_trials1;
function crdm_pract1_trials1LoopBegin(crdm_pract1_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_pract1_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_practice1.csv',
      seed: undefined, name: 'crdm_pract1_trials1'
    });
    psychoJS.experiment.addLoop(crdm_pract1_trials1); // add the loop to the experiment
    currentLoop = crdm_pract1_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_pract1_trials1 of crdm_pract1_trials1) {
      snapshot = crdm_pract1_trials1.getSnapshot();
      crdm_pract1_trials1LoopScheduler.add(importConditions(snapshot));
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_trialRoutineBegin(snapshot));
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_trialRoutineEachFrame());
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_trialRoutineEnd(snapshot));
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_feedbackRoutineBegin(snapshot));
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_feedbackRoutineEachFrame());
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_feedbackRoutineEnd(snapshot));
      crdm_pract1_trials1LoopScheduler.add(crdm_pract1_trials1LoopEndIteration(crdm_pract1_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_pract1_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_pract1_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_pract1_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_qp_trials1;
function crdm_qp_trials1LoopBegin(crdm_qp_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_qp_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_questplus_trials.csv',
      seed: undefined, name: 'crdm_qp_trials1'
    });
    psychoJS.experiment.addLoop(crdm_qp_trials1); // add the loop to the experiment
    currentLoop = crdm_qp_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_qp_trials1 of crdm_qp_trials1) {
      snapshot = crdm_qp_trials1.getSnapshot();
      crdm_qp_trials1LoopScheduler.add(importConditions(snapshot));
      crdm_qp_trials1LoopScheduler.add(crdm_questplusRoutineBegin(snapshot));
      crdm_qp_trials1LoopScheduler.add(crdm_questplusRoutineEachFrame());
      crdm_qp_trials1LoopScheduler.add(crdm_questplusRoutineEnd(snapshot));
      crdm_qp_trials1LoopScheduler.add(crdm_qp_feedbackRoutineBegin(snapshot));
      crdm_qp_trials1LoopScheduler.add(crdm_qp_feedbackRoutineEachFrame());
      crdm_qp_trials1LoopScheduler.add(crdm_qp_feedbackRoutineEnd(snapshot));
      crdm_qp_trials1LoopScheduler.add(crdm_qp_trials1LoopEndIteration(crdm_qp_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_qp_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_qp_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_qp_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_pract2_trials1;
function crdm_pract2_trials1LoopBegin(crdm_pract2_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_pract2_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_practice2.csv',
      seed: undefined, name: 'crdm_pract2_trials1'
    });
    psychoJS.experiment.addLoop(crdm_pract2_trials1); // add the loop to the experiment
    currentLoop = crdm_pract2_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_pract2_trials1 of crdm_pract2_trials1) {
      snapshot = crdm_pract2_trials1.getSnapshot();
      crdm_pract2_trials1LoopScheduler.add(importConditions(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_trialRoutineBegin(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_trialRoutineEachFrame());
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_trialRoutineEnd(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_feedbackRoutineBegin(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_feedbackRoutineEachFrame());
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_feedbackRoutineEnd(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_confRoutineBegin(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_confRoutineEachFrame());
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_confRoutineEnd(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_iti1RoutineBegin(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_iti1RoutineEachFrame());
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_iti1RoutineEnd(snapshot));
      crdm_pract2_trials1LoopScheduler.add(crdm_pract2_trials1LoopEndIteration(crdm_pract2_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_pract2_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_pract2_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_pract2_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_trials1;
function crdm_trials1LoopBegin(crdm_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_gen_trials_idx.csv',
      seed: undefined, name: 'crdm_trials1'
    });
    psychoJS.experiment.addLoop(crdm_trials1); // add the loop to the experiment
    currentLoop = crdm_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_trials1 of crdm_trials1) {
      snapshot = crdm_trials1.getSnapshot();
      crdm_trials1LoopScheduler.add(importConditions(snapshot));
      crdm_trials1LoopScheduler.add(crdm_trialRoutineBegin(snapshot));
      crdm_trials1LoopScheduler.add(crdm_trialRoutineEachFrame());
      crdm_trials1LoopScheduler.add(crdm_trialRoutineEnd(snapshot));
      crdm_trials1LoopScheduler.add(crdm_feedbackRoutineBegin(snapshot));
      crdm_trials1LoopScheduler.add(crdm_feedbackRoutineEachFrame());
      crdm_trials1LoopScheduler.add(crdm_feedbackRoutineEnd(snapshot));
      crdm_trials1LoopScheduler.add(crdm_confRoutineBegin(snapshot));
      crdm_trials1LoopScheduler.add(crdm_confRoutineEachFrame());
      crdm_trials1LoopScheduler.add(crdm_confRoutineEnd(snapshot));
      crdm_trials1LoopScheduler.add(crdm_trials_iti1RoutineBegin(snapshot));
      crdm_trials1LoopScheduler.add(crdm_trials_iti1RoutineEachFrame());
      crdm_trials1LoopScheduler.add(crdm_trials_iti1RoutineEnd(snapshot));
      crdm_trials1LoopScheduler.add(crdm_trials1LoopEndIteration(crdm_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run3;
function should_run3LoopBegin(should_run3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop3, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run3'
    });
    psychoJS.experiment.addLoop(should_run3); // add the loop to the experiment
    currentLoop = should_run3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run3 of should_run3) {
      snapshot = should_run3.getSnapshot();
      should_run3LoopScheduler.add(importConditions(snapshot));
      should_run3LoopScheduler.add(cdd_namer1RoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_namer1RoutineEachFrame());
      should_run3LoopScheduler.add(cdd_namer1RoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_instr1RoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_instr1RoutineEachFrame());
      should_run3LoopScheduler.add(cdd_instr1RoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_instr2RoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_instr2RoutineEachFrame());
      should_run3LoopScheduler.add(cdd_instr2RoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_instr3RoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_instr3RoutineEachFrame());
      should_run3LoopScheduler.add(cdd_instr3RoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_warnRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_warnRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_warnRoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_pract1_instrRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_pract1_instrRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_pract1_instrRoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_pract1_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run3LoopScheduler.add(cdd_pract1_trials1LoopBegin(cdd_pract1_trials1LoopScheduler, snapshot));
      should_run3LoopScheduler.add(cdd_pract1_trials1LoopScheduler);
      should_run3LoopScheduler.add(cdd_pract1_trials1LoopEnd);
      should_run3LoopScheduler.add(cdd_qp_instrRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_qp_instrRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_qp_instrRoutineEnd(snapshot));
      const cdd_qp_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run3LoopScheduler.add(cdd_qp_trials1LoopBegin(cdd_qp_trials1LoopScheduler, snapshot));
      should_run3LoopScheduler.add(cdd_qp_trials1LoopScheduler);
      should_run3LoopScheduler.add(cdd_qp_trials1LoopEnd);
      should_run3LoopScheduler.add(cdd_schedule_genRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_schedule_genRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_schedule_genRoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_pract2_instrRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_pract2_instrRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_pract2_instrRoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_pract2_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run3LoopScheduler.add(cdd_pract2_trials1LoopBegin(cdd_pract2_trials1LoopScheduler, snapshot));
      should_run3LoopScheduler.add(cdd_pract2_trials1LoopScheduler);
      should_run3LoopScheduler.add(cdd_pract2_trials1LoopEnd);
      should_run3LoopScheduler.add(cdd_trial_instrRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_trial_instrRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_trial_instrRoutineEnd(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_trials1LoopScheduler = new Scheduler(psychoJS);
      should_run3LoopScheduler.add(cdd_trials1LoopBegin(cdd_trials1LoopScheduler, snapshot));
      should_run3LoopScheduler.add(cdd_trials1LoopScheduler);
      should_run3LoopScheduler.add(cdd_trials1LoopEnd);
      should_run3LoopScheduler.add(cdd_endRoutineBegin(snapshot));
      should_run3LoopScheduler.add(cdd_endRoutineEachFrame());
      should_run3LoopScheduler.add(cdd_endRoutineEnd(snapshot));
      should_run3LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      should_run3LoopScheduler.add(idm_term_checkRoutineEachFrame());
      should_run3LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      should_run3LoopScheduler.add(should_run3LoopEndIteration(should_run3LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract1_trials1;
function cdd_pract1_trials1LoopBegin(cdd_pract1_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_pract1_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_practice1.csv',
      seed: undefined, name: 'cdd_pract1_trials1'
    });
    psychoJS.experiment.addLoop(cdd_pract1_trials1); // add the loop to the experiment
    currentLoop = cdd_pract1_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_pract1_trials1 of cdd_pract1_trials1) {
      snapshot = cdd_pract1_trials1.getSnapshot();
      cdd_pract1_trials1LoopScheduler.add(importConditions(snapshot));
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_trialRoutineBegin(snapshot));
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_trialRoutineEachFrame());
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_trialRoutineEnd(snapshot));
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_feedbackRoutineBegin(snapshot));
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_feedbackRoutineEachFrame());
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_feedbackRoutineEnd(snapshot));
      cdd_pract1_trials1LoopScheduler.add(cdd_pract1_trials1LoopEndIteration(cdd_pract1_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_pract1_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_pract1_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_pract1_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_qp_trials1;
function cdd_qp_trials1LoopBegin(cdd_qp_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_qp_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_qp_trials.csv',
      seed: undefined, name: 'cdd_qp_trials1'
    });
    psychoJS.experiment.addLoop(cdd_qp_trials1); // add the loop to the experiment
    currentLoop = cdd_qp_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_qp_trials1 of cdd_qp_trials1) {
      snapshot = cdd_qp_trials1.getSnapshot();
      cdd_qp_trials1LoopScheduler.add(importConditions(snapshot));
      cdd_qp_trials1LoopScheduler.add(cdd_questplusRoutineBegin(snapshot));
      cdd_qp_trials1LoopScheduler.add(cdd_questplusRoutineEachFrame());
      cdd_qp_trials1LoopScheduler.add(cdd_questplusRoutineEnd(snapshot));
      cdd_qp_trials1LoopScheduler.add(cdd_questplus_fbRoutineBegin(snapshot));
      cdd_qp_trials1LoopScheduler.add(cdd_questplus_fbRoutineEachFrame());
      cdd_qp_trials1LoopScheduler.add(cdd_questplus_fbRoutineEnd(snapshot));
      cdd_qp_trials1LoopScheduler.add(cdd_qp_trials1LoopEndIteration(cdd_qp_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_qp_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_qp_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_qp_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_pract2_trials1;
function cdd_pract2_trials1LoopBegin(cdd_pract2_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_pract2_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_practice2.csv',
      seed: undefined, name: 'cdd_pract2_trials1'
    });
    psychoJS.experiment.addLoop(cdd_pract2_trials1); // add the loop to the experiment
    currentLoop = cdd_pract2_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_pract2_trials1 of cdd_pract2_trials1) {
      snapshot = cdd_pract2_trials1.getSnapshot();
      cdd_pract2_trials1LoopScheduler.add(importConditions(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_trialRoutineBegin(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_trialRoutineEachFrame());
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_trialRoutineEnd(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_feedbackRoutineBegin(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_feedbackRoutineEachFrame());
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_feedbackRoutineEnd(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_confRoutineBegin(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_confRoutineEachFrame());
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_confRoutineEnd(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_iti1RoutineBegin(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_iti1RoutineEachFrame());
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_iti1RoutineEnd(snapshot));
      cdd_pract2_trials1LoopScheduler.add(cdd_pract2_trials1LoopEndIteration(cdd_pract2_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_pract2_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_pract2_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_pract2_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_trials1;
function cdd_trials1LoopBegin(cdd_trials1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_trials1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_gen_trials_idx.csv',
      seed: undefined, name: 'cdd_trials1'
    });
    psychoJS.experiment.addLoop(cdd_trials1); // add the loop to the experiment
    currentLoop = cdd_trials1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_trials1 of cdd_trials1) {
      snapshot = cdd_trials1.getSnapshot();
      cdd_trials1LoopScheduler.add(importConditions(snapshot));
      cdd_trials1LoopScheduler.add(cdd_trialRoutineBegin(snapshot));
      cdd_trials1LoopScheduler.add(cdd_trialRoutineEachFrame());
      cdd_trials1LoopScheduler.add(cdd_trialRoutineEnd(snapshot));
      cdd_trials1LoopScheduler.add(cdd_feedbackRoutineBegin(snapshot));
      cdd_trials1LoopScheduler.add(cdd_feedbackRoutineEachFrame());
      cdd_trials1LoopScheduler.add(cdd_feedbackRoutineEnd(snapshot));
      cdd_trials1LoopScheduler.add(cdd_confRoutineBegin(snapshot));
      cdd_trials1LoopScheduler.add(cdd_confRoutineEachFrame());
      cdd_trials1LoopScheduler.add(cdd_confRoutineEnd(snapshot));
      cdd_trials1LoopScheduler.add(cdd_trial_iti1RoutineBegin(snapshot));
      cdd_trials1LoopScheduler.add(cdd_trial_iti1RoutineEachFrame());
      cdd_trials1LoopScheduler.add(cdd_trial_iti1RoutineEnd(snapshot));
      cdd_trials1LoopScheduler.add(cdd_trials1LoopEndIteration(cdd_trials1LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_trials1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_trials1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_trials1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run4;
function should_run4LoopBegin(should_run4LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run4 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop4, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run4'
    });
    psychoJS.experiment.addLoop(should_run4); // add the loop to the experiment
    currentLoop = should_run4;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run4 of should_run4) {
      snapshot = should_run4.getSnapshot();
      should_run4LoopScheduler.add(importConditions(snapshot));
      should_run4LoopScheduler.add(cpdm_namer2RoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_namer2RoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_namer2RoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_instr1RoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_instr1RoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_instr1RoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_instr2RoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_instr2RoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_instr2RoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_instr3RoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_instr3RoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_instr3RoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_instr4RoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_instr4RoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_instr4RoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_warnRoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_warnRoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_warnRoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_pract_instrRoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_pract_instrRoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_pract_instrRoutineEnd(snapshot));
      should_run4LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_pract_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run4LoopScheduler.add(cpdm_pract_trials2LoopBegin(cpdm_pract_trials2LoopScheduler, snapshot));
      should_run4LoopScheduler.add(cpdm_pract_trials2LoopScheduler);
      should_run4LoopScheduler.add(cpdm_pract_trials2LoopEnd);
      should_run4LoopScheduler.add(cpdm_trial_instrRoutineBegin(snapshot));
      should_run4LoopScheduler.add(cpdm_trial_instrRoutineEachFrame());
      should_run4LoopScheduler.add(cpdm_trial_instrRoutineEnd(snapshot));
      const condition_runs2LoopScheduler = new Scheduler(psychoJS);
      should_run4LoopScheduler.add(condition_runs2LoopBegin(condition_runs2LoopScheduler, snapshot));
      should_run4LoopScheduler.add(condition_runs2LoopScheduler);
      should_run4LoopScheduler.add(condition_runs2LoopEnd);
      should_run4LoopScheduler.add(should_run4LoopEndIteration(should_run4LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_trials2;
function cpdm_pract_trials2LoopBegin(cpdm_pract_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_pract_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_practice.xlsx',
      seed: undefined, name: 'cpdm_pract_trials2'
    });
    psychoJS.experiment.addLoop(cpdm_pract_trials2); // add the loop to the experiment
    currentLoop = cpdm_pract_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_pract_trials2 of cpdm_pract_trials2) {
      snapshot = cpdm_pract_trials2.getSnapshot();
      cpdm_pract_trials2LoopScheduler.add(importConditions(snapshot));
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_trialRoutineBegin(snapshot));
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_trialRoutineEachFrame());
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_trialRoutineEnd(snapshot));
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_iti2RoutineBegin(snapshot));
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_iti2RoutineEachFrame());
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_iti2RoutineEnd(snapshot));
      cpdm_pract_trials2LoopScheduler.add(cpdm_pract_trials2LoopEndIteration(cpdm_pract_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_pract_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_pract_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_pract_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var condition_runs2;
function condition_runs2LoopBegin(condition_runs2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    condition_runs2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_run_type.xlsx',
      seed: undefined, name: 'condition_runs2'
    });
    psychoJS.experiment.addLoop(condition_runs2); // add the loop to the experiment
    currentLoop = condition_runs2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCondition_runs2 of condition_runs2) {
      snapshot = condition_runs2.getSnapshot();
      condition_runs2LoopScheduler.add(importConditions(snapshot));
      condition_runs2LoopScheduler.add(cpdm_run_setterRoutineBegin(snapshot));
      condition_runs2LoopScheduler.add(cpdm_run_setterRoutineEachFrame());
      condition_runs2LoopScheduler.add(cpdm_run_setterRoutineEnd(snapshot));
      condition_runs2LoopScheduler.add(cpdm_loop_instrRoutineBegin(snapshot));
      condition_runs2LoopScheduler.add(cpdm_loop_instrRoutineEachFrame());
      condition_runs2LoopScheduler.add(cpdm_loop_instrRoutineEnd(snapshot));
      condition_runs2LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      condition_runs2LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      condition_runs2LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_trials2LoopScheduler = new Scheduler(psychoJS);
      condition_runs2LoopScheduler.add(cpdm_trials2LoopBegin(cpdm_trials2LoopScheduler, snapshot));
      condition_runs2LoopScheduler.add(cpdm_trials2LoopScheduler);
      condition_runs2LoopScheduler.add(cpdm_trials2LoopEnd);
      condition_runs2LoopScheduler.add(cpdm_run_break2RoutineBegin(snapshot));
      condition_runs2LoopScheduler.add(cpdm_run_break2RoutineEachFrame());
      condition_runs2LoopScheduler.add(cpdm_run_break2RoutineEnd(snapshot));
      condition_runs2LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      condition_runs2LoopScheduler.add(idm_term_checkRoutineEachFrame());
      condition_runs2LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      condition_runs2LoopScheduler.add(condition_runs2LoopEndIteration(condition_runs2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_trials2;
function cpdm_trials2LoopBegin(cpdm_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm-1contrast.xlsx',
      seed: undefined, name: 'cpdm_trials2'
    });
    psychoJS.experiment.addLoop(cpdm_trials2); // add the loop to the experiment
    currentLoop = cpdm_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_trials2 of cpdm_trials2) {
      snapshot = cpdm_trials2.getSnapshot();
      cpdm_trials2LoopScheduler.add(importConditions(snapshot));
      cpdm_trials2LoopScheduler.add(cpdm_trialRoutineBegin(snapshot));
      cpdm_trials2LoopScheduler.add(cpdm_trialRoutineEachFrame());
      cpdm_trials2LoopScheduler.add(cpdm_trialRoutineEnd(snapshot));
      cpdm_trials2LoopScheduler.add(cpdm_trials_iti2RoutineBegin(snapshot));
      cpdm_trials2LoopScheduler.add(cpdm_trials_iti2RoutineEachFrame());
      cpdm_trials2LoopScheduler.add(cpdm_trials_iti2RoutineEnd(snapshot));
      cpdm_trials2LoopScheduler.add(cpdm_trials2LoopEndIteration(cpdm_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function condition_runs2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(condition_runs2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function condition_runs2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run4LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run4);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run4LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run5;
function should_run5LoopBegin(should_run5LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run5 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop5, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run5'
    });
    psychoJS.experiment.addLoop(should_run5); // add the loop to the experiment
    currentLoop = should_run5;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run5 of should_run5) {
      snapshot = should_run5.getSnapshot();
      should_run5LoopScheduler.add(importConditions(snapshot));
      should_run5LoopScheduler.add(crdm_namer2RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_namer2RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_namer2RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr1RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr1RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr1RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr2RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr2RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr2RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr3RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr3RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr3RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr4RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr4RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr4RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr5RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr5RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr5RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr6RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr6RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr6RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_instr7RoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_instr7RoutineEachFrame());
      should_run5LoopScheduler.add(crdm_instr7RoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_warnRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_warnRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_warnRoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_pract1_instrRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_pract1_instrRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_pract1_instrRoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_pract1_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run5LoopScheduler.add(crdm_pract1_trials2LoopBegin(crdm_pract1_trials2LoopScheduler, snapshot));
      should_run5LoopScheduler.add(crdm_pract1_trials2LoopScheduler);
      should_run5LoopScheduler.add(crdm_pract1_trials2LoopEnd);
      should_run5LoopScheduler.add(crdm_qp_instrRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_qp_instrRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_qp_instrRoutineEnd(snapshot));
      const crdm_qp_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run5LoopScheduler.add(crdm_qp_trials2LoopBegin(crdm_qp_trials2LoopScheduler, snapshot));
      should_run5LoopScheduler.add(crdm_qp_trials2LoopScheduler);
      should_run5LoopScheduler.add(crdm_qp_trials2LoopEnd);
      should_run5LoopScheduler.add(crdm_schedule_genRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_schedule_genRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_schedule_genRoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_pract2_instrRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_pract2_instrRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_pract2_instrRoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_pract2_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run5LoopScheduler.add(crdm_pract2_trials2LoopBegin(crdm_pract2_trials2LoopScheduler, snapshot));
      should_run5LoopScheduler.add(crdm_pract2_trials2LoopScheduler);
      should_run5LoopScheduler.add(crdm_pract2_trials2LoopEnd);
      should_run5LoopScheduler.add(crdm_trial_instrRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_trial_instrRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_trial_instrRoutineEnd(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_init_fixRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_init_fixRoutineEnd(snapshot));
      const crdm_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run5LoopScheduler.add(crdm_trials2LoopBegin(crdm_trials2LoopScheduler, snapshot));
      should_run5LoopScheduler.add(crdm_trials2LoopScheduler);
      should_run5LoopScheduler.add(crdm_trials2LoopEnd);
      should_run5LoopScheduler.add(crdm_endRoutineBegin(snapshot));
      should_run5LoopScheduler.add(crdm_endRoutineEachFrame());
      should_run5LoopScheduler.add(crdm_endRoutineEnd(snapshot));
      should_run5LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      should_run5LoopScheduler.add(idm_term_checkRoutineEachFrame());
      should_run5LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      should_run5LoopScheduler.add(should_run5LoopEndIteration(should_run5LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract1_trials2;
function crdm_pract1_trials2LoopBegin(crdm_pract1_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_pract1_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_practice1.csv',
      seed: undefined, name: 'crdm_pract1_trials2'
    });
    psychoJS.experiment.addLoop(crdm_pract1_trials2); // add the loop to the experiment
    currentLoop = crdm_pract1_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_pract1_trials2 of crdm_pract1_trials2) {
      snapshot = crdm_pract1_trials2.getSnapshot();
      crdm_pract1_trials2LoopScheduler.add(importConditions(snapshot));
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_trialRoutineBegin(snapshot));
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_trialRoutineEachFrame());
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_trialRoutineEnd(snapshot));
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_feedbackRoutineBegin(snapshot));
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_feedbackRoutineEachFrame());
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_feedbackRoutineEnd(snapshot));
      crdm_pract1_trials2LoopScheduler.add(crdm_pract1_trials2LoopEndIteration(crdm_pract1_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_pract1_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_pract1_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_pract1_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_qp_trials2;
function crdm_qp_trials2LoopBegin(crdm_qp_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_qp_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_questplus_trials.csv',
      seed: undefined, name: 'crdm_qp_trials2'
    });
    psychoJS.experiment.addLoop(crdm_qp_trials2); // add the loop to the experiment
    currentLoop = crdm_qp_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_qp_trials2 of crdm_qp_trials2) {
      snapshot = crdm_qp_trials2.getSnapshot();
      crdm_qp_trials2LoopScheduler.add(importConditions(snapshot));
      crdm_qp_trials2LoopScheduler.add(crdm_questplusRoutineBegin(snapshot));
      crdm_qp_trials2LoopScheduler.add(crdm_questplusRoutineEachFrame());
      crdm_qp_trials2LoopScheduler.add(crdm_questplusRoutineEnd(snapshot));
      crdm_qp_trials2LoopScheduler.add(crdm_qp_feedbackRoutineBegin(snapshot));
      crdm_qp_trials2LoopScheduler.add(crdm_qp_feedbackRoutineEachFrame());
      crdm_qp_trials2LoopScheduler.add(crdm_qp_feedbackRoutineEnd(snapshot));
      crdm_qp_trials2LoopScheduler.add(crdm_qp_trials2LoopEndIteration(crdm_qp_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_qp_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_qp_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_qp_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_pract2_trials2;
function crdm_pract2_trials2LoopBegin(crdm_pract2_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_pract2_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_practice2.csv',
      seed: undefined, name: 'crdm_pract2_trials2'
    });
    psychoJS.experiment.addLoop(crdm_pract2_trials2); // add the loop to the experiment
    currentLoop = crdm_pract2_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_pract2_trials2 of crdm_pract2_trials2) {
      snapshot = crdm_pract2_trials2.getSnapshot();
      crdm_pract2_trials2LoopScheduler.add(importConditions(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_trialRoutineBegin(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_trialRoutineEachFrame());
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_trialRoutineEnd(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_feedbackRoutineBegin(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_feedbackRoutineEachFrame());
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_feedbackRoutineEnd(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_confRoutineBegin(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_confRoutineEachFrame());
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_confRoutineEnd(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_iti2RoutineBegin(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_iti2RoutineEachFrame());
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_iti2RoutineEnd(snapshot));
      crdm_pract2_trials2LoopScheduler.add(crdm_pract2_trials2LoopEndIteration(crdm_pract2_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_pract2_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_pract2_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_pract2_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var crdm_trials2;
function crdm_trials2LoopBegin(crdm_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    crdm_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'crdm/crdm_gen_trials_idx.csv',
      seed: undefined, name: 'crdm_trials2'
    });
    psychoJS.experiment.addLoop(crdm_trials2); // add the loop to the experiment
    currentLoop = crdm_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCrdm_trials2 of crdm_trials2) {
      snapshot = crdm_trials2.getSnapshot();
      crdm_trials2LoopScheduler.add(importConditions(snapshot));
      crdm_trials2LoopScheduler.add(crdm_trialRoutineBegin(snapshot));
      crdm_trials2LoopScheduler.add(crdm_trialRoutineEachFrame());
      crdm_trials2LoopScheduler.add(crdm_trialRoutineEnd(snapshot));
      crdm_trials2LoopScheduler.add(crdm_feedbackRoutineBegin(snapshot));
      crdm_trials2LoopScheduler.add(crdm_feedbackRoutineEachFrame());
      crdm_trials2LoopScheduler.add(crdm_feedbackRoutineEnd(snapshot));
      crdm_trials2LoopScheduler.add(crdm_confRoutineBegin(snapshot));
      crdm_trials2LoopScheduler.add(crdm_confRoutineEachFrame());
      crdm_trials2LoopScheduler.add(crdm_confRoutineEnd(snapshot));
      crdm_trials2LoopScheduler.add(crdm_trials_iti2RoutineBegin(snapshot));
      crdm_trials2LoopScheduler.add(crdm_trials_iti2RoutineEachFrame());
      crdm_trials2LoopScheduler.add(crdm_trials_iti2RoutineEnd(snapshot));
      crdm_trials2LoopScheduler.add(crdm_trials2LoopEndIteration(crdm_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function crdm_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(crdm_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function crdm_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run5LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run5);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run5LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run6;
function should_run6LoopBegin(should_run6LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run6 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop6, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run6'
    });
    psychoJS.experiment.addLoop(should_run6); // add the loop to the experiment
    currentLoop = should_run6;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run6 of should_run6) {
      snapshot = should_run6.getSnapshot();
      should_run6LoopScheduler.add(importConditions(snapshot));
      should_run6LoopScheduler.add(cdd_namer2RoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_namer2RoutineEachFrame());
      should_run6LoopScheduler.add(cdd_namer2RoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_instr1RoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_instr1RoutineEachFrame());
      should_run6LoopScheduler.add(cdd_instr1RoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_instr2RoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_instr2RoutineEachFrame());
      should_run6LoopScheduler.add(cdd_instr2RoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_instr3RoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_instr3RoutineEachFrame());
      should_run6LoopScheduler.add(cdd_instr3RoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_warnRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_warnRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_warnRoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_pract1_instrRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_pract1_instrRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_pract1_instrRoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_pract1_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run6LoopScheduler.add(cdd_pract1_trials2LoopBegin(cdd_pract1_trials2LoopScheduler, snapshot));
      should_run6LoopScheduler.add(cdd_pract1_trials2LoopScheduler);
      should_run6LoopScheduler.add(cdd_pract1_trials2LoopEnd);
      should_run6LoopScheduler.add(cdd_qp_instrRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_qp_instrRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_qp_instrRoutineEnd(snapshot));
      const cdd_qp_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run6LoopScheduler.add(cdd_qp_trials2LoopBegin(cdd_qp_trials2LoopScheduler, snapshot));
      should_run6LoopScheduler.add(cdd_qp_trials2LoopScheduler);
      should_run6LoopScheduler.add(cdd_qp_trials2LoopEnd);
      should_run6LoopScheduler.add(cdd_schedule_genRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_schedule_genRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_schedule_genRoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_pract2_instrRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_pract2_instrRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_pract2_instrRoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_pract2_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run6LoopScheduler.add(cdd_pract2_trials2LoopBegin(cdd_pract2_trials2LoopScheduler, snapshot));
      should_run6LoopScheduler.add(cdd_pract2_trials2LoopScheduler);
      should_run6LoopScheduler.add(cdd_pract2_trials2LoopEnd);
      should_run6LoopScheduler.add(cdd_trial_instrRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_trial_instrRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_trial_instrRoutineEnd(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_init_fixRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_init_fixRoutineEnd(snapshot));
      const cdd_trials2LoopScheduler = new Scheduler(psychoJS);
      should_run6LoopScheduler.add(cdd_trials2LoopBegin(cdd_trials2LoopScheduler, snapshot));
      should_run6LoopScheduler.add(cdd_trials2LoopScheduler);
      should_run6LoopScheduler.add(cdd_trials2LoopEnd);
      should_run6LoopScheduler.add(cdd_endRoutineBegin(snapshot));
      should_run6LoopScheduler.add(cdd_endRoutineEachFrame());
      should_run6LoopScheduler.add(cdd_endRoutineEnd(snapshot));
      should_run6LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      should_run6LoopScheduler.add(idm_term_checkRoutineEachFrame());
      should_run6LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      should_run6LoopScheduler.add(should_run6LoopEndIteration(should_run6LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract1_trials2;
function cdd_pract1_trials2LoopBegin(cdd_pract1_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_pract1_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_practice1.csv',
      seed: undefined, name: 'cdd_pract1_trials2'
    });
    psychoJS.experiment.addLoop(cdd_pract1_trials2); // add the loop to the experiment
    currentLoop = cdd_pract1_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_pract1_trials2 of cdd_pract1_trials2) {
      snapshot = cdd_pract1_trials2.getSnapshot();
      cdd_pract1_trials2LoopScheduler.add(importConditions(snapshot));
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_trialRoutineBegin(snapshot));
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_trialRoutineEachFrame());
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_trialRoutineEnd(snapshot));
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_feedbackRoutineBegin(snapshot));
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_feedbackRoutineEachFrame());
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_feedbackRoutineEnd(snapshot));
      cdd_pract1_trials2LoopScheduler.add(cdd_pract1_trials2LoopEndIteration(cdd_pract1_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_pract1_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_pract1_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_pract1_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_qp_trials2;
function cdd_qp_trials2LoopBegin(cdd_qp_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_qp_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_qp_trials.csv',
      seed: undefined, name: 'cdd_qp_trials2'
    });
    psychoJS.experiment.addLoop(cdd_qp_trials2); // add the loop to the experiment
    currentLoop = cdd_qp_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_qp_trials2 of cdd_qp_trials2) {
      snapshot = cdd_qp_trials2.getSnapshot();
      cdd_qp_trials2LoopScheduler.add(importConditions(snapshot));
      cdd_qp_trials2LoopScheduler.add(cdd_questplusRoutineBegin(snapshot));
      cdd_qp_trials2LoopScheduler.add(cdd_questplusRoutineEachFrame());
      cdd_qp_trials2LoopScheduler.add(cdd_questplusRoutineEnd(snapshot));
      cdd_qp_trials2LoopScheduler.add(cdd_questplus_fbRoutineBegin(snapshot));
      cdd_qp_trials2LoopScheduler.add(cdd_questplus_fbRoutineEachFrame());
      cdd_qp_trials2LoopScheduler.add(cdd_questplus_fbRoutineEnd(snapshot));
      cdd_qp_trials2LoopScheduler.add(cdd_qp_trials2LoopEndIteration(cdd_qp_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_qp_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_qp_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_qp_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_pract2_trials2;
function cdd_pract2_trials2LoopBegin(cdd_pract2_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_pract2_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_practice2.csv',
      seed: undefined, name: 'cdd_pract2_trials2'
    });
    psychoJS.experiment.addLoop(cdd_pract2_trials2); // add the loop to the experiment
    currentLoop = cdd_pract2_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_pract2_trials2 of cdd_pract2_trials2) {
      snapshot = cdd_pract2_trials2.getSnapshot();
      cdd_pract2_trials2LoopScheduler.add(importConditions(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_trialRoutineBegin(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_trialRoutineEachFrame());
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_trialRoutineEnd(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_feedbackRoutineBegin(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_feedbackRoutineEachFrame());
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_feedbackRoutineEnd(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_confRoutineBegin(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_confRoutineEachFrame());
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_confRoutineEnd(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_iti2RoutineBegin(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_iti2RoutineEachFrame());
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_iti2RoutineEnd(snapshot));
      cdd_pract2_trials2LoopScheduler.add(cdd_pract2_trials2LoopEndIteration(cdd_pract2_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_pract2_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_pract2_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_pract2_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var cdd_trials2;
function cdd_trials2LoopBegin(cdd_trials2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cdd_trials2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cdd/cdd_gen_trials_idx.csv',
      seed: undefined, name: 'cdd_trials2'
    });
    psychoJS.experiment.addLoop(cdd_trials2); // add the loop to the experiment
    currentLoop = cdd_trials2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCdd_trials2 of cdd_trials2) {
      snapshot = cdd_trials2.getSnapshot();
      cdd_trials2LoopScheduler.add(importConditions(snapshot));
      cdd_trials2LoopScheduler.add(cdd_trialRoutineBegin(snapshot));
      cdd_trials2LoopScheduler.add(cdd_trialRoutineEachFrame());
      cdd_trials2LoopScheduler.add(cdd_trialRoutineEnd(snapshot));
      cdd_trials2LoopScheduler.add(cdd_feedbackRoutineBegin(snapshot));
      cdd_trials2LoopScheduler.add(cdd_feedbackRoutineEachFrame());
      cdd_trials2LoopScheduler.add(cdd_feedbackRoutineEnd(snapshot));
      cdd_trials2LoopScheduler.add(cdd_confRoutineBegin(snapshot));
      cdd_trials2LoopScheduler.add(cdd_confRoutineEachFrame());
      cdd_trials2LoopScheduler.add(cdd_confRoutineEnd(snapshot));
      cdd_trials2LoopScheduler.add(cdd_trial_iti2RoutineBegin(snapshot));
      cdd_trials2LoopScheduler.add(cdd_trial_iti2RoutineEachFrame());
      cdd_trials2LoopScheduler.add(cdd_trial_iti2RoutineEnd(snapshot));
      cdd_trials2LoopScheduler.add(cdd_trials2LoopEndIteration(cdd_trials2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cdd_trials2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cdd_trials2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cdd_trials2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run6LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run6);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run6LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var should_run7;
function should_run7LoopBegin(should_run7LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    should_run7 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: loop7, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'should_run7'
    });
    psychoJS.experiment.addLoop(should_run7); // add the loop to the experiment
    currentLoop = should_run7;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisShould_run7 of should_run7) {
      snapshot = should_run7.getSnapshot();
      should_run7LoopScheduler.add(importConditions(snapshot));
      should_run7LoopScheduler.add(cpdm_namer3RoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_namer3RoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_namer3RoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_instr1RoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_instr1RoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_instr1RoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_instr2RoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_instr2RoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_instr2RoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_instr3RoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_instr3RoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_instr3RoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_instr4RoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_instr4RoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_instr4RoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_warnRoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_warnRoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_warnRoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_pract_instrRoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_pract_instrRoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_pract_instrRoutineEnd(snapshot));
      should_run7LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_pract_trials3LoopScheduler = new Scheduler(psychoJS);
      should_run7LoopScheduler.add(cpdm_pract_trials3LoopBegin(cpdm_pract_trials3LoopScheduler, snapshot));
      should_run7LoopScheduler.add(cpdm_pract_trials3LoopScheduler);
      should_run7LoopScheduler.add(cpdm_pract_trials3LoopEnd);
      should_run7LoopScheduler.add(cpdm_trial_instrRoutineBegin(snapshot));
      should_run7LoopScheduler.add(cpdm_trial_instrRoutineEachFrame());
      should_run7LoopScheduler.add(cpdm_trial_instrRoutineEnd(snapshot));
      const condition_runs3LoopScheduler = new Scheduler(psychoJS);
      should_run7LoopScheduler.add(condition_runs3LoopBegin(condition_runs3LoopScheduler, snapshot));
      should_run7LoopScheduler.add(condition_runs3LoopScheduler);
      should_run7LoopScheduler.add(condition_runs3LoopEnd);
      should_run7LoopScheduler.add(should_run7LoopEndIteration(should_run7LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_trials3;
function cpdm_pract_trials3LoopBegin(cpdm_pract_trials3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_pract_trials3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_practice.xlsx',
      seed: undefined, name: 'cpdm_pract_trials3'
    });
    psychoJS.experiment.addLoop(cpdm_pract_trials3); // add the loop to the experiment
    currentLoop = cpdm_pract_trials3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_pract_trials3 of cpdm_pract_trials3) {
      snapshot = cpdm_pract_trials3.getSnapshot();
      cpdm_pract_trials3LoopScheduler.add(importConditions(snapshot));
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_trialRoutineBegin(snapshot));
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_trialRoutineEachFrame());
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_trialRoutineEnd(snapshot));
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_iti3RoutineBegin(snapshot));
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_iti3RoutineEachFrame());
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_iti3RoutineEnd(snapshot));
      cpdm_pract_trials3LoopScheduler.add(cpdm_pract_trials3LoopEndIteration(cpdm_pract_trials3LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_pract_trials3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_pract_trials3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_pract_trials3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var condition_runs3;
function condition_runs3LoopBegin(condition_runs3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    condition_runs3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm_run_type.xlsx',
      seed: undefined, name: 'condition_runs3'
    });
    psychoJS.experiment.addLoop(condition_runs3); // add the loop to the experiment
    currentLoop = condition_runs3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCondition_runs3 of condition_runs3) {
      snapshot = condition_runs3.getSnapshot();
      condition_runs3LoopScheduler.add(importConditions(snapshot));
      condition_runs3LoopScheduler.add(cpdm_run_setterRoutineBegin(snapshot));
      condition_runs3LoopScheduler.add(cpdm_run_setterRoutineEachFrame());
      condition_runs3LoopScheduler.add(cpdm_run_setterRoutineEnd(snapshot));
      condition_runs3LoopScheduler.add(cpdm_loop_instrRoutineBegin(snapshot));
      condition_runs3LoopScheduler.add(cpdm_loop_instrRoutineEachFrame());
      condition_runs3LoopScheduler.add(cpdm_loop_instrRoutineEnd(snapshot));
      condition_runs3LoopScheduler.add(cpdm_init_fixRoutineBegin(snapshot));
      condition_runs3LoopScheduler.add(cpdm_init_fixRoutineEachFrame());
      condition_runs3LoopScheduler.add(cpdm_init_fixRoutineEnd(snapshot));
      const cpdm_trials3LoopScheduler = new Scheduler(psychoJS);
      condition_runs3LoopScheduler.add(cpdm_trials3LoopBegin(cpdm_trials3LoopScheduler, snapshot));
      condition_runs3LoopScheduler.add(cpdm_trials3LoopScheduler);
      condition_runs3LoopScheduler.add(cpdm_trials3LoopEnd);
      condition_runs3LoopScheduler.add(cpdm_run_break3RoutineBegin(snapshot));
      condition_runs3LoopScheduler.add(cpdm_run_break3RoutineEachFrame());
      condition_runs3LoopScheduler.add(cpdm_run_break3RoutineEnd(snapshot));
      condition_runs3LoopScheduler.add(idm_term_checkRoutineBegin(snapshot));
      condition_runs3LoopScheduler.add(idm_term_checkRoutineEachFrame());
      condition_runs3LoopScheduler.add(idm_term_checkRoutineEnd(snapshot));
      condition_runs3LoopScheduler.add(condition_runs3LoopEndIteration(condition_runs3LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


var cpdm_trials3;
function cpdm_trials3LoopBegin(cpdm_trials3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    cpdm_trials3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'cpdm/cpdm-1contrast.xlsx',
      seed: undefined, name: 'cpdm_trials3'
    });
    psychoJS.experiment.addLoop(cpdm_trials3); // add the loop to the experiment
    currentLoop = cpdm_trials3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisCpdm_trials3 of cpdm_trials3) {
      snapshot = cpdm_trials3.getSnapshot();
      cpdm_trials3LoopScheduler.add(importConditions(snapshot));
      cpdm_trials3LoopScheduler.add(cpdm_trialRoutineBegin(snapshot));
      cpdm_trials3LoopScheduler.add(cpdm_trialRoutineEachFrame());
      cpdm_trials3LoopScheduler.add(cpdm_trialRoutineEnd(snapshot));
      cpdm_trials3LoopScheduler.add(cpdm_trials_iti3RoutineBegin(snapshot));
      cpdm_trials3LoopScheduler.add(cpdm_trials_iti3RoutineEachFrame());
      cpdm_trials3LoopScheduler.add(cpdm_trials_iti3RoutineEnd(snapshot));
      cpdm_trials3LoopScheduler.add(cpdm_trials3LoopEndIteration(cpdm_trials3LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}


async function cpdm_trials3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(cpdm_trials3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function cpdm_trials3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function condition_runs3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(condition_runs3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function condition_runs3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function should_run7LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(should_run7);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function should_run7LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var survbox1_color;
var survbox2_color;
var survbox3_color;
var survbox4_color;
var survbox5_color;
var survbox6_color;
var font_color1;
var font_color2;
var font_color3;
var font_color4;
var font_color5;
var font_color6;
var resp1_txt;
var resp2_txt;
var resp3_txt;
var resp4_txt;
var resp5_txt;
var resp6_txt;
var surv_keylist;
var _idm_surv1_resp_allKeys;
var idm_surv1Components;
function idm_surv1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_surv1' ---
    t = 0;
    idm_surv1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_surv1.started', globalClock.getTime());
    // Run 'Begin Routine' code from idm_surv1_code
    survbox1_color = [0, 0, 0];
    survbox2_color = [0, 0, 0];
    survbox3_color = [0, 0, 0];
    survbox4_color = [0, 0, 0];
    survbox5_color = [0, 0, 0];
    survbox6_color = [0, 0, 0];
    font_color1 = [0, 0, 0];
    font_color2 = [0, 0, 0];
    font_color3 = [0, 0, 0];
    font_color4 = [0, 0, 0];
    font_color5 = [0, 0, 0];
    font_color6 = [0, 0, 0];
    resp1_txt = "";
    resp2_txt = "";
    resp3_txt = "";
    resp4_txt = "";
    resp5_txt = "";
    resp6_txt = "";
    if ((resps === 2)) {
        surv_keylist = ["1", "2"];
        survbox1_color = "white";
        survbox2_color = "white";
        font_color1 = "white";
        font_color2 = "white";
        resp1_txt = resp1;
        resp2_txt = resp2;
    } else {
        if ((resps === 3)) {
            surv_keylist = ["1", "2", "3"];
            survbox1_color = "white";
            survbox2_color = "white";
            survbox3_color = "white";
            font_color1 = "white";
            font_color2 = "white";
            font_color3 = "white";
            resp1_txt = resp1;
            resp2_txt = resp2;
            resp3_txt = resp3;
        } else {
            if ((resps === 4)) {
                surv_keylist = ["1", "2", "3", "4"];
                survbox1_color = "white";
                survbox2_color = "white";
                survbox3_color = "white";
                survbox4_color = "white";
                font_color1 = "white";
                font_color2 = "white";
                font_color3 = "white";
                font_color4 = "white";
                resp1_txt = resp1;
                resp2_txt = resp2;
                resp3_txt = resp3;
                resp4_txt = resp4;
            } else {
                if ((resps === 5)) {
                    surv_keylist = ["1", "2", "3", "4", "5"];
                    survbox1_color = "white";
                    survbox2_color = "white";
                    survbox3_color = "white";
                    survbox4_color = "white";
                    survbox5_color = "white";
                    font_color1 = "white";
                    font_color2 = "white";
                    font_color3 = "white";
                    font_color4 = "white";
                    font_color5 = "white";
                    resp1_txt = resp1;
                    resp2_txt = resp2;
                    resp3_txt = resp3;
                    resp4_txt = resp4;
                    resp5_txt = resp5;
                } else {
                    if ((resps === 6)) {
                        surv_keylist = ["1", "2", "3", "4", "5", "6"];
                        survbox1_color = "white";
                        survbox2_color = "white";
                        survbox3_color = "white";
                        survbox4_color = "white";
                        survbox5_color = "white";
                        survbox6_color = "white";
                        font_color1 = "white";
                        font_color2 = "white";
                        font_color3 = "white";
                        font_color4 = "white";
                        font_color5 = "white";
                        font_color6 = "white";
                        resp1_txt = resp1;
                        resp2_txt = resp2;
                        resp3_txt = resp3;
                        resp4_txt = resp4;
                        resp5_txt = resp5;
                        resp6_txt = resp6;
                    }
                }
            }
        }
    }
    
    idm_surv1_question_txt.setText(question);
    idm_surv1_1.setLineColor(new util.Color(survbox1_color));
    idm_surv1_1_txt.setText(resp1_txt);
    idm_surv1_2.setLineColor(new util.Color(survbox2_color));
    idm_surv1_2_txt.setText(resp2_txt);
    idm_surv1_3.setLineColor(new util.Color(survbox3_color));
    idm_surv1_3_txt.setText(resp3_txt);
    idm_surv1_4.setLineColor(new util.Color(survbox4_color));
    idm_surv1_4_txt.setText(resp4_txt);
    idm_surv1_5.setLineColor(new util.Color(survbox5_color));
    idm_surv1_5_txt.setText(resp5_txt);
    idm_surv1_6.setLineColor(new util.Color(survbox6_color));
    idm_surv1_6_txt.setText(resp6_txt);
    idm_surv1_key1.setColor(new util.Color(font_color1));
    idm_surv1_key2.setColor(new util.Color(font_color2));
    idm_surv1_key3.setColor(new util.Color(font_color3));
    idm_surv1_key4.setColor(new util.Color(font_color4));
    idm_surv1_key5.setColor(new util.Color(font_color5));
    idm_surv1_key6.setColor(new util.Color(font_color6));
    idm_surv1_resp.keys = undefined;
    idm_surv1_resp.rt = undefined;
    _idm_surv1_resp_allKeys = [];
    // keep track of which components have finished
    idm_surv1Components = [];
    idm_surv1Components.push(idm_surv1_question_txt);
    idm_surv1Components.push(idm_surv1_1);
    idm_surv1Components.push(idm_surv1_1_txt);
    idm_surv1Components.push(idm_surv1_2);
    idm_surv1Components.push(idm_surv1_2_txt);
    idm_surv1Components.push(idm_surv1_3);
    idm_surv1Components.push(idm_surv1_3_txt);
    idm_surv1Components.push(idm_surv1_4);
    idm_surv1Components.push(idm_surv1_4_txt);
    idm_surv1Components.push(idm_surv1_5);
    idm_surv1Components.push(idm_surv1_5_txt);
    idm_surv1Components.push(idm_surv1_6);
    idm_surv1Components.push(idm_surv1_6_txt);
    idm_surv1Components.push(idm_surv1_key1);
    idm_surv1Components.push(idm_surv1_key2);
    idm_surv1Components.push(idm_surv1_key3);
    idm_surv1Components.push(idm_surv1_key4);
    idm_surv1Components.push(idm_surv1_key5);
    idm_surv1Components.push(idm_surv1_key6);
    idm_surv1Components.push(idm_surv1_resp);
    
    for (const thisComponent of idm_surv1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


var key;
function idm_surv1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_surv1' ---
    // get current time
    t = idm_surv1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from idm_surv1_code
    key = idm_surv1_resp.keys;
    if ((resps === 2)) {
        if (((key === "1") || (key === "2"))) {
            continueRoutine = false;
        }
    } else {
        if ((resps === 3)) {
            if ((((key === "1") || (key === "2")) || (key === "3"))) {
                continueRoutine = false;
            }
        } else {
            if ((resps === 4)) {
                if (((((key === "1") || (key === "2")) || (key === "3")) || (key === "4"))) {
                    continueRoutine = false;
                }
            } else {
                if ((resps === 5)) {
                    if ((((((key === "1") || (key === "2")) || (key === "3")) || (key === "4")) || (key === "5"))) {
                        continueRoutine = false;
                    }
                } else {
                    if ((resps === 6)) {
                        if (((((((key === "1") || (key === "2")) || (key === "3")) || (key === "4")) || (key === "5")) || (key === "6"))) {
                            continueRoutine = false;
                        }
                    }
                }
            }
        }
    }
    
    
    // *idm_surv1_question_txt* updates
    if (t >= 0.0 && idm_surv1_question_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_question_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_question_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_question_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_1* updates
    if (t >= 0.0 && idm_surv1_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_1.tStart = t;  // (not accounting for frame time here)
      idm_surv1_1.frameNStart = frameN;  // exact frame index
      
      idm_surv1_1.setAutoDraw(true);
    }
    
    
    // *idm_surv1_1_txt* updates
    if (t >= 0.0 && idm_surv1_1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_1_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_1_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_1_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_2* updates
    if (t >= 0.0 && idm_surv1_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_2.tStart = t;  // (not accounting for frame time here)
      idm_surv1_2.frameNStart = frameN;  // exact frame index
      
      idm_surv1_2.setAutoDraw(true);
    }
    
    
    // *idm_surv1_2_txt* updates
    if (t >= 0.0 && idm_surv1_2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_2_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_2_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_2_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_3* updates
    if (t >= 0.0 && idm_surv1_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_3.tStart = t;  // (not accounting for frame time here)
      idm_surv1_3.frameNStart = frameN;  // exact frame index
      
      idm_surv1_3.setAutoDraw(true);
    }
    
    
    // *idm_surv1_3_txt* updates
    if (t >= 0.0 && idm_surv1_3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_3_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_3_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_3_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_4* updates
    if (t >= 0.0 && idm_surv1_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_4.tStart = t;  // (not accounting for frame time here)
      idm_surv1_4.frameNStart = frameN;  // exact frame index
      
      idm_surv1_4.setAutoDraw(true);
    }
    
    
    // *idm_surv1_4_txt* updates
    if (t >= 0.0 && idm_surv1_4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_4_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_4_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_4_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_5* updates
    if (t >= 0.0 && idm_surv1_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_5.tStart = t;  // (not accounting for frame time here)
      idm_surv1_5.frameNStart = frameN;  // exact frame index
      
      idm_surv1_5.setAutoDraw(true);
    }
    
    
    // *idm_surv1_5_txt* updates
    if (t >= 0.0 && idm_surv1_5_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_5_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_5_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_5_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_6* updates
    if (t >= 0.0 && idm_surv1_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_6.tStart = t;  // (not accounting for frame time here)
      idm_surv1_6.frameNStart = frameN;  // exact frame index
      
      idm_surv1_6.setAutoDraw(true);
    }
    
    
    // *idm_surv1_6_txt* updates
    if (t >= 0.0 && idm_surv1_6_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_6_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv1_6_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv1_6_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key1* updates
    if (t >= 0.0 && idm_surv1_key1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key1.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key1.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key1.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key2* updates
    if (t >= 0.0 && idm_surv1_key2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key2.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key2.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key2.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key3* updates
    if (t >= 0.0 && idm_surv1_key3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key3.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key3.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key3.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key4* updates
    if (t >= 0.0 && idm_surv1_key4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key4.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key4.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key4.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key5* updates
    if (t >= 0.0 && idm_surv1_key5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key5.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key5.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key5.setAutoDraw(true);
    }
    
    
    // *idm_surv1_key6* updates
    if (t >= 0.0 && idm_surv1_key6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_key6.tStart = t;  // (not accounting for frame time here)
      idm_surv1_key6.frameNStart = frameN;  // exact frame index
      
      idm_surv1_key6.setAutoDraw(true);
    }
    
    
    // *idm_surv1_resp* updates
    if (t >= 0.0 && idm_surv1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv1_resp.tStart = t;  // (not accounting for frame time here)
      idm_surv1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_surv1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_surv1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_surv1_resp.clearEvents(); });
    }
    
    if (idm_surv1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_surv1_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6'], waitRelease: false});
      _idm_surv1_resp_allKeys = _idm_surv1_resp_allKeys.concat(theseKeys);
      if (_idm_surv1_resp_allKeys.length > 0) {
        idm_surv1_resp.keys = _idm_surv1_resp_allKeys[_idm_surv1_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_surv1_resp.rt = _idm_surv1_resp_allKeys[_idm_surv1_resp_allKeys.length - 1].rt;
        idm_surv1_resp.duration = _idm_surv1_resp_allKeys[_idm_surv1_resp_allKeys.length - 1].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_surv1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var surv_key;
function idm_surv1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_surv1' ---
    for (const thisComponent of idm_surv1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_surv1.stopped', globalClock.getTime());
    // Run 'End Routine' code from idm_surv1_code
    surv_key = idm_surv1_resp.keys;
    if ((surv_key === "1")) {
        survey1.addData("surv1_resp", resp1);
    } else {
        if ((surv_key === "2")) {
            survey1.addData("surv1_resp", resp2);
        } else {
            if ((surv_key === "3")) {
                survey1.addData("surv1_resp", resp3);
            } else {
                if ((surv_key === "4")) {
                    survey1.addData("surv1_resp", resp4);
                } else {
                    if ((surv_key === "5")) {
                        survey1.addData("surv1_resp", resp5);
                    } else {
                        if ((surv_key === "6")) {
                            survey1.addData("surv1_resp", resp6);
                        }
                    }
                }
            }
        }
    }
    
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(idm_surv1_resp.corr, level);
    }
    psychoJS.experiment.addData('idm_surv1_resp.keys', idm_surv1_resp.keys);
    if (typeof idm_surv1_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('idm_surv1_resp.rt', idm_surv1_resp.rt);
        psychoJS.experiment.addData('idm_surv1_resp.duration', idm_surv1_resp.duration);
        }
    
    idm_surv1_resp.stop();
    // the Routine "idm_surv1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_surv2_intro_resp_allKeys;
var idm_surv2_introComponents;
function idm_surv2_introRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_surv2_intro' ---
    t = 0;
    idm_surv2_introClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_surv2_intro.started', globalClock.getTime());
    idm_surv2_intro_resp.keys = undefined;
    idm_surv2_intro_resp.rt = undefined;
    _idm_surv2_intro_resp_allKeys = [];
    // keep track of which components have finished
    idm_surv2_introComponents = [];
    idm_surv2_introComponents.push(idm_surv2_intro_title_txt);
    idm_surv2_introComponents.push(idm_surv2_intro_txt);
    idm_surv2_introComponents.push(idm_surv2_intro_space_txt);
    idm_surv2_introComponents.push(idm_surv2_intro_resp);
    
    for (const thisComponent of idm_surv2_introComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_surv2_introRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_surv2_intro' ---
    // get current time
    t = idm_surv2_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_surv2_intro_title_txt* updates
    if (t >= 0.0 && idm_surv2_intro_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_intro_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_intro_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_intro_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_intro_txt* updates
    if (t >= 0.0 && idm_surv2_intro_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_intro_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_intro_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_intro_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_intro_space_txt* updates
    if (t >= 0.0 && idm_surv2_intro_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_intro_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_intro_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_intro_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_intro_resp* updates
    if (t >= 0.0 && idm_surv2_intro_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_intro_resp.tStart = t;  // (not accounting for frame time here)
      idm_surv2_intro_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_surv2_intro_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_surv2_intro_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_surv2_intro_resp.clearEvents(); });
    }
    
    if (idm_surv2_intro_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_surv2_intro_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_surv2_intro_resp_allKeys = _idm_surv2_intro_resp_allKeys.concat(theseKeys);
      if (_idm_surv2_intro_resp_allKeys.length > 0) {
        idm_surv2_intro_resp.keys = _idm_surv2_intro_resp_allKeys[_idm_surv2_intro_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_surv2_intro_resp.rt = _idm_surv2_intro_resp_allKeys[_idm_surv2_intro_resp_allKeys.length - 1].rt;
        idm_surv2_intro_resp.duration = _idm_surv2_intro_resp_allKeys[_idm_surv2_intro_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_surv2_introComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_surv2_introRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_surv2_intro' ---
    for (const thisComponent of idm_surv2_introComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_surv2_intro.stopped', globalClock.getTime());
    idm_surv2_intro_resp.stop();
    // the Routine "idm_surv2_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_surv2_resp_allKeys;
var idm_surv2Components;
function idm_surv2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_surv2' ---
    t = 0;
    idm_surv2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_surv2.started', globalClock.getTime());
    idm_surv2_question_txt.setText(question);
    idm_surv2_resp.keys = undefined;
    idm_surv2_resp.rt = undefined;
    _idm_surv2_resp_allKeys = [];
    // keep track of which components have finished
    idm_surv2Components = [];
    idm_surv2Components.push(idm_surv2_stim_txt);
    idm_surv2Components.push(idm_surv2_question_txt);
    idm_surv2Components.push(idm_surv2_1);
    idm_surv2Components.push(idm_surv2_1_txt);
    idm_surv2Components.push(idm_surv2_2);
    idm_surv2Components.push(idm_surv2_2_txt);
    idm_surv2Components.push(idm_surv2_3);
    idm_surv2Components.push(idm_surv2_3_txt);
    idm_surv2Components.push(idm_surv2_4);
    idm_surv2Components.push(idm_surv2_4_txt);
    idm_surv2Components.push(idm_surv2_5);
    idm_surv2Components.push(idm_surv2_5_txt);
    idm_surv2Components.push(idm_surv2_key1);
    idm_surv2Components.push(idm_surv2_key2);
    idm_surv2Components.push(idm_surv2_key3);
    idm_surv2Components.push(idm_surv2_key4);
    idm_surv2Components.push(idm_surv2_key5);
    idm_surv2Components.push(idm_surv2_resp);
    
    for (const thisComponent of idm_surv2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_surv2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_surv2' ---
    // get current time
    t = idm_surv2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_surv2_stim_txt* updates
    if (t >= 0.0 && idm_surv2_stim_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_stim_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_stim_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_stim_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_question_txt* updates
    if (t >= 0.0 && idm_surv2_question_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_question_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_question_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_question_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_1* updates
    if (t >= 0.0 && idm_surv2_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_1.tStart = t;  // (not accounting for frame time here)
      idm_surv2_1.frameNStart = frameN;  // exact frame index
      
      idm_surv2_1.setAutoDraw(true);
    }
    
    
    // *idm_surv2_1_txt* updates
    if (t >= 0.0 && idm_surv2_1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_1_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_1_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_1_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_2* updates
    if (t >= 0.0 && idm_surv2_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_2.tStart = t;  // (not accounting for frame time here)
      idm_surv2_2.frameNStart = frameN;  // exact frame index
      
      idm_surv2_2.setAutoDraw(true);
    }
    
    
    // *idm_surv2_2_txt* updates
    if (t >= 0.0 && idm_surv2_2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_2_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_2_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_2_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_3* updates
    if (t >= 0.0 && idm_surv2_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_3.tStart = t;  // (not accounting for frame time here)
      idm_surv2_3.frameNStart = frameN;  // exact frame index
      
      idm_surv2_3.setAutoDraw(true);
    }
    
    
    // *idm_surv2_3_txt* updates
    if (t >= 0.0 && idm_surv2_3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_3_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_3_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_3_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_4* updates
    if (t >= 0.0 && idm_surv2_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_4.tStart = t;  // (not accounting for frame time here)
      idm_surv2_4.frameNStart = frameN;  // exact frame index
      
      idm_surv2_4.setAutoDraw(true);
    }
    
    
    // *idm_surv2_4_txt* updates
    if (t >= 0.0 && idm_surv2_4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_4_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_4_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_4_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_5* updates
    if (t >= 0.0 && idm_surv2_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_5.tStart = t;  // (not accounting for frame time here)
      idm_surv2_5.frameNStart = frameN;  // exact frame index
      
      idm_surv2_5.setAutoDraw(true);
    }
    
    
    // *idm_surv2_5_txt* updates
    if (t >= 0.0 && idm_surv2_5_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_5_txt.tStart = t;  // (not accounting for frame time here)
      idm_surv2_5_txt.frameNStart = frameN;  // exact frame index
      
      idm_surv2_5_txt.setAutoDraw(true);
    }
    
    
    // *idm_surv2_key1* updates
    if (t >= 0.0 && idm_surv2_key1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_key1.tStart = t;  // (not accounting for frame time here)
      idm_surv2_key1.frameNStart = frameN;  // exact frame index
      
      idm_surv2_key1.setAutoDraw(true);
    }
    
    
    // *idm_surv2_key2* updates
    if (t >= 0.0 && idm_surv2_key2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_key2.tStart = t;  // (not accounting for frame time here)
      idm_surv2_key2.frameNStart = frameN;  // exact frame index
      
      idm_surv2_key2.setAutoDraw(true);
    }
    
    
    // *idm_surv2_key3* updates
    if (t >= 0.0 && idm_surv2_key3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_key3.tStart = t;  // (not accounting for frame time here)
      idm_surv2_key3.frameNStart = frameN;  // exact frame index
      
      idm_surv2_key3.setAutoDraw(true);
    }
    
    
    // *idm_surv2_key4* updates
    if (t >= 0.0 && idm_surv2_key4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_key4.tStart = t;  // (not accounting for frame time here)
      idm_surv2_key4.frameNStart = frameN;  // exact frame index
      
      idm_surv2_key4.setAutoDraw(true);
    }
    
    
    // *idm_surv2_key5* updates
    if (t >= 0.0 && idm_surv2_key5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_key5.tStart = t;  // (not accounting for frame time here)
      idm_surv2_key5.frameNStart = frameN;  // exact frame index
      
      idm_surv2_key5.setAutoDraw(true);
    }
    
    
    // *idm_surv2_resp* updates
    if (t >= 0.0 && idm_surv2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_surv2_resp.tStart = t;  // (not accounting for frame time here)
      idm_surv2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_surv2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_surv2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_surv2_resp.clearEvents(); });
    }
    
    if (idm_surv2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_surv2_resp.getKeys({keyList: ['1', '2', '3', '4', '5'], waitRelease: false});
      _idm_surv2_resp_allKeys = _idm_surv2_resp_allKeys.concat(theseKeys);
      if (_idm_surv2_resp_allKeys.length > 0) {
        idm_surv2_resp.keys = _idm_surv2_resp_allKeys[_idm_surv2_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_surv2_resp.rt = _idm_surv2_resp_allKeys[_idm_surv2_resp_allKeys.length - 1].rt;
        idm_surv2_resp.duration = _idm_surv2_resp_allKeys[_idm_surv2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_surv2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_surv2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_surv2' ---
    for (const thisComponent of idm_surv2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_surv2.stopped', globalClock.getTime());
    // Run 'End Routine' code from idm_surv2_code_2
    surv_key = idm_surv2_resp.keys;
    if ((surv_key === "1")) {
        survey2.addData("surv2_resp", resp1);
    } else {
        if ((surv_key === "2")) {
            survey2.addData("surv2_resp", resp2);
        } else {
            if ((surv_key === "3")) {
                survey2.addData("surv2_resp", resp3);
            } else {
                if ((surv_key === "4")) {
                    survey2.addData("surv2_resp", resp4);
                } else {
                    if ((surv_key === "5")) {
                        survey2.addData("surv2_resp", resp5);
                    }
                }
            }
        }
    }
    
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(idm_surv2_resp.corr, level);
    }
    psychoJS.experiment.addData('idm_surv2_resp.keys', idm_surv2_resp.keys);
    if (typeof idm_surv2_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('idm_surv2_resp.rt', idm_surv2_resp.rt);
        psychoJS.experiment.addData('idm_surv2_resp.duration', idm_surv2_resp.duration);
        routineTimer.reset();
        }
    
    idm_surv2_resp.stop();
    // the Routine "idm_surv2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_instr1_resp_allKeys;
var idm_instr1Components;
function idm_instr1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_instr1' ---
    t = 0;
    idm_instr1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_instr1.started', globalClock.getTime());
    idm_instr1_resp.keys = undefined;
    idm_instr1_resp.rt = undefined;
    _idm_instr1_resp_allKeys = [];
    // keep track of which components have finished
    idm_instr1Components = [];
    idm_instr1Components.push(idm_instr1_title_txt);
    idm_instr1Components.push(idm_instr1_txt);
    idm_instr1Components.push(idm_instr1_space_txt);
    idm_instr1Components.push(idm_instr1_resp);
    
    for (const thisComponent of idm_instr1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_instr1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_instr1' ---
    // get current time
    t = idm_instr1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_instr1_title_txt* updates
    if (t >= 0.0 && idm_instr1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr1_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr1_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr1_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr1_txt* updates
    if (t >= 0.0 && idm_instr1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr1_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr1_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr1_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr1_space_txt* updates
    if (t >= 0.0 && idm_instr1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr1_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr1_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr1_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr1_resp* updates
    if (t >= 0.0 && idm_instr1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr1_resp.tStart = t;  // (not accounting for frame time here)
      idm_instr1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_instr1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_instr1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_instr1_resp.clearEvents(); });
    }
    
    if (idm_instr1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_instr1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_instr1_resp_allKeys = _idm_instr1_resp_allKeys.concat(theseKeys);
      if (_idm_instr1_resp_allKeys.length > 0) {
        idm_instr1_resp.keys = _idm_instr1_resp_allKeys[_idm_instr1_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_instr1_resp.rt = _idm_instr1_resp_allKeys[_idm_instr1_resp_allKeys.length - 1].rt;
        idm_instr1_resp.duration = _idm_instr1_resp_allKeys[_idm_instr1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_instr1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_instr1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_instr1' ---
    for (const thisComponent of idm_instr1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_instr1.stopped', globalClock.getTime());
    idm_instr1_resp.stop();
    // the Routine "idm_instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_instr2_resp_allKeys;
var idm_instr2Components;
function idm_instr2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_instr2' ---
    t = 0;
    idm_instr2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_instr2.started', globalClock.getTime());
    idm_instr2_resp.keys = undefined;
    idm_instr2_resp.rt = undefined;
    _idm_instr2_resp_allKeys = [];
    // keep track of which components have finished
    idm_instr2Components = [];
    idm_instr2Components.push(idm_instr2_title_txt);
    idm_instr2Components.push(idm_instr2_cursor_txt);
    idm_instr2Components.push(idm_instr2_space_txt);
    idm_instr2Components.push(idm_instr2_resp);
    
    for (const thisComponent of idm_instr2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_instr2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_instr2' ---
    // get current time
    t = idm_instr2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_instr2_title_txt* updates
    if (t >= 0.0 && idm_instr2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr2_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr2_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr2_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr2_cursor_txt* updates
    if (t >= 0.0 && idm_instr2_cursor_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr2_cursor_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr2_cursor_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr2_cursor_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr2_space_txt* updates
    if (t >= 0.0 && idm_instr2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr2_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_instr2_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_instr2_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_instr2_resp* updates
    if (t >= 0.0 && idm_instr2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_instr2_resp.tStart = t;  // (not accounting for frame time here)
      idm_instr2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_instr2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_instr2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_instr2_resp.clearEvents(); });
    }
    
    if (idm_instr2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_instr2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_instr2_resp_allKeys = _idm_instr2_resp_allKeys.concat(theseKeys);
      if (_idm_instr2_resp_allKeys.length > 0) {
        idm_instr2_resp.keys = _idm_instr2_resp_allKeys[_idm_instr2_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_instr2_resp.rt = _idm_instr2_resp_allKeys[_idm_instr2_resp_allKeys.length - 1].rt;
        idm_instr2_resp.duration = _idm_instr2_resp_allKeys[_idm_instr2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_instr2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_instr2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_instr2' ---
    for (const thisComponent of idm_instr2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_instr2.stopped', globalClock.getTime());
    idm_instr2_resp.stop();
    // the Routine "idm_instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_warn2_resp_allKeys;
var idm_warn2Components;
function idm_warn2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_warn2' ---
    t = 0;
    idm_warn2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_warn2.started', globalClock.getTime());
    idm_warn2_resp.keys = undefined;
    idm_warn2_resp.rt = undefined;
    _idm_warn2_resp_allKeys = [];
    // keep track of which components have finished
    idm_warn2Components = [];
    idm_warn2Components.push(idm_warn2_title_txt);
    idm_warn2Components.push(idm_warn2_warning_txt);
    idm_warn2Components.push(idm_warn2_space_txt);
    idm_warn2Components.push(idm_warn2_resp);
    
    for (const thisComponent of idm_warn2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_warn2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_warn2' ---
    // get current time
    t = idm_warn2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_warn2_title_txt* updates
    if (t >= 0.0 && idm_warn2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn2_title_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn2_title_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn2_title_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn2_warning_txt* updates
    if (t >= 0.0 && idm_warn2_warning_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn2_warning_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn2_warning_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn2_warning_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn2_space_txt* updates
    if (t >= 0.0 && idm_warn2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn2_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_warn2_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_warn2_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_warn2_resp* updates
    if (t >= 0.0 && idm_warn2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_warn2_resp.tStart = t;  // (not accounting for frame time here)
      idm_warn2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_warn2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_warn2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_warn2_resp.clearEvents(); });
    }
    
    if (idm_warn2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_warn2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_warn2_resp_allKeys = _idm_warn2_resp_allKeys.concat(theseKeys);
      if (_idm_warn2_resp_allKeys.length > 0) {
        idm_warn2_resp.keys = _idm_warn2_resp_allKeys[_idm_warn2_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_warn2_resp.rt = _idm_warn2_resp_allKeys[_idm_warn2_resp_allKeys.length - 1].rt;
        idm_warn2_resp.duration = _idm_warn2_resp_allKeys[_idm_warn2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_warn2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_warn2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_warn2' ---
    for (const thisComponent of idm_warn2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_warn2.stopped', globalClock.getTime());
    idm_warn2_resp.stop();
    // the Routine "idm_warn2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_practice_loop_name;
var cpdm_loop_name;
var cpdm_namer1Components;
function cpdm_namer1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_namer1' ---
    t = 0;
    cpdm_namer1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_namer1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_namer1_code
    cpdm_practice_loop_name = "cpdm_pract_trials1";
    cpdm_loop_name = "cpdm_trials1";
    
    // keep track of which components have finished
    cpdm_namer1Components = [];
    
    for (const thisComponent of cpdm_namer1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_namer1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_namer1' ---
    // get current time
    t = cpdm_namer1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_namer1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_namer1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_namer1' ---
    for (const thisComponent of cpdm_namer1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_namer1.stopped', globalClock.getTime());
    // the Routine "cpdm_namer1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_instr1_resp_allKeys;
var cpdm_instr1Components;
function cpdm_instr1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_instr1' ---
    t = 0;
    cpdm_instr1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_instr1.started', globalClock.getTime());
    cpdm_instr1_resp.keys = undefined;
    cpdm_instr1_resp.rt = undefined;
    _cpdm_instr1_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_instr1Components = [];
    cpdm_instr1Components.push(cpdm_instr1_img);
    cpdm_instr1Components.push(cpdm_instr1_title_txt);
    cpdm_instr1Components.push(cpdm_instr1_txt);
    cpdm_instr1Components.push(cpdm_instr1_Q_txt);
    cpdm_instr1Components.push(cpdm_instr1_P_txt);
    cpdm_instr1Components.push(cpdm_instr1_A_txt);
    cpdm_instr1Components.push(cpdm_instr1_L_txt);
    cpdm_instr1Components.push(cpdm_instr1_space_txt);
    cpdm_instr1Components.push(cpdm_instr1_resp);
    
    for (const thisComponent of cpdm_instr1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_instr1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_instr1' ---
    // get current time
    t = cpdm_instr1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_instr1_img* updates
    if (t >= 0.0 && cpdm_instr1_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_img.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_img.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_img.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_title_txt* updates
    if (t >= 0.0 && cpdm_instr1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_txt* updates
    if (t >= 0.0 && cpdm_instr1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_Q_txt* updates
    if (t >= 0.0 && cpdm_instr1_Q_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_Q_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_Q_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_Q_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_P_txt* updates
    if (t >= 0.0 && cpdm_instr1_P_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_P_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_P_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_P_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_A_txt* updates
    if (t >= 0.0 && cpdm_instr1_A_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_A_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_A_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_A_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_L_txt* updates
    if (t >= 0.0 && cpdm_instr1_L_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_L_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_L_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_L_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_space_txt* updates
    if (t >= 0.0 && cpdm_instr1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr1_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr1_resp* updates
    if (t >= 0.0 && cpdm_instr1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr1_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_instr1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_instr1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr1_resp.clearEvents(); });
    }
    
    if (cpdm_instr1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_instr1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_instr1_resp_allKeys = _cpdm_instr1_resp_allKeys.concat(theseKeys);
      if (_cpdm_instr1_resp_allKeys.length > 0) {
        cpdm_instr1_resp.keys = _cpdm_instr1_resp_allKeys[_cpdm_instr1_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_instr1_resp.rt = _cpdm_instr1_resp_allKeys[_cpdm_instr1_resp_allKeys.length - 1].rt;
        cpdm_instr1_resp.duration = _cpdm_instr1_resp_allKeys[_cpdm_instr1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_instr1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_instr1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_instr1' ---
    for (const thisComponent of cpdm_instr1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_instr1.stopped', globalClock.getTime());
    cpdm_instr1_resp.stop();
    // the Routine "cpdm_instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_instr2_resp_allKeys;
var cpdm_instr2Components;
function cpdm_instr2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_instr2' ---
    t = 0;
    cpdm_instr2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_instr2.started', globalClock.getTime());
    cpdm_instr2_resp.keys = undefined;
    cpdm_instr2_resp.rt = undefined;
    _cpdm_instr2_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_instr2Components = [];
    cpdm_instr2Components.push(cpdm_instr2_title_txt);
    cpdm_instr2Components.push(cpdm_instr2_instr_txt);
    cpdm_instr2Components.push(cpdm_instr2_left_arrow);
    cpdm_instr2Components.push(cpdm_instr2_left_gabor);
    cpdm_instr2Components.push(cpdm_instr2_left_txt);
    cpdm_instr2Components.push(cpdm_instr2_right_arrow);
    cpdm_instr2Components.push(cpdm_instr2_right_gabor);
    cpdm_instr2Components.push(cpdm_instr2_right_txt);
    cpdm_instr2Components.push(cpdm_instr2_space_txt);
    cpdm_instr2Components.push(cpdm_instr2_resp);
    
    for (const thisComponent of cpdm_instr2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_instr2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_instr2' ---
    // get current time
    t = cpdm_instr2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_instr2_title_txt* updates
    if (t >= 0.0 && cpdm_instr2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_instr_txt* updates
    if (t >= 0.0 && cpdm_instr2_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_instr_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_instr_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_instr_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_left_arrow* updates
    if (t >= 0.0 && cpdm_instr2_left_arrow.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_left_arrow.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_left_arrow.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_left_arrow.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_left_gabor* updates
    if (t >= 0.0 && cpdm_instr2_left_gabor.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_left_gabor.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_left_gabor.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_left_gabor.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_left_txt* updates
    if (t >= 0.0 && cpdm_instr2_left_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_left_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_left_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_left_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_right_arrow* updates
    if (t >= 0.0 && cpdm_instr2_right_arrow.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_right_arrow.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_right_arrow.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_right_arrow.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_right_gabor* updates
    if (t >= 0.0 && cpdm_instr2_right_gabor.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_right_gabor.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_right_gabor.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_right_gabor.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_right_txt* updates
    if (t >= 0.0 && cpdm_instr2_right_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_right_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_right_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_right_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_space_txt* updates
    if (t >= 0.0 && cpdm_instr2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr2_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr2_resp* updates
    if (t >= 0.0 && cpdm_instr2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr2_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_instr2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_instr2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr2_resp.clearEvents(); });
    }
    
    if (cpdm_instr2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_instr2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_instr2_resp_allKeys = _cpdm_instr2_resp_allKeys.concat(theseKeys);
      if (_cpdm_instr2_resp_allKeys.length > 0) {
        cpdm_instr2_resp.keys = _cpdm_instr2_resp_allKeys[_cpdm_instr2_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_instr2_resp.rt = _cpdm_instr2_resp_allKeys[_cpdm_instr2_resp_allKeys.length - 1].rt;
        cpdm_instr2_resp.duration = _cpdm_instr2_resp_allKeys[_cpdm_instr2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_instr2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_instr2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_instr2' ---
    for (const thisComponent of cpdm_instr2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_instr2.stopped', globalClock.getTime());
    cpdm_instr2_resp.stop();
    // the Routine "cpdm_instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_instr3_resp_allKeys;
var cpdm_instr3Components;
function cpdm_instr3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_instr3' ---
    t = 0;
    cpdm_instr3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_instr3.started', globalClock.getTime());
    cpdm_instr3_resp.keys = undefined;
    cpdm_instr3_resp.rt = undefined;
    _cpdm_instr3_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_instr3Components = [];
    cpdm_instr3Components.push(cpdm_instr3_title_txt);
    cpdm_instr3Components.push(cpdm_instr3_txt);
    cpdm_instr3Components.push(cpdm_instr3_space_txt);
    cpdm_instr3Components.push(cpdm_instr3_resp);
    
    for (const thisComponent of cpdm_instr3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_instr3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_instr3' ---
    // get current time
    t = cpdm_instr3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_instr3_title_txt* updates
    if (t >= 0.0 && cpdm_instr3_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr3_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr3_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr3_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr3_txt* updates
    if (t >= 0.0 && cpdm_instr3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr3_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr3_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr3_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr3_space_txt* updates
    if (t >= 0.0 && cpdm_instr3_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr3_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr3_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr3_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr3_resp* updates
    if (t >= 0.0 && cpdm_instr3_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr3_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_instr3_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_instr3_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr3_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr3_resp.clearEvents(); });
    }
    
    if (cpdm_instr3_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_instr3_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_instr3_resp_allKeys = _cpdm_instr3_resp_allKeys.concat(theseKeys);
      if (_cpdm_instr3_resp_allKeys.length > 0) {
        cpdm_instr3_resp.keys = _cpdm_instr3_resp_allKeys[_cpdm_instr3_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_instr3_resp.rt = _cpdm_instr3_resp_allKeys[_cpdm_instr3_resp_allKeys.length - 1].rt;
        cpdm_instr3_resp.duration = _cpdm_instr3_resp_allKeys[_cpdm_instr3_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_instr3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_instr3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_instr3' ---
    for (const thisComponent of cpdm_instr3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_instr3.stopped', globalClock.getTime());
    cpdm_instr3_resp.stop();
    // the Routine "cpdm_instr3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_instr4_resp_allKeys;
var cpdm_instr4Components;
function cpdm_instr4RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_instr4' ---
    t = 0;
    cpdm_instr4Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_instr4.started', globalClock.getTime());
    cpdm_instr4_resp.keys = undefined;
    cpdm_instr4_resp.rt = undefined;
    _cpdm_instr4_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_instr4Components = [];
    cpdm_instr4Components.push(cpdm_instr4_title_txt);
    cpdm_instr4Components.push(cpdm_instr4_txt);
    cpdm_instr4Components.push(cpdm_instr4_space_txt);
    cpdm_instr4Components.push(cpdm_instr4_resp);
    
    for (const thisComponent of cpdm_instr4Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_instr4RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_instr4' ---
    // get current time
    t = cpdm_instr4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_instr4_title_txt* updates
    if (t >= 0.0 && cpdm_instr4_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr4_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr4_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr4_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr4_txt* updates
    if (t >= 0.0 && cpdm_instr4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr4_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr4_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr4_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr4_space_txt* updates
    if (t >= 0.0 && cpdm_instr4_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr4_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_instr4_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_instr4_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_instr4_resp* updates
    if (t >= 0.0 && cpdm_instr4_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_instr4_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_instr4_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_instr4_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr4_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_instr4_resp.clearEvents(); });
    }
    
    if (cpdm_instr4_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_instr4_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_instr4_resp_allKeys = _cpdm_instr4_resp_allKeys.concat(theseKeys);
      if (_cpdm_instr4_resp_allKeys.length > 0) {
        cpdm_instr4_resp.keys = _cpdm_instr4_resp_allKeys[_cpdm_instr4_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_instr4_resp.rt = _cpdm_instr4_resp_allKeys[_cpdm_instr4_resp_allKeys.length - 1].rt;
        cpdm_instr4_resp.duration = _cpdm_instr4_resp_allKeys[_cpdm_instr4_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_instr4Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_instr4RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_instr4' ---
    for (const thisComponent of cpdm_instr4Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_instr4.stopped', globalClock.getTime());
    cpdm_instr4_resp.stop();
    // the Routine "cpdm_instr4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_warn1_resp_allKeys;
var cpdm_warnComponents;
function cpdm_warnRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_warn' ---
    t = 0;
    cpdm_warnClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_warn.started', globalClock.getTime());
    cpdm_warn1_resp.keys = undefined;
    cpdm_warn1_resp.rt = undefined;
    _cpdm_warn1_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_warnComponents = [];
    cpdm_warnComponents.push(cpdm_warn1_title_txt);
    cpdm_warnComponents.push(cpdm_warn1_txt);
    cpdm_warnComponents.push(cpdm_warn1_space_txt);
    cpdm_warnComponents.push(cpdm_warn1_resp);
    
    for (const thisComponent of cpdm_warnComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_warnRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_warn' ---
    // get current time
    t = cpdm_warnClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_warn1_title_txt* updates
    if (t >= 0.0 && cpdm_warn1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_warn1_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_warn1_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_warn1_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_warn1_txt* updates
    if (t >= 0.0 && cpdm_warn1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_warn1_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_warn1_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_warn1_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_warn1_space_txt* updates
    if (t >= 0.0 && cpdm_warn1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_warn1_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_warn1_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_warn1_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_warn1_resp* updates
    if (t >= 0.0 && cpdm_warn1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_warn1_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_warn1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_warn1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_warn1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_warn1_resp.clearEvents(); });
    }
    
    if (cpdm_warn1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_warn1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_warn1_resp_allKeys = _cpdm_warn1_resp_allKeys.concat(theseKeys);
      if (_cpdm_warn1_resp_allKeys.length > 0) {
        cpdm_warn1_resp.keys = _cpdm_warn1_resp_allKeys[_cpdm_warn1_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_warn1_resp.rt = _cpdm_warn1_resp_allKeys[_cpdm_warn1_resp_allKeys.length - 1].rt;
        cpdm_warn1_resp.duration = _cpdm_warn1_resp_allKeys[_cpdm_warn1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_warnComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_warnRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_warn' ---
    for (const thisComponent of cpdm_warnComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_warn.stopped', globalClock.getTime());
    cpdm_warn1_resp.stop();
    // the Routine "cpdm_warn" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_pract_instr_resp_allKeys;
var cpdm_pract_instrComponents;
function cpdm_pract_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_pract_instr' ---
    t = 0;
    cpdm_pract_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_pract_instr.started', globalClock.getTime());
    cpdm_pract_instr_resp.keys = undefined;
    cpdm_pract_instr_resp.rt = undefined;
    _cpdm_pract_instr_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_pract_instrComponents = [];
    cpdm_pract_instrComponents.push(cpdm_pract_instr_title_txt);
    cpdm_pract_instrComponents.push(cpdm_pract_instr_txt);
    cpdm_pract_instrComponents.push(cpdm_pract_instr_space_txt);
    cpdm_pract_instrComponents.push(cpdm_pract_instr_resp);
    
    for (const thisComponent of cpdm_pract_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_pract_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_pract_instr' ---
    // get current time
    t = cpdm_pract_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_pract_instr_title_txt* updates
    if (t >= 0.0 && cpdm_pract_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_pract_instr_txt* updates
    if (t >= 0.0 && cpdm_pract_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_instr_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_instr_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_instr_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_pract_instr_space_txt* updates
    if (t >= 0.0 && cpdm_pract_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_pract_instr_resp* updates
    if (t >= 0.0 && cpdm_pract_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_instr_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_pract_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_pract_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_pract_instr_resp.clearEvents(); });
    }
    
    if (cpdm_pract_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_pract_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_pract_instr_resp_allKeys = _cpdm_pract_instr_resp_allKeys.concat(theseKeys);
      if (_cpdm_pract_instr_resp_allKeys.length > 0) {
        cpdm_pract_instr_resp.keys = _cpdm_pract_instr_resp_allKeys[_cpdm_pract_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_pract_instr_resp.rt = _cpdm_pract_instr_resp_allKeys[_cpdm_pract_instr_resp_allKeys.length - 1].rt;
        cpdm_pract_instr_resp.duration = _cpdm_pract_instr_resp_allKeys[_cpdm_pract_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_pract_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_pract_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_pract_instr' ---
    for (const thisComponent of cpdm_pract_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_pract_instr.stopped', globalClock.getTime());
    cpdm_pract_instr_resp.stop();
    // the Routine "cpdm_pract_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_init_fixComponents;
function cpdm_init_fixRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_init_fix' ---
    t = 0;
    cpdm_init_fixClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_init_fix.started', globalClock.getTime());
    // keep track of which components have finished
    cpdm_init_fixComponents = [];
    cpdm_init_fixComponents.push(cpdm_init_fix_poly);
    
    for (const thisComponent of cpdm_init_fixComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


var frameRemains;
function cpdm_init_fixRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_init_fix' ---
    // get current time
    t = cpdm_init_fixClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_init_fix_poly* updates
    if (t >= 0.0 && cpdm_init_fix_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_init_fix_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_init_fix_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_init_fix_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_init_fix_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_init_fix_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_init_fixComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_init_fixRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_init_fix' ---
    for (const thisComponent of cpdm_init_fixComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_init_fix.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var my_loop;
var cpdm_trial_acc;
var cpdm_trial_conf;
var is_clockwise;
var _cpdm_pract_trial_resp_allKeys;
var cpdm_pract_trialComponents;
function cpdm_pract_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_pract_trial' ---
    t = 0;
    cpdm_pract_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.300000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_pract_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_pract_trial_code
    my_loop = eval(cpdm_practice_loop_name);
    cpdm_trial_acc = 0;
    cpdm_trial_conf = 0; 
    left_high_color = [0, 0, 0];
    left_low_color = [0, 0, 0];
    right_high_color = [0, 0, 0];
    right_low_color = [0, 0, 0];
    is_clockwise = false;
    if ((cpdm_gabor_orient > 0.0)) {
        is_clockwise = true;
    } else {
        if ((cpdm_gabor_orient === 0.0)) {
            cpdm_rand_num = random.randint(0, 2);
            if ((cpdm_rand_num === 1)) {
                is_clockwise = true;
            } else {
                is_clockwise = false;
            }
        }
    }
    
    cpdm_pract_trial_gabor.setContrast(cpdm_gabor_contrast);
    cpdm_pract_trial_gabor.setOri(cpdm_gabor_orient);
    cpdm_pract_trial_resp.keys = undefined;
    cpdm_pract_trial_resp.rt = undefined;
    _cpdm_pract_trial_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_pract_trialComponents = [];
    cpdm_pract_trialComponents.push(cpdm_pract_trial_gabor);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_left_high_poly);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_right_high_poly);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_left_low_poly);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_right_low_poly);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_left_high_txt);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_right_high_txt);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_left_low_txt);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_right_low_txt);
    cpdm_pract_trialComponents.push(cpdm_pract_trial_resp);
    
    for (const thisComponent of cpdm_pract_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


var cpdm_key;
function cpdm_pract_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_pract_trial' ---
    // get current time
    t = cpdm_pract_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from cpdm_pract_trial_code
    cpdm_key = cpdm_pract_trial_resp.keys;
    if (!(cpdm_key === undefined) && (cpdm_key.length == 1)) {
        if ((cpdm_key === "q")) {
            cpdm_trial_conf = 1;
            if ((is_clockwise === false)) {
                left_high_color = "green";
                cpdm_trial_acc = 1;
            } else {
                left_high_color = "red";
            }
        } else {
            if ((cpdm_key === "a")) {
                if ((is_clockwise === false)) {
                    left_low_color = "green";
                    cpdm_trial_acc = 1;
                } else {
                    left_low_color = "red";
                }
            } else {
                if ((cpdm_key === "p")) {
                    cpdm_trial_conf = 1;
                    if ((is_clockwise === true)) {
                        right_high_color = "green";
                        cpdm_trial_acc = 1;
                    } else {
                        right_high_color = "red";
                    }
                } else {
                    if ((cpdm_key === "l")) {
                        if ((is_clockwise === true)) {
                            right_low_color = "green";
                            cpdm_trial_acc = 1;
                        } else {
                            right_low_color = "red";
                        }
                    }
                }
            }
        }
    }
    
    // *cpdm_pract_trial_gabor* updates
    if (t >= 0.0 && cpdm_pract_trial_gabor.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_gabor.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_gabor.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_gabor.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_gabor.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_gabor.setAutoDraw(false);
    }
    
    if (cpdm_pract_trial_left_high_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_pract_trial_left_high_poly.setFillColor(new util.Color(left_high_color), false);
    }
    
    // *cpdm_pract_trial_left_high_poly* updates
    if (t >= 0.3 && cpdm_pract_trial_left_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_left_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_left_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_left_high_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_left_high_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_left_high_poly.setAutoDraw(false);
    }
    
    if (cpdm_pract_trial_right_high_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_pract_trial_right_high_poly.setFillColor(new util.Color(right_high_color), false);
    }
    
    // *cpdm_pract_trial_right_high_poly* updates
    if (t >= 0.3 && cpdm_pract_trial_right_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_right_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_right_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_right_high_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_right_high_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_right_high_poly.setAutoDraw(false);
    }
    
    if (cpdm_pract_trial_left_low_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_pract_trial_left_low_poly.setFillColor(new util.Color(left_low_color), false);
    }
    
    // *cpdm_pract_trial_left_low_poly* updates
    if (t >= 0.3 && cpdm_pract_trial_left_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_left_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_left_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_left_low_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_left_low_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_left_low_poly.setAutoDraw(false);
    }
    
    if (cpdm_pract_trial_right_low_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_pract_trial_right_low_poly.setFillColor(new util.Color(right_low_color), false);
    }
    
    // *cpdm_pract_trial_right_low_poly* updates
    if (t >= 0.3 && cpdm_pract_trial_right_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_right_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_right_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_right_low_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_right_low_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_right_low_poly.setAutoDraw(false);
    }
    
    // *cpdm_pract_trial_left_high_txt* updates
    if (t >= 0.3 && cpdm_pract_trial_left_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_left_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_left_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_left_high_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_left_high_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_left_high_txt.setAutoDraw(false);
    }
    
    // *cpdm_pract_trial_right_high_txt* updates
    if (t >= 0.3 && cpdm_pract_trial_right_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_right_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_right_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_right_high_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_right_high_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_right_high_txt.setAutoDraw(false);
    }
    
    // *cpdm_pract_trial_left_low_txt* updates
    if (t >= 0.3 && cpdm_pract_trial_left_low_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_left_low_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_left_low_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_left_low_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_left_low_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_left_low_txt.setAutoDraw(false);
    }
    
    // *cpdm_pract_trial_right_low_txt* updates
    if (t >= 0.3 && cpdm_pract_trial_right_low_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_right_low_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_right_low_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_trial_right_low_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_right_low_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_right_low_txt.setAutoDraw(false);
    }
    
    // *cpdm_pract_trial_resp* updates
    if (t >= 0.3 && cpdm_pract_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_trial_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_pract_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_pract_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_pract_trial_resp.clearEvents(); });
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cpdm_pract_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_pract_trial_resp.getKeys({keyList: ['q', 'a', 'p', 'l'], waitRelease: false});
      _cpdm_pract_trial_resp_allKeys = _cpdm_pract_trial_resp_allKeys.concat(theseKeys);
      if (_cpdm_pract_trial_resp_allKeys.length > 0) {
        cpdm_pract_trial_resp.keys = _cpdm_pract_trial_resp_allKeys[0].name;  // just the first key pressed
        cpdm_pract_trial_resp.rt = _cpdm_pract_trial_resp_allKeys[0].rt;
        cpdm_pract_trial_resp.duration = _cpdm_pract_trial_resp_allKeys[0].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_pract_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_pract_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_pract_trial' ---
    for (const thisComponent of cpdm_pract_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_pract_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_pract_trial_code
    my_loop.addData("cpdm_pract_acc", cpdm_trial_acc);
    my_loop.addData("cpdm_pract_conf", cpdm_trial_conf);
    my_loop.addData("cpdm_trial_type", "practice");
    
    left_high_color = [0, 0, 0];
    left_low_color = [0, 0, 0];
    right_high_color = [0, 0, 0];
    right_low_color = [0, 0, 0];
    
    cpdm_pract_trial_left_high_poly.setFillColor(new util.Color(left_high_color), false);
    cpdm_pract_trial_left_low_poly.setFillColor(new util.Color(left_low_color), false);
    cpdm_pract_trial_right_high_poly.setFillColor(new util.Color(right_high_color), false);
    cpdm_pract_trial_right_low_poly.setFillColor(new util.Color(right_low_color), false);
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cpdm_pract_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cpdm_pract_trial_resp.keys', cpdm_pract_trial_resp.keys);
    if (typeof cpdm_pract_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cpdm_pract_trial_resp.rt', cpdm_pract_trial_resp.rt);
        psychoJS.experiment.addData('cpdm_pract_trial_resp.duration', cpdm_pract_trial_resp.duration);
        }
    
    cpdm_pract_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_iti1Components;
function cpdm_pract_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_pract_iti1' ---
    t = 0;
    cpdm_pract_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_pract_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_pract_iti1_code
    if (!(cpdm_pract_trials1.thisTrialN == undefined) && (cpdm_pract_trials1.thisTrialN === 4)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cpdm_pract_iti1Components = [];
    cpdm_pract_iti1Components.push(cpdm_pract_iti1_poly);
    
    for (const thisComponent of cpdm_pract_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_pract_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_pract_iti1' ---
    // get current time
    t = cpdm_pract_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_pract_iti1_poly* updates
    if (t >= 0.0 && cpdm_pract_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_iti1_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_iti1_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_pract_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_pract_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_pract_iti1' ---
    for (const thisComponent of cpdm_pract_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_pract_iti1.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_trial_instr_resp_allKeys;
var cpdm_trial_instrComponents;
function cpdm_trial_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_trial_instr' ---
    t = 0;
    cpdm_trial_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_trial_instr.started', globalClock.getTime());
    cpdm_trial_instr_resp.keys = undefined;
    cpdm_trial_instr_resp.rt = undefined;
    _cpdm_trial_instr_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_trial_instrComponents = [];
    cpdm_trial_instrComponents.push(cpdm_trial_instr_title_txt);
    cpdm_trial_instrComponents.push(cpdm_trial_instr_txt);
    cpdm_trial_instrComponents.push(cpdm_trial_instr_space_txt);
    cpdm_trial_instrComponents.push(cpdm_trial_instr_resp);
    
    for (const thisComponent of cpdm_trial_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_trial_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_trial_instr' ---
    // get current time
    t = cpdm_trial_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_trial_instr_title_txt* updates
    if (t >= 0.0 && cpdm_trial_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_trial_instr_txt* updates
    if (t >= 0.0 && cpdm_trial_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_instr_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_instr_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_instr_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_trial_instr_space_txt* updates
    if (t >= 0.0 && cpdm_trial_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_trial_instr_resp* updates
    if (t >= 0.0 && cpdm_trial_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_instr_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_trial_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_trial_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_trial_instr_resp.clearEvents(); });
    }
    
    if (cpdm_trial_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_trial_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_trial_instr_resp_allKeys = _cpdm_trial_instr_resp_allKeys.concat(theseKeys);
      if (_cpdm_trial_instr_resp_allKeys.length > 0) {
        cpdm_trial_instr_resp.keys = _cpdm_trial_instr_resp_allKeys[_cpdm_trial_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_trial_instr_resp.rt = _cpdm_trial_instr_resp_allKeys[_cpdm_trial_instr_resp_allKeys.length - 1].rt;
        cpdm_trial_instr_resp.duration = _cpdm_trial_instr_resp_allKeys[_cpdm_trial_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_trial_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_trial_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_trial_instr' ---
    for (const thisComponent of cpdm_trial_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_trial_instr.stopped', globalClock.getTime());
    cpdm_trial_instr_resp.stop();
    // the Routine "cpdm_trial_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _pj;
var run_resps;
var cpdm_catch_trials;
var left_resp_txt;
var right_resp_txt;
var cpdm_iti_list;
var cpdm_s;
var cpdm_run_setterComponents;
function cpdm_run_setterRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_run_setter' ---
    t = 0;
    cpdm_run_setterClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_run_setter.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_run_setter_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    run_resps = [];
    cpdm_catch_trials = [];
    
    //if (_pj.in_es6("low_vol", cpdm_run_dimension)) {
    //    run_schedule = "cpdm/cpdm-1contrast.xlsx";
    //} else {
    //    run_schedule = "cpdm/cpdm-5contrasts.xlsx";
    //}
    
    if (_pj.in_es6("low_risk", cpdm_run_dimension)) {
        left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $9 or $0";
        right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $9 or $0";
    } else {
        left_resp_txt = "LEFT \n \n HIGH Confidence \n \n $13 or $0";
        right_resp_txt = "RIGHT \n \n HIGH Confidence \n \n $13 or $0";
    }
    cpdm_iti_list = function () {
        var _pj_a = [], _pj_b = util.range(200);
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(random.random());
        }
        return _pj_a;
    }
    .call(this);
    cpdm_s = util.sum(cpdm_iti_list);
    cpdm_iti_list = function () {
        var _pj_a = [], _pj_b = cpdm_iti_list;
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(((i * 200) / cpdm_s));
        }
        return _pj_a;
    }
    .call(this);
    // keep track of which components have finished
    cpdm_run_setterComponents = [];
    
    for (const thisComponent of cpdm_run_setterComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_run_setterRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_run_setter' ---
    // get current time
    t = cpdm_run_setterClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_run_setterComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_run_setterRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_run_setter' ---
    for (const thisComponent of cpdm_run_setterComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_run_setter.stopped', globalClock.getTime());
    // the Routine "cpdm_run_setter" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var corr_high_txt;
var _cpdm_loop_instr_resp_allKeys;
var cpdm_loop_instrComponents;
function cpdm_loop_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_loop_instr' ---
    t = 0;
    cpdm_loop_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_loop_instr.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_loop_instr_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    if (_pj.in_es6("low_risk", cpdm_run_dimension)) {
        corr_high_txt = "Correct \n High Confidence \n $9";
    } else {
        corr_high_txt = "Correct \n High Confidence \n $13";
    }
    
    cpdm_loop_instr_code2.setText(("Block " + run_counter.toString()));
    cpdm_loop_instr_corr_high_txt.setText(corr_high_txt);
    cpdm_loop_instr_resp.keys = undefined;
    cpdm_loop_instr_resp.rt = undefined;
    _cpdm_loop_instr_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_loop_instrComponents = [];
    cpdm_loop_instrComponents.push(cpdm_loop_instr_code2);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_corr_high_poly);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_right_high_poly);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_left_low_poly);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_right_low_poly);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_corr_high_txt);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_incorr_high_txt);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_corr_low_txt);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_incorr_low);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_space_txt);
    cpdm_loop_instrComponents.push(cpdm_loop_instr_resp);
    
    for (const thisComponent of cpdm_loop_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_loop_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_loop_instr' ---
    // get current time
    t = cpdm_loop_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_loop_instr_code2* updates
    if (t >= 0.0 && cpdm_loop_instr_code2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_code2.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_code2.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_code2.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_corr_high_poly* updates
    if (t >= 0.0 && cpdm_loop_instr_corr_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_corr_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_corr_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_corr_high_poly.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_right_high_poly* updates
    if (t >= 0 && cpdm_loop_instr_right_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_right_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_right_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_right_high_poly.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_left_low_poly* updates
    if (t >= 0.0 && cpdm_loop_instr_left_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_left_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_left_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_left_low_poly.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_right_low_poly* updates
    if (t >= 0.0 && cpdm_loop_instr_right_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_right_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_right_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_right_low_poly.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_corr_high_txt* updates
    if (t >= 0.0 && cpdm_loop_instr_corr_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_corr_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_corr_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_corr_high_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_incorr_high_txt* updates
    if (t >= 0 && cpdm_loop_instr_incorr_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_incorr_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_incorr_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_incorr_high_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_corr_low_txt* updates
    if (t >= 0.0 && cpdm_loop_instr_corr_low_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_corr_low_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_corr_low_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_corr_low_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_incorr_low* updates
    if (t >= 0.0 && cpdm_loop_instr_incorr_low.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_incorr_low.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_incorr_low.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_incorr_low.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_space_txt* updates
    if (t >= 0.0 && cpdm_loop_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_loop_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_loop_instr_resp* updates
    if (t >= 0.0 && cpdm_loop_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_loop_instr_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_loop_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_loop_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_loop_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_loop_instr_resp.clearEvents(); });
    }
    
    if (cpdm_loop_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_loop_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_loop_instr_resp_allKeys = _cpdm_loop_instr_resp_allKeys.concat(theseKeys);
      if (_cpdm_loop_instr_resp_allKeys.length > 0) {
        cpdm_loop_instr_resp.keys = _cpdm_loop_instr_resp_allKeys[_cpdm_loop_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_loop_instr_resp.rt = _cpdm_loop_instr_resp_allKeys[_cpdm_loop_instr_resp_allKeys.length - 1].rt;
        cpdm_loop_instr_resp.duration = _cpdm_loop_instr_resp_allKeys[_cpdm_loop_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_loop_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_loop_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_loop_instr' ---
    for (const thisComponent of cpdm_loop_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_loop_instr.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_loop_instr_code
    run_counter += 1;
    
    cpdm_loop_instr_resp.stop();
    // the Routine "cpdm_loop_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_stop_timer;
var cpdm_stopped_time;
var _cpdm_trial_resp_allKeys;
var cpdm_trialComponents;
function cpdm_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_trial' ---
    t = 0;
    cpdm_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.300000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_trial_code
    my_loop = eval(cpdm_loop_name);
    cpdm_stop_timer = null;
    cpdm_stopped_time = 0;
    cpdm_trial_acc = 0;
    cpdm_trial_conf = 0;
    left_high_color = [0, 0, 0];
    left_low_color = [0, 0, 0];
    right_high_color = [0, 0, 0];
    right_low_color = [0, 0, 0];
    is_clockwise = false;
    if ((cpdm_gabor_orient > 0.0)) {
        is_clockwise = true;
    } else {
        if ((cpdm_gabor_orient === 0.0)) {
            cpdm_rand_num = random.randint(0, 2);
            if ((cpdm_rand_num === 1)) {
                is_clockwise = true;
            } else {
                is_clockwise = false;
            }
        }
    }
    
    cpdm_trial_gabor.setContrast(cpdm_gabor_contrast);
    cpdm_trial_gabor.setOri(cpdm_gabor_orient);
    cpdm_trial_left_high_txt.setText(left_resp_txt);
    cpdm_trial_right_high_txt.setText(right_resp_txt);
    cpdm_trial_resp.keys = undefined;
    cpdm_trial_resp.rt = undefined;
    _cpdm_trial_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_trialComponents = [];
    cpdm_trialComponents.push(cpdm_trial_gabor);
    cpdm_trialComponents.push(cpdm_trial_left_high_poly);
    cpdm_trialComponents.push(cpdm_trial_right_high_poly);
    cpdm_trialComponents.push(cpdm_trial_left_low_poly);
    cpdm_trialComponents.push(cpdm_trial_right_low_poly);
    cpdm_trialComponents.push(cpdm_trial_left_high_txt);
    cpdm_trialComponents.push(cpdm_trial_right_high_txt);
    cpdm_trialComponents.push(cpdm_trial_left_low_txt);
    cpdm_trialComponents.push(cpdm_trial_right_low_txt);
    cpdm_trialComponents.push(cpdm_trial_resp);
    
    for (const thisComponent of cpdm_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_trial' ---
    // get current time
    t = cpdm_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from cpdm_trial_code
    cpdm_key = cpdm_trial_resp.keys;
    if (!(cpdm_key === undefined) && (cpdm_key.length == 1)) { 
        if ((cpdm_stop_timer === null)) {
            cpdm_stop_timer = new util.Clock();
        } else {
            cpdm_stopped_time = cpdm_stop_timer.getTime();
            if ((cpdm_stopped_time >= 0.5)) {
                continueRoutine = false;
            }
        }
        if ((cpdm_key === "q")) {
            cpdm_trial_conf = 1;
            if ((is_clockwise === false)) {
                left_high_color = "darkgray";
                cpdm_trial_acc = 1;
            } else {
                left_high_color = "darkgray";
            }
        } else {
            if ((cpdm_key === "a")) {
                if ((is_clockwise === false)) {
                    left_low_color = "darkgray";
                    cpdm_trial_acc = 1;
                } else {
                    left_low_color = "darkgray";
                }
            } else {
                if ((cpdm_key === "p")) {
                    cpdm_trial_conf = 1;
                    if ((is_clockwise === true)) {
                        right_high_color = "darkgray";
                        cpdm_trial_acc = 1;
                    } else {
                        right_high_color = "darkgray";
                    }
                } else {
                    if ((cpdm_key === "l")) {
                        if ((is_clockwise === true)) {
                            right_low_color = "darkgray";
                            cpdm_trial_acc = 1;
                        } else {
                            right_low_color = "darkgray";
                        }
                    }
                }
            }
        }
    }
    
    
    // *cpdm_trial_gabor* updates
    if (t >= 0.0 && cpdm_trial_gabor.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_gabor.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_gabor.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_gabor.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_gabor.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_gabor.setAutoDraw(false);
    }
    
    if (cpdm_trial_left_high_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_trial_left_high_poly.setFillColor(new util.Color(left_high_color), false);
    }
    
    // *cpdm_trial_left_high_poly* updates
    if (t >= 0.3 && cpdm_trial_left_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_left_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_left_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_left_high_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_left_high_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_left_high_poly.setAutoDraw(false);
    }
    
    if (cpdm_trial_right_high_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_trial_right_high_poly.setFillColor(new util.Color(right_high_color), false);
    }
    
    // *cpdm_trial_right_high_poly* updates
    if (t >= 0.3 && cpdm_trial_right_high_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_right_high_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_right_high_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_right_high_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_right_high_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_right_high_poly.setAutoDraw(false);
    }
    
    if (cpdm_trial_left_low_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_trial_left_low_poly.setFillColor(new util.Color(left_low_color), false);
    }
    
    // *cpdm_trial_left_low_poly* updates
    if (t >= 0.3 && cpdm_trial_left_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_left_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_left_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_left_low_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_left_low_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_left_low_poly.setAutoDraw(false);
    }
    
    if (cpdm_trial_right_low_poly.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cpdm_trial_right_low_poly.setFillColor(new util.Color(right_low_color), false);
    }
    
    // *cpdm_trial_right_low_poly* updates
    if (t >= 0.3 && cpdm_trial_right_low_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_right_low_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_right_low_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_right_low_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_right_low_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_right_low_poly.setAutoDraw(false);
    }
    
    // *cpdm_trial_left_high_txt* updates
    if (t >= 0.3 && cpdm_trial_left_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_left_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_left_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_left_high_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_left_high_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_left_high_txt.setAutoDraw(false);
    }
    
    // *cpdm_trial_right_high_txt* updates
    if (t >= 0.3 && cpdm_trial_right_high_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_right_high_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_right_high_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_right_high_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_right_high_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_right_high_txt.setAutoDraw(false);
    }
    
    // *cpdm_trial_left_low_txt* updates
    if (t >= 0.3 && cpdm_trial_left_low_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_left_low_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_left_low_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_left_low_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_left_low_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_left_low_txt.setAutoDraw(false);
    }
    
    // *cpdm_trial_right_low_txt* updates
    if (t >= 0.3 && cpdm_trial_right_low_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_right_low_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_right_low_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_trial_right_low_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_right_low_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_right_low_txt.setAutoDraw(false);
    }
    
    // *cpdm_trial_resp* updates
    if (t >= 0.3 && cpdm_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trial_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_trial_resp.clearEvents(); });
    }
    
    frameRemains = 0.3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cpdm_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_trial_resp.getKeys({keyList: ['q', 'a', 'p', 'l'], waitRelease: false});
      _cpdm_trial_resp_allKeys = _cpdm_trial_resp_allKeys.concat(theseKeys);
      if (_cpdm_trial_resp_allKeys.length > 0) {
        cpdm_trial_resp.keys = _cpdm_trial_resp_allKeys[0].name;  // just the first key pressed
        cpdm_trial_resp.rt = _cpdm_trial_resp_allKeys[0].rt;
        cpdm_trial_resp.duration = _cpdm_trial_resp_allKeys[0].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_trial' ---
    for (const thisComponent of cpdm_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_trial_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    my_loop.addData("cpdm_run_dimension", cpdm_run_dimension);
    my_loop.addData("cpdm_acc", cpdm_trial_acc);
    my_loop.addData("cpdm_conf", cpdm_trial_conf);
    my_loop.addData("cpdm_trial_type", "task");
    cpdm_key = cpdm_trial_resp.keys;
    if (_pj.in_es6(cpdm_key, ["q", "a", "p", "l"])) {
        run_resps.push(cpdm_key);
    }
    if ((((cpdm_trial_resp.rt) === undefined) || (cpdm_trial_resp.rt >= (2 - 0.5)))) { 
        cpdm_delta_time = 0;
    } else {
        cpdm_delta_time = Math.max(0, (2 - (cpdm_trial_resp.rt + cpdm_stopped_time)));
    }
    if (_pj.in_es6("low_risk", cpdm_run_dimension)) {
        if ((cpdm_key === "q")) {
            if ((is_clockwise === false)) {
                my_loop.addData("cpdm_conf2", "high");
                my_loop.addData("cpdm_money", 9);
                if ((cpdm_catch_trial === 1)) {
                    cpdm_catch_trials.push(1);
                }
                if ((cpdm_gabor_orient !== 0.0)) {
                    cpdm_bonus_trials.push(["CPDM", 9, "CORRECT", "HIGH"]);
                }
            } else {
                my_loop.addData("cpdm_conf2", "high");
                my_loop.addData("cpdm_money", 0);
                if ((cpdm_catch_trial === 1)) {
                    cpdm_catch_trials.push(0);
                }
                if ((cpdm_gabor_orient !== 0.0)) {
                    cpdm_bonus_trials.push(["CPDM", 0, "INCORRECT", "HIGH"]);
                }
            }
        } else {
            if ((cpdm_key === "a")) {
                if ((is_clockwise === false)) {
                    my_loop.addData("cpdm_conf2", "low");
                    my_loop.addData("cpdm_money", 8);
                    if ((cpdm_catch_trial === 1)) {
                        cpdm_catch_trials.push(1);
                    }
                    if ((cpdm_gabor_orient !== 0.0)) {
                        cpdm_bonus_trials.push(["CPDM", 8, "CORRECT", "LOW"]);
                    }
                } else {
                    my_loop.addData("cpdm_conf2", "low");
                    my_loop.addData("cpdm_money", 6);
                    if ((cpdm_catch_trial === 1)) {
                        cpdm_catch_trials.push(0);
                    }
                    if ((cpdm_gabor_orient !== 0.0)) {
                        cpdm_bonus_trials.push(["CPDM", 6, "INCORRECT", "LOW"]);
                    }
                }
            } else {
                if ((cpdm_key === "p")) {
                    if ((is_clockwise === true)) {
                        my_loop.addData("cpdm_conf2", "high");
                        my_loop.addData("cpdm_money", 9);
                        if ((cpdm_catch_trial === 1)) {
                            cpdm_catch_trials.push(1);
                        }
                        if ((cpdm_gabor_orient !== 0.0)) {
                            cpdm_bonus_trials.push(["CPDM", 9, "CORRECT", "HIGH"]);
                        }
                    } else {
                        my_loop.addData("cpdm_conf2", "high");
                        my_loop.addData("cpdm_money", 0);
                        if ((cpdm_catch_trial === 1)) {
                            cpdm_catch_trials.push(0);
                        }
                        if ((cpdm_gabor_orient !== 0.0)) {
                            cpdm_bonus_trials.push(["CPDM", 0, "INCORRECT", "HIGH"]);
                        }
                    }
                } else {
                    if ((cpdm_key === "l")) {
                        if ((is_clockwise === true)) {
                            my_loop.addData("cpdm_conf2", "low");
                            my_loop.addData("cpdm_money", 8);
                            if ((cpdm_catch_trial === 1)) {
                                cpdm_catch_trials.push(1);
                            }
                            if ((cpdm_gabor_orient !== 0.0)) {
                                cpdm_bonus_trials.push(["CPDM", 8, "CORRECT", "LOW"]);
                            }
                        } else {
                            my_loop.addData("cpdm_conf2", "low");
                            my_loop.addData("cpdm_money", 6);
                            if ((cpdm_catch_trial === 1)) {
                                cpdm_catch_trials.push(0);
                            }
                            if ((cpdm_gabor_orient !== 0.0)) {
                                cpdm_bonus_trials.push(["CPDM", 6, "INCORRECT", "LOW"]);
                            }
                        }
                    }
                }
            }
        }
    } else {
        if ((cpdm_key === "q")) {
            if ((is_clockwise === false)) {
                my_loop.addData("cpdm_conf2", "high");
                my_loop.addData("cpdm_money", 13);
                if ((cpdm_catch_trial === 1)) {
                    cpdm_catch_trials.push(1);
                }
                if ((cpdm_gabor_orient !== 0.0)) {
                    cpdm_bonus_trials.push(["CPDM", 13, "CORRECT", "HIGH"]);
                }
            } else {
                my_loop.addData("cpdm_conf2", "high");
                my_loop.addData("cpdm_money", 0);
                if ((cpdm_catch_trial === 1)) {
                    cpdm_catch_trials.push(0);
                }
                if ((cpdm_gabor_orient !== 0.0)) {
                    cpdm_bonus_trials.push(["CPDM", 0, "INCORRECT", "HIGH"]);
                }
            }
        } else {
            if ((cpdm_key === "a")) {
                if ((is_clockwise === false)) {
                    my_loop.addData("cpdm_conf2", "low");
                    my_loop.addData("cpdm_money", 8);
                    if ((cpdm_catch_trial === 1)) {
                        cpdm_catch_trials.push(1);
                    }
                    if ((cpdm_gabor_orient !== 0.0)) {
                        cpdm_bonus_trials.push(["CPDM", 8, "CORRECT", "LOW"]);
                    }
                } else {
                    my_loop.addData("cpdm_conf2", "low");
                    my_loop.addData("cpdm_money", 6);
                    if ((cpdm_catch_trial === 1)) {
                        cpdm_catch_trials.push(0);
                    }
                    if ((cpdm_gabor_orient !== 0.0)) {
                        cpdm_bonus_trials.push(["CPDM", 6, "INCORRECT", "LOW"]);
                    }
                }
            } else {
                if ((cpdm_key === "p")) {
                    if ((is_clockwise === true)) {
                        my_loop.addData("cpdm_conf2", "high");
                        my_loop.addData("cpdm_money", 13);
                        if ((cpdm_catch_trial === 1)) {
                            cpdm_catch_trials.push(1);
                        }
                        if ((cpdm_gabor_orient !== 0.0)) {
                            cpdm_bonus_trials.push(["CPDM", 13, "CORRECT", "HIGH"]);
                        }
                    } else {
                        my_loop.addData("cpdm_conf2", "high");
                        my_loop.addData("cpdm_money", 0);
                        if ((cpdm_catch_trial === 1)) {
                            cpdm_catch_trials.push(0);
                        }
                        if ((cpdm_gabor_orient !== 0.0)) {
                            cpdm_bonus_trials.push(["CPDM", 0, "INCORRECT", "HIGH"]);
                        }
                    }
                } else {
                    if ((cpdm_key === "l")) {
                        if ((is_clockwise === true)) {
                            my_loop.addData("cpdm_conf2", "low");
                            my_loop.addData("cpdm_money", 8);
                            if ((cpdm_catch_trial === 1)) {
                                cpdm_catch_trials.push(1);
                            }
                            if ((cpdm_gabor_orient !== 0.0)) {
                                cpdm_bonus_trials.push(["CPDM", 8, "CORRECT", "LOW"]);
                            }
                        } else {
                            my_loop.addData("cpdm_conf2", "low");
                            my_loop.addData("cpdm_money", 6);
                            if ((cpdm_catch_trial === 1)) {
                                cpdm_catch_trials.push(0);
                            }
                            if ((cpdm_gabor_orient !== 0.0)) {
                                cpdm_bonus_trials.push(["CPDM", 6, "INCORRECT", "LOW"]);
                            }
                        }
                    }
                }
            }
        }
    }
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cpdm_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cpdm_trial_resp.keys', cpdm_trial_resp.keys);
    if (typeof cpdm_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cpdm_trial_resp.rt', cpdm_trial_resp.rt);
        psychoJS.experiment.addData('cpdm_trial_resp.duration', cpdm_trial_resp.duration);
        }
    
    cpdm_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_iti_time;
var cpdm_trial_iti1Components;
function cpdm_trial_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_trial_iti1' ---
    t = 0;
    cpdm_trial_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_trial_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_trials_iti1_code
    cpdm_iti_time = (cpdm_iti_list[my_loop.thisIndex] + cpdm_delta_time);
    if (!(cpdm_trials1.thisTrialN == undefined) && (cpdm_trials1.thisTrialN === 199)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cpdm_trial_iti1Components = [];
    cpdm_trial_iti1Components.push(cpdm_trials_iti1_poly);
    
    for (const thisComponent of cpdm_trial_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_trial_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_trial_iti1' ---
    // get current time
    t = cpdm_trial_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_trials_iti1_poly* updates
    if (t >= 0.0 && cpdm_trials_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trials_iti1_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trials_iti1_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trials_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + cpdm_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trials_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trials_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_trial_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_trial_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_trial_iti1' ---
    for (const thisComponent of cpdm_trial_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_trial_iti1.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_trials_iti1_code
    my_loop.addData("cpdm_delta_time", cpdm_delta_time);
    my_loop.addData("cpdm_iti_time", cpdm_iti_time);
    
    // the Routine "cpdm_trial_iti1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_unique_resps;
var cpdm_unique_count;
var exp_proceed;
var _cpdm_run_break1_resp_allKeys;
var cpdm_run_break1Components;
function cpdm_run_break1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_run_break1' ---
    t = 0;
    cpdm_run_break1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_run_break1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_run_break1_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    cpdm_unique_resps = [];
    cpdm_unique_count = 0;
    for (var i, _pj_c = 0, _pj_a = run_resps, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        if ((! _pj.in_es6(i, cpdm_unique_resps))) {
            cpdm_unique_count += 1;
            cpdm_unique_resps.push(i);
        }
    }
    cpdm_run_break_text = "";
    cpdm_space_text = "";
    if ((run_resps.length < 190)) {
        cpdm_run_break_text = (("You failed to respond to " + (200 - run_resps.length).toString()) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
        cpdm_space_text = "Press SPACE to end.";
        exp_proceed = false;
        my_loop.addData("cpdm_subReject1", "< 95% resp rate");
        my_loop.addData("cpdm_subReject1_nonresps", (200 - run_resps.length));
    } else {
        if ((cpdm_unique_count < 2)) {
            cpdm_run_break_text = (("You provided the same response to all " + run_resps.length.toString()) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
            cpdm_space_text = "Press SPACE to end.";
            exp_proceed = false;
            my_loop.addData("cpdm_subReject2", "1key response");
            my_loop.addData("cpdm_subReject2_key", run_resps[0]);
        } else {
            if ((_pj.in_es6("low_vol", cpdm_run_dimension) && (util.sum(cpdm_catch_trials) < 14))) {
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.";
                cpdm_space_text = "Press SPACE to end.";
                exp_proceed = false;
                my_loop.addData("cpdm_subReject3LV", "LV catch fail");
                my_loop.addData("cpdm_subReject3LV_fails", (20 - util.sum(cpdm_catch_trials)));
            } else {
                if ((condition_runs1.thisN === 1)) {
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!";
                    cpdm_space_text = "Press SPACE to continue.";
                } else {
                    cpdm_run_break_text = (("Please feel free to take a short break. \n \n As you begin Block " + run_counter.toString()) + ", read the possible monetary values of each option carefully as they may have changed.");
                    cpdm_space_text = "Press SPACE to continue.";
                }
            }
        }
    }
    
    cpdm_run_break1_txt.setText(cpdm_run_break_text);
    cpdm_run_break1_space_txt.setText(cpdm_space_text);
    cpdm_run_break1_resp.keys = undefined;
    cpdm_run_break1_resp.rt = undefined;
    _cpdm_run_break1_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_run_break1Components = [];
    cpdm_run_break1Components.push(cpdm_run_break1_title_txt);
    cpdm_run_break1Components.push(cpdm_run_break1_txt);
    cpdm_run_break1Components.push(cpdm_run_break1_space_txt);
    cpdm_run_break1Components.push(cpdm_run_break1_resp);
    
    for (const thisComponent of cpdm_run_break1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_run_break1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_run_break1' ---
    // get current time
    t = cpdm_run_break1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_run_break1_title_txt* updates
    if (t >= 0.0 && cpdm_run_break1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break1_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break1_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break1_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break1_txt* updates
    if (t >= 0.0 && cpdm_run_break1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break1_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break1_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break1_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break1_space_txt* updates
    if (t >= 0.0 && cpdm_run_break1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break1_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break1_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break1_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break1_resp* updates
    if (t >= 0.0 && cpdm_run_break1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break1_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_run_break1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break1_resp.clearEvents(); });
    }
    
    if (cpdm_run_break1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_run_break1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_run_break1_resp_allKeys = _cpdm_run_break1_resp_allKeys.concat(theseKeys);
      if (_cpdm_run_break1_resp_allKeys.length > 0) {
        cpdm_run_break1_resp.keys = _cpdm_run_break1_resp_allKeys[_cpdm_run_break1_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_run_break1_resp.rt = _cpdm_run_break1_resp_allKeys[_cpdm_run_break1_resp_allKeys.length - 1].rt;
        cpdm_run_break1_resp.duration = _cpdm_run_break1_resp_allKeys[_cpdm_run_break1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_run_break1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_run_break1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_run_break1' ---
    for (const thisComponent of cpdm_run_break1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_run_break1.stopped', globalClock.getTime());
    cpdm_run_break1_resp.stop();
    // the Routine "cpdm_run_break1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var idm_term_checkComponents;
function idm_term_checkRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_term_check' ---
    t = 0;
    idm_term_checkClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_term_check.started', globalClock.getTime());
    // Run 'Begin Routine' code from idm_term_check_code
    if ((exp_proceed === false)) {
        psychoJS.quit();
    }
    // keep track of which components have finished
    idm_term_checkComponents = [];
    
    for (const thisComponent of idm_term_checkComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_term_checkRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_term_check' ---
    // get current time
    t = idm_term_checkClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_term_checkComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_term_checkRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_term_check' ---
    for (const thisComponent of idm_term_checkComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_term_check.stopped', globalClock.getTime());
    // the Routine "idm_term_check" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_practice_loop1_name;
var crdm_questplus_loop_name;
var crdm_practice_loop2_name;
var crdm_loop_name;
var crdm_namer1Components;
function crdm_namer1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_namer1' ---
    t = 0;
    crdm_namer1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_namer1.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_namer_code
    crdm_practice_loop1_name = "crdm_pract1_trials1";
    crdm_questplus_loop_name = "crdm_qp_trials1";
    crdm_practice_loop2_name = "crdm_pract2_trials1";
    crdm_loop_name = "crdm_trials1";
    // keep track of which components have finished
    crdm_namer1Components = [];
    
    for (const thisComponent of crdm_namer1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_namer1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_namer1' ---
    // get current time
    t = crdm_namer1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_namer1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_namer1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_namer1' ---
    for (const thisComponent of crdm_namer1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_namer1.stopped', globalClock.getTime());
    // the Routine "crdm_namer1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr1_resp_allKeys;
var crdm_instr1Components;
function crdm_instr1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr1' ---
    t = 0;
    crdm_instr1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr1.started', globalClock.getTime());
    crdm_instr1_resp.keys = undefined;
    crdm_instr1_resp.rt = undefined;
    _crdm_instr1_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr1Components = [];
    crdm_instr1Components.push(crdm_instr1_title_txt);
    crdm_instr1Components.push(crdm_instr1_txt);
    crdm_instr1Components.push(crdm_instr1_space_txt);
    crdm_instr1Components.push(crdm_instr1_resp);
    
    for (const thisComponent of crdm_instr1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr1' ---
    // get current time
    t = crdm_instr1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr1_title_txt* updates
    if (t >= 0.0 && crdm_instr1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr1_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr1_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr1_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr1_txt* updates
    if (t >= 0.0 && crdm_instr1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr1_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr1_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr1_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr1_space_txt* updates
    if (t >= 0.0 && crdm_instr1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr1_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr1_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr1_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr1_resp* updates
    if (t >= 0.0 && crdm_instr1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr1_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr1_resp.clearEvents(); });
    }
    
    if (crdm_instr1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr1_resp_allKeys = _crdm_instr1_resp_allKeys.concat(theseKeys);
      if (_crdm_instr1_resp_allKeys.length > 0) {
        crdm_instr1_resp.keys = _crdm_instr1_resp_allKeys[_crdm_instr1_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr1_resp.rt = _crdm_instr1_resp_allKeys[_crdm_instr1_resp_allKeys.length - 1].rt;
        crdm_instr1_resp.duration = _crdm_instr1_resp_allKeys[_crdm_instr1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr1' ---
    for (const thisComponent of crdm_instr1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr1.stopped', globalClock.getTime());
    crdm_instr1_resp.stop();
    // the Routine "crdm_instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr2_resp_allKeys;
var crdm_instr2Components;
function crdm_instr2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr2' ---
    t = 0;
    crdm_instr2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr2.started', globalClock.getTime());
    crdm_instr2_resp.keys = undefined;
    crdm_instr2_resp.rt = undefined;
    _crdm_instr2_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr2Components = [];
    crdm_instr2Components.push(crdm_instr2_lottname_txt);
    crdm_instr2Components.push(crdm_instr2_txt);
    crdm_instr2Components.push(crdm_instr2_img);
    crdm_instr2Components.push(crdm_instr2_lott0_txt);
    crdm_instr2Components.push(crdm_instr2_lott20_txt);
    crdm_instr2Components.push(crdm_instr2_space_txt);
    crdm_instr2Components.push(crdm_instr2_resp);
    
    for (const thisComponent of crdm_instr2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr2' ---
    // get current time
    t = crdm_instr2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr2_lottname_txt* updates
    if (t >= 0.0 && crdm_instr2_lottname_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_lottname_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_lottname_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_lottname_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_txt* updates
    if (t >= 0.0 && crdm_instr2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_img* updates
    if (t >= 0.0 && crdm_instr2_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_lott0_txt* updates
    if (t >= 0.0 && crdm_instr2_lott0_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_lott0_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_lott0_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_lott0_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_lott20_txt* updates
    if (t >= 0.0 && crdm_instr2_lott20_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_lott20_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_lott20_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_lott20_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_space_txt* updates
    if (t >= 0.0 && crdm_instr2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr2_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr2_resp* updates
    if (t >= 0.0 && crdm_instr2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr2_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr2_resp.clearEvents(); });
    }
    
    if (crdm_instr2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr2_resp_allKeys = _crdm_instr2_resp_allKeys.concat(theseKeys);
      if (_crdm_instr2_resp_allKeys.length > 0) {
        crdm_instr2_resp.keys = _crdm_instr2_resp_allKeys[_crdm_instr2_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr2_resp.rt = _crdm_instr2_resp_allKeys[_crdm_instr2_resp_allKeys.length - 1].rt;
        crdm_instr2_resp.duration = _crdm_instr2_resp_allKeys[_crdm_instr2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr2' ---
    for (const thisComponent of crdm_instr2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr2.stopped', globalClock.getTime());
    crdm_instr2_resp.stop();
    // the Routine "crdm_instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr3_resp_allKeys;
var crdm_instr3Components;
function crdm_instr3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr3' ---
    t = 0;
    crdm_instr3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr3.started', globalClock.getTime());
    crdm_instr3_resp.keys = undefined;
    crdm_instr3_resp.rt = undefined;
    _crdm_instr3_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr3Components = [];
    crdm_instr3Components.push(crdm_instr3_lottname_txt);
    crdm_instr3Components.push(crdm_instr3_txt);
    crdm_instr3Components.push(crdm_instr3_img);
    crdm_instr3Components.push(crdm_instr3_lott0_txt);
    crdm_instr3Components.push(crdm_instr3_lott20_txt);
    crdm_instr3Components.push(crdm_instr3_space_txt);
    crdm_instr3Components.push(crdm_instr3_resp);
    
    for (const thisComponent of crdm_instr3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr3' ---
    // get current time
    t = crdm_instr3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr3_lottname_txt* updates
    if (t >= 0.0 && crdm_instr3_lottname_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_lottname_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_lottname_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_lottname_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_txt* updates
    if (t >= 0.0 && crdm_instr3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_img* updates
    if (t >= 0.0 && crdm_instr3_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_lott0_txt* updates
    if (t >= 0.0 && crdm_instr3_lott0_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_lott0_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_lott0_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_lott0_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_lott20_txt* updates
    if (t >= 0.0 && crdm_instr3_lott20_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_lott20_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_lott20_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_lott20_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_space_txt* updates
    if (t >= 0.0 && crdm_instr3_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr3_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr3_resp* updates
    if (t >= 0.0 && crdm_instr3_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr3_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr3_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr3_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr3_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr3_resp.clearEvents(); });
    }
    
    if (crdm_instr3_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr3_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr3_resp_allKeys = _crdm_instr3_resp_allKeys.concat(theseKeys);
      if (_crdm_instr3_resp_allKeys.length > 0) {
        crdm_instr3_resp.keys = _crdm_instr3_resp_allKeys[_crdm_instr3_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr3_resp.rt = _crdm_instr3_resp_allKeys[_crdm_instr3_resp_allKeys.length - 1].rt;
        crdm_instr3_resp.duration = _crdm_instr3_resp_allKeys[_crdm_instr3_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr3' ---
    for (const thisComponent of crdm_instr3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr3.stopped', globalClock.getTime());
    crdm_instr3_resp.stop();
    // the Routine "crdm_instr3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr4_resp_allKeys;
var crdm_instr4Components;
function crdm_instr4RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr4' ---
    t = 0;
    crdm_instr4Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr4.started', globalClock.getTime());
    crdm_instr4_resp.keys = undefined;
    crdm_instr4_resp.rt = undefined;
    _crdm_instr4_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr4Components = [];
    crdm_instr4Components.push(crdm_instr4_lottname_txt);
    crdm_instr4Components.push(crdm_instr4_txt);
    crdm_instr4Components.push(crdm_instr4_img);
    crdm_instr4Components.push(crdm_instr4_lott0_txt);
    crdm_instr4Components.push(crdm_instr4_lott20_txt);
    crdm_instr4Components.push(crdm_instr4_space_txt);
    crdm_instr4Components.push(crdm_instr4_resp);
    
    for (const thisComponent of crdm_instr4Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr4RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr4' ---
    // get current time
    t = crdm_instr4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr4_lottname_txt* updates
    if (t >= 0.0 && crdm_instr4_lottname_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_lottname_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_lottname_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_lottname_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_txt* updates
    if (t >= 0.0 && crdm_instr4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_img* updates
    if (t >= 0.0 && crdm_instr4_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_lott0_txt* updates
    if (t >= 0.0 && crdm_instr4_lott0_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_lott0_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_lott0_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_lott0_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_lott20_txt* updates
    if (t >= 0.0 && crdm_instr4_lott20_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_lott20_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_lott20_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_lott20_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_space_txt* updates
    if (t >= 0.0 && crdm_instr4_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr4_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr4_resp* updates
    if (t >= 0.0 && crdm_instr4_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr4_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr4_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr4_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr4_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr4_resp.clearEvents(); });
    }
    
    if (crdm_instr4_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr4_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr4_resp_allKeys = _crdm_instr4_resp_allKeys.concat(theseKeys);
      if (_crdm_instr4_resp_allKeys.length > 0) {
        crdm_instr4_resp.keys = _crdm_instr4_resp_allKeys[_crdm_instr4_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr4_resp.rt = _crdm_instr4_resp_allKeys[_crdm_instr4_resp_allKeys.length - 1].rt;
        crdm_instr4_resp.duration = _crdm_instr4_resp_allKeys[_crdm_instr4_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr4Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr4RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr4' ---
    for (const thisComponent of crdm_instr4Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr4.stopped', globalClock.getTime());
    crdm_instr4_resp.stop();
    // the Routine "crdm_instr4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr5_resp_allKeys;
var crdm_instr5Components;
function crdm_instr5RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr5' ---
    t = 0;
    crdm_instr5Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr5.started', globalClock.getTime());
    crdm_instr5_resp.keys = undefined;
    crdm_instr5_resp.rt = undefined;
    _crdm_instr5_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr5Components = [];
    crdm_instr5Components.push(crdm_instr5_txt);
    crdm_instr5Components.push(crdm_instr5_img);
    crdm_instr5Components.push(crdm_instr5_lott_top_txt);
    crdm_instr5Components.push(crdm_instr5_lott_bot_txt);
    crdm_instr5Components.push(crdm_instr5_sure_txt);
    crdm_instr5Components.push(crdm_instr5_space_txt);
    crdm_instr5Components.push(crdm_instr5_resp);
    
    for (const thisComponent of crdm_instr5Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr5RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr5' ---
    // get current time
    t = crdm_instr5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr5_txt* updates
    if (t >= 0.0 && crdm_instr5_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_img* updates
    if (t >= 0.0 && crdm_instr5_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_lott_top_txt* updates
    if (t >= 0.0 && crdm_instr5_lott_top_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_lott_top_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_lott_top_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_lott_top_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_lott_bot_txt* updates
    if (t >= 0.0 && crdm_instr5_lott_bot_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_lott_bot_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_lott_bot_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_lott_bot_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_sure_txt* updates
    if (t >= 0.0 && crdm_instr5_sure_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_sure_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_sure_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_sure_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_space_txt* updates
    if (t >= 0.0 && crdm_instr5_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr5_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr5_resp* updates
    if (t >= 0.0 && crdm_instr5_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr5_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr5_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr5_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr5_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr5_resp.clearEvents(); });
    }
    
    if (crdm_instr5_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr5_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr5_resp_allKeys = _crdm_instr5_resp_allKeys.concat(theseKeys);
      if (_crdm_instr5_resp_allKeys.length > 0) {
        crdm_instr5_resp.keys = _crdm_instr5_resp_allKeys[_crdm_instr5_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr5_resp.rt = _crdm_instr5_resp_allKeys[_crdm_instr5_resp_allKeys.length - 1].rt;
        crdm_instr5_resp.duration = _crdm_instr5_resp_allKeys[_crdm_instr5_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr5Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr5RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr5' ---
    for (const thisComponent of crdm_instr5Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr5.stopped', globalClock.getTime());
    crdm_instr5_resp.stop();
    // the Routine "crdm_instr5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr6_resp_allKeys;
var crdm_instr6Components;
function crdm_instr6RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr6' ---
    t = 0;
    crdm_instr6Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr6.started', globalClock.getTime());
    crdm_instr6_resp.keys = undefined;
    crdm_instr6_resp.rt = undefined;
    _crdm_instr6_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr6Components = [];
    crdm_instr6Components.push(crdm_instr6_title_txt);
    crdm_instr6Components.push(crdm_instr6_txt);
    crdm_instr6Components.push(crdm_instr6_img);
    crdm_instr6Components.push(crdm_instr6_space_txt);
    crdm_instr6Components.push(crdm_instr6_resp);
    
    for (const thisComponent of crdm_instr6Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr6RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr6' ---
    // get current time
    t = crdm_instr6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr6_title_txt* updates
    if (t >= 0.0 && crdm_instr6_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr6_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr6_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr6_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr6_txt* updates
    if (t >= 0.0 && crdm_instr6_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr6_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr6_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr6_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr6_img* updates
    if (t >= 0.0 && crdm_instr6_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr6_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr6_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr6_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr6_space_txt* updates
    if (t >= 0.0 && crdm_instr6_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr6_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr6_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr6_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr6_resp* updates
    if (t >= 0.0 && crdm_instr6_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr6_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr6_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr6_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr6_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr6_resp.clearEvents(); });
    }
    
    if (crdm_instr6_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr6_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr6_resp_allKeys = _crdm_instr6_resp_allKeys.concat(theseKeys);
      if (_crdm_instr6_resp_allKeys.length > 0) {
        crdm_instr6_resp.keys = _crdm_instr6_resp_allKeys[_crdm_instr6_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr6_resp.rt = _crdm_instr6_resp_allKeys[_crdm_instr6_resp_allKeys.length - 1].rt;
        crdm_instr6_resp.duration = _crdm_instr6_resp_allKeys[_crdm_instr6_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr6Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr6RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr6' ---
    for (const thisComponent of crdm_instr6Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr6.stopped', globalClock.getTime());
    crdm_instr6_resp.stop();
    // the Routine "crdm_instr6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_instr7_resp_allKeys;
var crdm_instr7Components;
function crdm_instr7RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_instr7' ---
    t = 0;
    crdm_instr7Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_instr7.started', globalClock.getTime());
    crdm_instr7_resp.keys = undefined;
    crdm_instr7_resp.rt = undefined;
    _crdm_instr7_resp_allKeys = [];
    // keep track of which components have finished
    crdm_instr7Components = [];
    crdm_instr7Components.push(crdm_instr7_title_txt);
    crdm_instr7Components.push(crdm_instr7_txt);
    crdm_instr7Components.push(crdm_instr7_img);
    crdm_instr7Components.push(crdm_instr7_space_txt);
    crdm_instr7Components.push(crdm_instr7_resp);
    
    for (const thisComponent of crdm_instr7Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_instr7RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_instr7' ---
    // get current time
    t = crdm_instr7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_instr7_title_txt* updates
    if (t >= 0.0 && crdm_instr7_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr7_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr7_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr7_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr7_txt* updates
    if (t >= 0.0 && crdm_instr7_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr7_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr7_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr7_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr7_img* updates
    if (t >= 0.0 && crdm_instr7_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr7_img.tStart = t;  // (not accounting for frame time here)
      crdm_instr7_img.frameNStart = frameN;  // exact frame index
      
      crdm_instr7_img.setAutoDraw(true);
    }
    
    
    // *crdm_instr7_space_txt* updates
    if (t >= 0.0 && crdm_instr7_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr7_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_instr7_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_instr7_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_instr7_resp* updates
    if (t >= 0.0 && crdm_instr7_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_instr7_resp.tStart = t;  // (not accounting for frame time here)
      crdm_instr7_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_instr7_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr7_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_instr7_resp.clearEvents(); });
    }
    
    if (crdm_instr7_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_instr7_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_instr7_resp_allKeys = _crdm_instr7_resp_allKeys.concat(theseKeys);
      if (_crdm_instr7_resp_allKeys.length > 0) {
        crdm_instr7_resp.keys = _crdm_instr7_resp_allKeys[_crdm_instr7_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_instr7_resp.rt = _crdm_instr7_resp_allKeys[_crdm_instr7_resp_allKeys.length - 1].rt;
        crdm_instr7_resp.duration = _crdm_instr7_resp_allKeys[_crdm_instr7_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_instr7Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_instr7RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_instr7' ---
    for (const thisComponent of crdm_instr7Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_instr7.stopped', globalClock.getTime());
    crdm_instr7_resp.stop();
    // the Routine "crdm_instr7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_warn1_resp_allKeys;
var crdm_warnComponents;
function crdm_warnRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_warn' ---
    t = 0;
    crdm_warnClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_warn.started', globalClock.getTime());
    crdm_warn1_resp.keys = undefined;
    crdm_warn1_resp.rt = undefined;
    _crdm_warn1_resp_allKeys = [];
    // keep track of which components have finished
    crdm_warnComponents = [];
    crdm_warnComponents.push(crdm_warn1_title_txt);
    crdm_warnComponents.push(crdm_warn1_txt);
    crdm_warnComponents.push(crdm_warn1_space_txt);
    crdm_warnComponents.push(crdm_warn1_resp);
    
    for (const thisComponent of crdm_warnComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_warnRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_warn' ---
    // get current time
    t = crdm_warnClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_warn1_title_txt* updates
    if (t >= 0.0 && crdm_warn1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_warn1_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_warn1_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_warn1_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_warn1_txt* updates
    if (t >= 0.0 && crdm_warn1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_warn1_txt.tStart = t;  // (not accounting for frame time here)
      crdm_warn1_txt.frameNStart = frameN;  // exact frame index
      
      crdm_warn1_txt.setAutoDraw(true);
    }
    
    
    // *crdm_warn1_space_txt* updates
    if (t >= 0.0 && crdm_warn1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_warn1_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_warn1_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_warn1_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_warn1_resp* updates
    if (t >= 0.0 && crdm_warn1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_warn1_resp.tStart = t;  // (not accounting for frame time here)
      crdm_warn1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_warn1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_warn1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_warn1_resp.clearEvents(); });
    }
    
    if (crdm_warn1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_warn1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_warn1_resp_allKeys = _crdm_warn1_resp_allKeys.concat(theseKeys);
      if (_crdm_warn1_resp_allKeys.length > 0) {
        crdm_warn1_resp.keys = _crdm_warn1_resp_allKeys[_crdm_warn1_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_warn1_resp.rt = _crdm_warn1_resp_allKeys[_crdm_warn1_resp_allKeys.length - 1].rt;
        crdm_warn1_resp.duration = _crdm_warn1_resp_allKeys[_crdm_warn1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_warnComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_warnRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_warn' ---
    for (const thisComponent of crdm_warnComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_warn.stopped', globalClock.getTime());
    crdm_warn1_resp.stop();
    // the Routine "crdm_warn" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_pract1_instr_key_allKeys;
var crdm_pract1_instrComponents;
function crdm_pract1_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract1_instr' ---
    t = 0;
    crdm_pract1_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract1_instr.started', globalClock.getTime());
    crdm_pract1_instr_key.keys = undefined;
    crdm_pract1_instr_key.rt = undefined;
    _crdm_pract1_instr_key_allKeys = [];
    // keep track of which components have finished
    crdm_pract1_instrComponents = [];
    crdm_pract1_instrComponents.push(crdm_pract1_instr_name_txt);
    crdm_pract1_instrComponents.push(crdm_pract1_instr_txt);
    crdm_pract1_instrComponents.push(crdm_pract1_instr_space_txt);
    crdm_pract1_instrComponents.push(crdm_pract1_instr_key);
    
    for (const thisComponent of crdm_pract1_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract1_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract1_instr' ---
    // get current time
    t = crdm_pract1_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract1_instr_name_txt* updates
    if (t >= 0.0 && crdm_pract1_instr_name_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_instr_name_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_instr_name_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_instr_name_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract1_instr_txt* updates
    if (t >= 0.0 && crdm_pract1_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_instr_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_instr_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_instr_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract1_instr_space_txt* updates
    if (t >= 0.0 && crdm_pract1_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract1_instr_key* updates
    if (t >= 0.0 && crdm_pract1_instr_key.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_instr_key.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_instr_key.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_pract1_instr_key.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract1_instr_key.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract1_instr_key.clearEvents(); });
    }
    
    if (crdm_pract1_instr_key.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_pract1_instr_key.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_pract1_instr_key_allKeys = _crdm_pract1_instr_key_allKeys.concat(theseKeys);
      if (_crdm_pract1_instr_key_allKeys.length > 0) {
        crdm_pract1_instr_key.keys = _crdm_pract1_instr_key_allKeys[_crdm_pract1_instr_key_allKeys.length - 1].name;  // just the last key pressed
        crdm_pract1_instr_key.rt = _crdm_pract1_instr_key_allKeys[_crdm_pract1_instr_key_allKeys.length - 1].rt;
        crdm_pract1_instr_key.duration = _crdm_pract1_instr_key_allKeys[_crdm_pract1_instr_key_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract1_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract1_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract1_instr' ---
    for (const thisComponent of crdm_pract1_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract1_instr.stopped', globalClock.getTime());
    crdm_pract1_instr_key.stop();
    // the Routine "crdm_pract1_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_init_fixComponents;
function crdm_init_fixRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_init_fix' ---
    t = 0;
    crdm_init_fixClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_init_fix.started', globalClock.getTime());
    // keep track of which components have finished
    crdm_init_fixComponents = [];
    crdm_init_fixComponents.push(crdm_init_fix_poly);
    
    for (const thisComponent of crdm_init_fixComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_init_fixRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_init_fix' ---
    // get current time
    t = crdm_init_fixClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_init_fix_poly* updates
    if (t >= 0.0 && crdm_init_fix_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_init_fix_poly.tStart = t;  // (not accounting for frame time here)
      crdm_init_fix_poly.frameNStart = frameN;  // exact frame index
      
      crdm_init_fix_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_init_fix_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_init_fix_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_init_fixComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_init_fixRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_init_fix' ---
    for (const thisComponent of crdm_init_fixComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_init_fix.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_idx1;
var _crdm_pract1_trial_resp_allKeys;
var crdm_pract1_trialComponents;
function crdm_pract1_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract1_trial' ---
    t = 0;
    crdm_pract1_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract1_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract1_trial_code
    my_loop = eval(crdm_practice_loop1_name);
    
    crdm_idx1 = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    crdm_sure_pos1 = crdm_pos1[crdm_idx1];
    crdm_sure_resp1 = crdm_resp1[crdm_idx1];
    crdm_pract1_trial_img.setImage(("crdm/" + crdm_img1));
    crdm_pract1_trial_lott_top_txt.setText(("$" + format(crdm_lott_top1).toString()).toString());
    crdm_pract1_trial_lott_bot_txt.setText(("$" + format(crdm_lott_bot1).toString()).toString());
    crdm_pract1_trial_sure_amt_txt.setPos(crdm_sure_pos1);
    crdm_pract1_trial_sure_amt_txt.setText(("$" + format(crdm_sure_amt1).toString()).toString());
    crdm_pract1_trial_resp.keys = undefined;
    crdm_pract1_trial_resp.rt = undefined;
    _crdm_pract1_trial_resp_allKeys = [];
    // keep track of which components have finished
    crdm_pract1_trialComponents = [];
    crdm_pract1_trialComponents.push(crdm_pract1_trial_img);
    crdm_pract1_trialComponents.push(crdm_pract1_trial_lott_top_txt);
    crdm_pract1_trialComponents.push(crdm_pract1_trial_lott_bot_txt);
    crdm_pract1_trialComponents.push(crdm_pract1_trial_sure_amt_txt);
    crdm_pract1_trialComponents.push(GRFX_fix4);
    crdm_pract1_trialComponents.push(crdm_pract1_trial_cue);
    crdm_pract1_trialComponents.push(crdm_pract1_trial_resp);
    
    for (const thisComponent of crdm_pract1_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract1_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract1_trial' ---
    // get current time
    t = crdm_pract1_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract1_trial_img* updates
    if (t >= 0.0 && crdm_pract1_trial_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_img.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_img.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_trial_img.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_img.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_img.setAutoDraw(false);
    }
    
    // *crdm_pract1_trial_lott_top_txt* updates
    if (t >= 0.0 && crdm_pract1_trial_lott_top_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_lott_top_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_lott_top_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_trial_lott_top_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_lott_top_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_lott_top_txt.setAutoDraw(false);
    }
    
    // *crdm_pract1_trial_lott_bot_txt* updates
    if (t >= 0.0 && crdm_pract1_trial_lott_bot_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_lott_bot_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_lott_bot_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_trial_lott_bot_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_lott_bot_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_lott_bot_txt.setAutoDraw(false);
    }
    
    // *crdm_pract1_trial_sure_amt_txt* updates
    if (t >= 0.0 && crdm_pract1_trial_sure_amt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_sure_amt_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_sure_amt_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_trial_sure_amt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_sure_amt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_sure_amt_txt.setAutoDraw(false);
    }
    
    // *GRFX_fix4* updates
    if (t >= 3 && GRFX_fix4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix4.tStart = t;  // (not accounting for frame time here)
      GRFX_fix4.frameNStart = frameN;  // exact frame index
      
      GRFX_fix4.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix4.setAutoDraw(false);
    }
    
    // *crdm_pract1_trial_cue* updates
    if (t >= 3 && crdm_pract1_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_cue.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_cue.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_cue.setAutoDraw(false);
    }
    
    // *crdm_pract1_trial_resp* updates
    if (t >= 3 && crdm_pract1_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_trial_resp.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_pract1_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract1_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract1_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_pract1_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_pract1_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _crdm_pract1_trial_resp_allKeys = _crdm_pract1_trial_resp_allKeys.concat(theseKeys);
      if (_crdm_pract1_trial_resp_allKeys.length > 0) {
        crdm_pract1_trial_resp.keys = _crdm_pract1_trial_resp_allKeys[0].name;  // just the first key pressed
        crdm_pract1_trial_resp.rt = _crdm_pract1_trial_resp_allKeys[0].rt;
        crdm_pract1_trial_resp.duration = _crdm_pract1_trial_resp_allKeys[0].duration;
        // was this correct?
        if (crdm_pract1_trial_resp.keys == crdm_sure_resp1) {
            crdm_pract1_trial_resp.corr = 1;
        } else {
            crdm_pract1_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract1_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var crdm_pract1_key;
var crdm_pract1_sure_key;
function crdm_pract1_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract1_trial' ---
    for (const thisComponent of crdm_pract1_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract1_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_pract1_trial_code
    crdm_pract1_key = crdm_pract1_trial_resp.keys;
    crdm_pract1_sure_key = crdm_pract1_trial_resp.corr;
    my_loop.addData("crdm_trial_type", "practice1");
    // was no response the correct answer?!
    if (crdm_pract1_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(crdm_sure_resp1)) {
         crdm_pract1_trial_resp.corr = 1;  // correct non-response
      } else {
         crdm_pract1_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_pract1_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_pract1_trial_resp.keys', crdm_pract1_trial_resp.keys);
    psychoJS.experiment.addData('crdm_pract1_trial_resp.corr', crdm_pract1_trial_resp.corr);
    if (typeof crdm_pract1_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_pract1_trial_resp.rt', crdm_pract1_trial_resp.rt);
        psychoJS.experiment.addData('crdm_pract1_trial_resp.duration', crdm_pract1_trial_resp.duration);
        routineTimer.reset();
        }
    
    crdm_pract1_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract1_feedbackComponents;
function crdm_pract1_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract1_feedback' ---
    t = 0;
    crdm_pract1_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract1_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract1_feedback_code
    if ((crdm_pract1_key === undefined)) {
        crdm_msg1 = "NO RESPONSE";
    } else {
        if (crdm_pract1_sure_key) {
            crdm_msg1 = ("CERTAIN $" + format(crdm_sure_amt1.toString()));
        } else {
            crdm_msg1 = "LOTTERY";
        }
    }
    crdm_pract1_feedback_txt.setText(crdm_msg1);
    // keep track of which components have finished
    crdm_pract1_feedbackComponents = [];
    crdm_pract1_feedbackComponents.push(crdm_pract1_feedback_txt);
    
    for (const thisComponent of crdm_pract1_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract1_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract1_feedback' ---
    // get current time
    t = crdm_pract1_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract1_feedback_txt* updates
    if (t >= 0.0 && crdm_pract1_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract1_feedback_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract1_feedback_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract1_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract1_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract1_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract1_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract1_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract1_feedback' ---
    for (const thisComponent of crdm_pract1_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract1_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_qp_instr_resp_allKeys;
var crdm_qp_instrComponents;
function crdm_qp_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_qp_instr' ---
    t = 0;
    crdm_qp_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_qp_instr.started', globalClock.getTime());
    crdm_qp_instr_resp.keys = undefined;
    crdm_qp_instr_resp.rt = undefined;
    _crdm_qp_instr_resp_allKeys = [];
    // keep track of which components have finished
    crdm_qp_instrComponents = [];
    crdm_qp_instrComponents.push(crdm_qp_instr_title_txt);
    crdm_qp_instrComponents.push(crdm_qp_instr_txt);
    crdm_qp_instrComponents.push(crdm_qp_instr_space_txt);
    crdm_qp_instrComponents.push(crdm_qp_instr_resp);
    
    for (const thisComponent of crdm_qp_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_qp_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_qp_instr' ---
    // get current time
    t = crdm_qp_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_qp_instr_title_txt* updates
    if (t >= 0.0 && crdm_qp_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_qp_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_qp_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_qp_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_qp_instr_txt* updates
    if (t >= 0.0 && crdm_qp_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_qp_instr_txt.tStart = t;  // (not accounting for frame time here)
      crdm_qp_instr_txt.frameNStart = frameN;  // exact frame index
      
      crdm_qp_instr_txt.setAutoDraw(true);
    }
    
    
    // *crdm_qp_instr_space_txt* updates
    if (t >= 0.0 && crdm_qp_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_qp_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_qp_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_qp_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_qp_instr_resp* updates
    if (t >= 0.0 && crdm_qp_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_qp_instr_resp.tStart = t;  // (not accounting for frame time here)
      crdm_qp_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_qp_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_qp_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_qp_instr_resp.clearEvents(); });
    }
    
    if (crdm_qp_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_qp_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_qp_instr_resp_allKeys = _crdm_qp_instr_resp_allKeys.concat(theseKeys);
      if (_crdm_qp_instr_resp_allKeys.length > 0) {
        crdm_qp_instr_resp.keys = _crdm_qp_instr_resp_allKeys[_crdm_qp_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_qp_instr_resp.rt = _crdm_qp_instr_resp_allKeys[_crdm_qp_instr_resp_allKeys.length - 1].rt;
        crdm_qp_instr_resp.duration = _crdm_qp_instr_resp_allKeys[_crdm_qp_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_qp_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_qp_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_qp_instr' ---
    for (const thisComponent of crdm_qp_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_qp_instr.stopped', globalClock.getTime());
    crdm_qp_instr_resp.stop();
    // the Routine "crdm_qp_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_idx_qp;
var crdm_sure_amt_qp;
var crdm_ambiguity;
var crdm_probability;
var crdm_lott_top_qp;
var crdm_lott_bot_qp;
var crdm_img_qp;
var _crdm_questplus_trial_resp_allKeys;
var crdm_questplusComponents;
function crdm_questplusRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_questplus' ---
    t = 0;
    crdm_questplusClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_questplus.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_questplus_JS
    my_loop = eval(crdm_questplus_loop_name);
    crdm_idx_qp = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    crdm_sure_pos_qp = crdm_pos_qp[crdm_idx_qp];
    crdm_sure_resp_qp = crdm_resp_qp[crdm_idx_qp];
    
    if (crdm_domain_type == 'gain') { //GAINS - get ambiguity, probability, and lott top & bottom
        crdm_sure_amt_qp = crdm_gain_stim_space[crdm_contrast_idx_gain][3];
        crdm_ambiguity = crdm_gain_stim_space[crdm_contrast_idx_gain][1];
        if (!crdm_ambiguity) {
            crdm_probability = crdm_gain_stim_space[crdm_contrast_idx_gain][2];
        } else {
            crdm_probability = 0.5;
        }
        if (crdm_nonzero_side == 'top') {
            crdm_lott_top_qp = crdm_gain_stim_space[crdm_contrast_idx_gain][0];
            crdm_lott_bot_qp = 0;
        } else {
            crdm_lott_top_qp = 0;
            crdm_lott_bot_qp = crdm_gain_stim_space[crdm_contrast_idx_gain][0];
        }
    } else { //LOSSES - get ambiguity, probability, and lott top & bottom
        crdm_sure_amt_qp = crdm_loss_stim_space[crdm_contrast_idx_loss][3];
        crdm_ambiguity = crdm_loss_stim_space[crdm_contrast_idx_loss][1];
        if (!crdm_ambiguity) {
            crdm_probability = crdm_loss_stim_space[crdm_contrast_idx_loss][2];
        } else {
            crdm_probability = 0.5;
        }
        if (crdm_nonzero_side == 'top') {
            crdm_lott_top_qp = crdm_loss_stim_space[crdm_contrast_idx_loss][0];
            crdm_lott_bot_qp = 0;
        } else {
            crdm_lott_top_qp = 0;
            crdm_lott_bot_qp = crdm_loss_stim_space[crdm_contrast_idx_loss][0];
        }
    }
    
    if (crdm_ambiguity) { //set current image
        crdm_img_qp = 'ambig_' + parseInt(crdm_ambiguity * 100) + '.bmp';
    } else {
        if (crdm_lott_top_qp != 0) {
            crdm_img_qp = 'risk_red_' + parseInt(crdm_probability * 100) + '.bmp'
        } else {
            crdm_img_qp = 'risk_blue_' + parseInt(crdm_probability * 100) + '.bmp'
        }
    }
    crdm_questplus_img.setImage(("crdm/" + crdm_img_qp));
    crdm_questplus_trial_lott_top_txt.setText(("$" + format(crdm_lott_top_qp).toString()).toString());
    crdm_questplus_trial_lott_bot_txt.setText(("$" + format(crdm_lott_bot_qp).toString()).toString());
    crdm_questplus_trial_sure_amt_txt.setPos(crdm_sure_pos_qp);
    crdm_questplus_trial_sure_amt_txt.setText(("$" + format(crdm_sure_amt_qp).toString()).toString());
    crdm_questplus_trial_resp.keys = undefined;
    crdm_questplus_trial_resp.rt = undefined;
    _crdm_questplus_trial_resp_allKeys = [];
    // keep track of which components have finished
    crdm_questplusComponents = [];
    crdm_questplusComponents.push(crdm_questplus_img);
    crdm_questplusComponents.push(crdm_questplus_trial_lott_top_txt);
    crdm_questplusComponents.push(crdm_questplus_trial_lott_bot_txt);
    crdm_questplusComponents.push(crdm_questplus_trial_sure_amt_txt);
    crdm_questplusComponents.push(GRFX_fix3);
    crdm_questplusComponents.push(crdm_questplus_trial_cue);
    crdm_questplusComponents.push(crdm_questplus_trial_resp);
    
    for (const thisComponent of crdm_questplusComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_questplusRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_questplus' ---
    // get current time
    t = crdm_questplusClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_questplus_img* updates
    if (t >= 0.0 && crdm_questplus_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_img.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_img.frameNStart = frameN;  // exact frame index
      
      crdm_questplus_img.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_img.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_img.setAutoDraw(false);
    }
    
    // *crdm_questplus_trial_lott_top_txt* updates
    if (t >= 0.0 && crdm_questplus_trial_lott_top_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_trial_lott_top_txt.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_trial_lott_top_txt.frameNStart = frameN;  // exact frame index
      
      crdm_questplus_trial_lott_top_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_trial_lott_top_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_trial_lott_top_txt.setAutoDraw(false);
    }
    
    // *crdm_questplus_trial_lott_bot_txt* updates
    if (t >= 0.0 && crdm_questplus_trial_lott_bot_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_trial_lott_bot_txt.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_trial_lott_bot_txt.frameNStart = frameN;  // exact frame index
      
      crdm_questplus_trial_lott_bot_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_trial_lott_bot_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_trial_lott_bot_txt.setAutoDraw(false);
    }
    
    // *crdm_questplus_trial_sure_amt_txt* updates
    if (t >= 0.0 && crdm_questplus_trial_sure_amt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_trial_sure_amt_txt.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_trial_sure_amt_txt.frameNStart = frameN;  // exact frame index
      
      crdm_questplus_trial_sure_amt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_trial_sure_amt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_trial_sure_amt_txt.setAutoDraw(false);
    }
    
    // *GRFX_fix3* updates
    if (t >= 3 && GRFX_fix3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix3.tStart = t;  // (not accounting for frame time here)
      GRFX_fix3.frameNStart = frameN;  // exact frame index
      
      GRFX_fix3.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix3.setAutoDraw(false);
    }
    
    // *crdm_questplus_trial_cue* updates
    if (t >= 3 && crdm_questplus_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_trial_cue.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_trial_cue.frameNStart = frameN;  // exact frame index
      
      crdm_questplus_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_trial_cue.setAutoDraw(false);
    }
    
    // *crdm_questplus_trial_resp* updates
    if (t >= 3 && crdm_questplus_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_questplus_trial_resp.tStart = t;  // (not accounting for frame time here)
      crdm_questplus_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_questplus_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_questplus_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_questplus_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_questplus_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_questplus_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_questplus_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_questplus_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _crdm_questplus_trial_resp_allKeys = _crdm_questplus_trial_resp_allKeys.concat(theseKeys);
      if (_crdm_questplus_trial_resp_allKeys.length > 0) {
        crdm_questplus_trial_resp.keys = _crdm_questplus_trial_resp_allKeys[0].name;  // just the first key pressed
        crdm_questplus_trial_resp.rt = _crdm_questplus_trial_resp_allKeys[0].rt;
        crdm_questplus_trial_resp.duration = _crdm_questplus_trial_resp_allKeys[0].duration;
        // was this correct?
        if (crdm_questplus_trial_resp.keys == crdm_sure_resp_qp) {
            crdm_questplus_trial_resp.corr = 1;
        } else {
            crdm_questplus_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_questplusComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var crdm_qp_key;
var crdm_qp_sure_key;
var crdm_post_mean;
var crdm_post_sd;
function crdm_questplusRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_questplus' ---
    for (const thisComponent of crdm_questplusComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_questplus.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_questplus_JS
    crdm_qp_key = crdm_questplus_trial_resp.keys;
    crdm_qp_sure_key = crdm_questplus_trial_resp.corr;
    
    crdm_response = !crdm_qp_sure_key;
    if (crdm_domain_type == 'gain'){
        // update posterior
        crdm_q_gain.update(crdm_contrast_idx_gain, crdm_response);
        // find next contrast index
        crdm_contrast_idx_gain = crdm_q_gain.next_contrast();
        crdm_post_mean = weighted_avg(crdm_q_gain);
        crdm_post_sd = weighted_sd(crdm_q_gain);
    } else {
        crdm_q_loss.update(crdm_contrast_idx_loss, crdm_response);
        crdm_contrast_idx_loss = crdm_q_loss.next_contrast();
        crdm_post_mean = weighted_avg(crdm_q_loss);
        crdm_post_sd = weighted_sd(crdm_q_loss);
    }
    
    my_loop.addData("crdm_trial_type", "questplus");
    my_loop.addData("crdm_response", crdm_response);
    my_loop.addData("crdm_mean_alpha", crdm_post_mean[0]);
    my_loop.addData("crdm_mean_beta", crdm_post_mean[1]);
    my_loop.addData("crdm_mean_gamma", crdm_post_mean[2]);
    my_loop.addData("crdm_sd_alpha", crdm_post_sd[0]); 
    my_loop.addData("crdm_sd_beta", crdm_post_sd[1]);
    my_loop.addData("crdm_sd_gamma", crdm_post_sd[2]);
    my_loop.addData("crdm_lott_reward", crdm_lott_top_qp + crdm_lott_bot_qp);
    my_loop.addData("crdm_lott_prob", Number.parseInt((crdm_probability * 100)));
    my_loop.addData("crdm_ambig_level", Number.parseInt((crdm_ambiguity * 100)));
    // was no response the correct answer?!
    if (crdm_questplus_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(crdm_sure_resp_qp)) {
         crdm_questplus_trial_resp.corr = 1;  // correct non-response
      } else {
         crdm_questplus_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_questplus_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_questplus_trial_resp.keys', crdm_questplus_trial_resp.keys);
    psychoJS.experiment.addData('crdm_questplus_trial_resp.corr', crdm_questplus_trial_resp.corr);
    if (typeof crdm_questplus_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_questplus_trial_resp.rt', crdm_questplus_trial_resp.rt);
        psychoJS.experiment.addData('crdm_questplus_trial_resp.duration', crdm_questplus_trial_resp.duration);
        routineTimer.reset();
        }
    
    crdm_questplus_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_qp_feedbackComponents;
function crdm_qp_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_qp_feedback' ---
    t = 0;
    crdm_qp_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_qp_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_qp_feedback_code
    if ((crdm_qp_key === undefined)) {
        crdm_msg_qp = "NO RESPONSE";
    } else {
        if (crdm_qp_sure_key) {
            crdm_msg_qp  = ("CERTAIN $" + format(crdm_sure_amt_qp.toString()));
        } else {
            crdm_msg_qp  = "LOTTERY";
        }
    }
    crdm_qp_feedback_txt.setText(crdm_msg_qp);
    // keep track of which components have finished
    crdm_qp_feedbackComponents = [];
    crdm_qp_feedbackComponents.push(crdm_qp_feedback_txt);
    
    for (const thisComponent of crdm_qp_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_qp_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_qp_feedback' ---
    // get current time
    t = crdm_qp_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_qp_feedback_txt* updates
    if (t >= 0.0 && crdm_qp_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_qp_feedback_txt.tStart = t;  // (not accounting for frame time here)
      crdm_qp_feedback_txt.frameNStart = frameN;  // exact frame index
      
      crdm_qp_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_qp_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_qp_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_qp_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_qp_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_qp_feedback' ---
    for (const thisComponent of crdm_qp_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_qp_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_fit_gain;
var crdm_fit_loss;
var alpha_gain;
var alpha_loss;
var beta_gain;
var beta_loss;
var prob;
var amb;
var crdm_steps;
var append_trial;
var lottery2sv;
var round2fiddy;
var safe2sv;
var sort_it;
var sv2money;
var make_sample_sv_ranges;
var crdm_trials_dict;
var generate_trials;
var crdm_schedule_genComponents;
function crdm_schedule_genRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_schedule_gen' ---
    t = 0;
    crdm_schedule_genClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_schedule_gen.started', globalClock.getTime());
    //# because Pavlovia doesn't auto-convert append or extend to push, 
    //#  make the same functions work for any javascript array by affecting the prototype
    Array.prototype.append = Array.prototype.push
    Array.prototype.extend = function(arr){this.push(...arr)};
    
    //# avoid using the "function name(){}" syntax
    //#  to account for Pavlovia's scope problems.
    
    range = function(start_stop, post_stop, step=1) {
        //# create a list sequence with a starting point, stopping point, and step size
        //#  the step size is assumed 1 if not provided
        //#  the first value is considered the stopping point if the second value is not given,
        //#   in which case the starting point is assumed to be 0.
        //#  post_stop is the non-inclusive end point.
        var arr = [];
        if (post_stop != undefined) {
            for (var i = start_stop; i < post_stop; i += step) {
                arr.push(i);
            }
        } else {
            for (var i = 0; i < start_stop; i += step) {
                arr.push(i);
            }
        }
        return arr;
    }
    
    arange = function(start_stop, post_stop, step=1, rounding=2) {
        //# same as range(), but with rounding built-in
        //# create a list sequence with a starting point, stopping point, and step size
        //#  the step size is assumed 1 if not provided
        //#  the first value is considered the stopping point if the second value is not given,
        //#   in which case the starting point is assumed to be 0.
        //#  post_stop is the non-inclusive end point.
        var arr = [];
        if (post_stop != undefined) {
            if (post_stop < start_stop) {
                for (var i = start_stop; i > post_stop; i += step) {
                    arr.push(round(i, rounding))
                } 
            } else {
                for (var i = start_stop; i < post_stop; i += step) {
                    arr.push(round(i, rounding))
                } 
            }
        } else {
            if (start_stop < 0) {
                for (var i = 0; i > start_stop; i += step) {
                    arr.push(round(i, rounding))
                }
            } else {
                for (var i = 0; i < start_stop; i += step) {
                    arr.push(round(i, rounding))
                }
            }
        }
        return arr;
    }
    
    clone = function(arr) {
        //# recursive function to deep copy arrays and dictionaries    
        var loops, tmp;
        //# see if it is an array
        //#  check a couple of things to try to avoid objects with these keys
        if (Array.isArray(arr)) {
            loops = arr;
            tmp = [];
        } else {
            loops = Object.keys(arr);
            tmp = {};
        }
        loops.forEach(function(val) {
            var value;
            //# if the looped items are the array, push() to a list
            if (loops === arr) {
                value = val;
                if (typeof(value) == "object") {
                    //# if the subelement is another complex object, 
                    //#  then clone it as well.
                    tmp.push(clone(value));
                } else {
                    tmp.push(value);
                }
            } else { //# if the looped items are the dictionary
                     //#  add them with the key
                value = arr[val];
                if (typeof(value) == "object") {
                    //# if the subelement is another complex object, 
                    //#  then clone it as well.
                    tmp[val] = clone(value);
                } else {
                    tmp[val] = value;
                }
            }
        })
        return tmp;
    }
    
    sum = function(arr){return arr.reduce((partialSum, a) => partialSum + a, 0)}
    
    
    random = {
        //# contains useful random number generation functions
        "random" : function(start_stop=1, post_stop=undefined, count=1) {
            var results = [];
            range(count).forEach(function() {
                if (post_stop != undefined) {
                    if (post_stop < start_stop) {
                        var tmp = post_stop;
                        post_stop = start_stop;
                        start_stop = tmp;
                    }
                    results.push((start_stop + Math.random() * (post_stop - start_stop)));
                } else {
                    //# if post_stop is not defined, start_stop is the non-inclusive max value.
                    results.push((Math.random() * start_stop));
                }
            });
            if (count == 1)
                return results[0];
                return results;       
        },
        
        "randint" : function(start_stop, post_stop, count=1) {
            var results = [];
            range(count).forEach(function() {
                //# Math.random() never gives exactly 1, so it
                //#  never reaches the provided max value.
                if (post_stop != undefined) {
                    if (post_stop < start_stop) {
                        var tmp = post_stop;
                        post_stop = start_stop;
                        start_stop = tmp;
                    }
                    results.push(parseInt(start_stop + Math.random() * (post_stop - start_stop)));
                } else {
                    //# if post_stop is not defined, start_stop is non-inclusive max value
                    results.push(parseInt(Math.random() * start_stop));
                }
            });
            if (count == 1)
                return results[0];
                return results;
        },
        
        "choice" : function(arr, count=1, with_replacement=true) {
            var results = [];
            if (with_replacement) {
                range(count).forEach(function() {
                    results.push(arr[random.randint(arr.length)]);
                });
            } else {
                //# make shallow copy to choose from.
                //#  you can always clone returned result if you want unique copies,
                //#  and it makes no difference for arrays of primitives 
                //#  (like numeric indices or string keys).
                var tmp = [...arr];
                range(count).forEach(function() {
                    if (tmp.length == 0)
                        //# refill array
                        tmp = [...arr];
                        results.push(tmp.splice(random.randint(tmp.length), 1));
                });
            }
            if (count == 1)
                return results[0];
                return results;
        }
    }
    
    
    
    crdm_fit_gain = weighted_avg(crdm_q_gain) //# parameters for gains
    crdm_fit_loss = weighted_avg(crdm_q_loss) //# parameters for losses
    
    //# global variables
    alpha_gain = crdm_fit_gain[0];
    alpha_loss = crdm_fit_loss[0];
    beta_gain = crdm_fit_gain[1];
    beta_loss = crdm_fit_loss[1];
    prob = 0.5;
    amb = 0; 
    crdm_steps = 4;
    //# domain: gain = 1, loss = -1
    
    append_trial = function(trials, safe_sv, lott_sv, lott, safe, prob, amb, sv_half, domain) {
        //# appends trial info for presentation and output
        trials["crdm_safe_sv"].append(safe_sv);
        trials["crdm_lott_sv"].append(lott_sv);
        trials["crdm_lott"].append(lott);
        trials["crdm_sure_amt"].append(safe);
        trials["crdm_lott_p"].append(prob);
        trials["crdm_amb_lev"].append(amb);
        trials["crdm_delta_sv"].append(lott_sv - safe_sv);
        trials["crdm_domain"].append(domain);
    }
    
    lottery2sv = function(objective_value, alpha_risk_aversion, beta_ambiguity_aversion, probability, ambiguity) {
        //# converts lottery option value from money space --> subjective value space
        //# domain considered where function is called
        return Math.sign(objective_value) * (probability - beta_ambiguity_aversion * (ambiguity/2)) 
               * Math.pow(Math.abs(objective_value), alpha_risk_aversion);
    }
    
    round2fiddy = function(number) {
        //# rounding all money values to nearest $0.50
        return Math.round(number * 2)/2;
    }
    
    safe2sv = function(subjective_value, alpha) { //# deprecated
        //# converts safe option value from money space --> subjective value space
        return Math.sign(subjective_value) * Math.pow(Math.abs(subjective_value), alpha);
    }
    
    sort_it = function(arr) {
        //# sort ascending (used for SVs)
        arr.sort(function(a, b){return a - b});
    }
    
    sv2money = function(subjective_value, domain, alpha, beta, prob, amb) { 
        //# based on whether you provide beta, converts each value in the 
        //#  subjective value (safe & lottery) range --> money spaces
        var money;
        if (beta === undefined) { //# beta isn't used for safe money
            //# compute safe money using inverse of SV formula
            //#  gain - money(V) = 1*SV**1/alpha
            //#  loss - money(V) = -1*SV**1/alpha
            money = round2fiddy(domain * Math.pow(Math.abs(subjective_value), 1/alpha)); 
        } else {
            //# compute lottery money using inverse of SV formula
            //#  gain - money(V) = 1*(SV/P-B*A/2)**1/alpha
            //#  loss - money(V) = -1*(SV/P-B*A/2)**1/alpha
            money = round2fiddy(domain * Math.pow(Math.abs(subjective_value)/(prob - beta * amb/2), 1/alpha));
        }
        //# constrains min and max lottery $ and ensure correct sign for gain/loss
        money = domain * Math.min(50, Math.max(0.5, Math.abs(money)));
        return money
    }
    
    make_sample_sv_ranges = function(domain, alpha, beta, prob, amb, steps) {
        //# calculates SVdeltas and corresponding monetary values
        var sv_max = domain * lottery2sv(50, alpha, beta, prob, amb); //# maximum possible lottery value ($ --> SV space)
        var sv_min = 0; //# domain * safe2sv(0.5, alpha); //#minimum possible lottery value ($ --> SV space)
        var sv_half = sv_max/2; //# SV of trial halfway between 0 and max lottery gain (true center)
        var step_size = (sv_max - sv_min)/(2 * steps - 1);
        var space = arange(sv_min, sv_max + step_size/2, step_size);
        return [space, sv_half];
    }
    
    crdm_trials_dict = {"crdm_safe_sv":[], "crdm_lott_sv":[], "crdm_lott":[], "crdm_sure_amt":[], //# dict for trial variables
                        "crdm_lott_p":[], "crdm_amb_lev":[], "crdm_delta_sv":[], "crdm_domain":[]};
    
    generate_trials = function(trials, domain, alpha, beta, steps) {
        //# creates trial schedule for each domain (gain/loss)
        var amb_space = [0.24, 0.5, 0.74]; //# possible ambiguity values
        var prob_space = [0.13, 0.25, 0.38, 0.5, 0.75]; //# possible probability values
        var trials_per = 9; //# number of trials per unique prob/amb option
        var choice_idxs = [0,1,2,3,3.5,4,5,6,7];
        var delta_idx = range(8); //# index of trials_remaining_per_sv_delta array
    
        prob_space.forEach(function(prob) {
            //# non-ambiguity trials
            var tmp = make_sample_sv_ranges(domain, alpha, beta, prob, 0, steps);
            var svs = tmp[0]; //# get list of SV quadrants
            var sv_half = tmp[1]; //# get SV_half
            range(trials_per).forEach(function(_, tidx) { //# for each of 9 trials per prob
                var choice_idx = choice_idxs[tidx]; //# current sample index
                if (choice_idx != parseInt(choice_idx)) { //# if not an integer
                    var inty = parseInt(choice_idx); //# turn it into integer
                    choice_idx = random.randint(inty, inty + 2); //# randomly sample within two steps
                }
                var subspace_sv = svs[choice_idx]; //# specific random SV for curr quad
                var lott = sv2money(subspace_sv, domain, alpha, beta, prob, 0); //# specific lottery $ for curr quad
                var safe = sv2money(sv_half, domain, alpha); //# specific safe $ for curr quad
                append_trial(trials, sv_half, subspace_sv, lott, safe, prob, 0, sv_half, domain); //# save to trials dict
            });
    
        });
    
        amb_space.forEach(function(amb) {
            //# ambiguity trials
            var tmp = make_sample_sv_ranges(domain, alpha, beta, 0.5, amb, steps);
            var svs = tmp[0]; //# get list of SV quadrants
            var sv_half = tmp[1]; //# get SV_half
            range(trials_per).forEach(function(_, tidx) { //# for each of 9 trials per amb
                var choice_idx = choice_idxs[tidx]; //# current sample index
                if (choice_idx != parseInt(choice_idx)) { //# if not an integer
                    var inty = parseInt(choice_idx); //# turn it into integer
                    choice_idx = random.randint(inty, inty + 2); //# randomly sample within two steps
                }
                var subspace_sv = svs[choice_idx]; //# specific random SV for curr quad
                var lott = sv2money(subspace_sv, domain, alpha, beta, 0.5, amb); //# specific lottery $ for curr quad
                var safe = sv2money(sv_half, domain, alpha); //# specific safe $ for curr quad
                append_trial(trials, sv_half, subspace_sv, lott, safe, 0.5, amb, sv_half, domain); //# save to trials dict
            });
    
        });
    }
    
    //# generate schedule for each domain
    generate_trials(crdm_trials_dict, 1, alpha_gain, beta_gain, crdm_steps); //# gain trials
    //generate_trials(crdm_trials_dict, -1, alpha_loss, beta_loss, crdm_steps); //# loss trials
    // keep track of which components have finished
    crdm_schedule_genComponents = [];
    
    for (const thisComponent of crdm_schedule_genComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_schedule_genRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_schedule_gen' ---
    // get current time
    t = crdm_schedule_genClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_schedule_genComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_schedule_genRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_schedule_gen' ---
    for (const thisComponent of crdm_schedule_genComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_schedule_gen.stopped', globalClock.getTime());
    // the Routine "crdm_schedule_gen" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_pract2_instr_key_allKeys;
var crdm_pract2_instrComponents;
function crdm_pract2_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_instr' ---
    t = 0;
    crdm_pract2_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_instr.started', globalClock.getTime());
    crdm_pract2_instr_key.keys = undefined;
    crdm_pract2_instr_key.rt = undefined;
    _crdm_pract2_instr_key_allKeys = [];
    // keep track of which components have finished
    crdm_pract2_instrComponents = [];
    crdm_pract2_instrComponents.push(crdm_pract2_instr_name_txt);
    crdm_pract2_instrComponents.push(crdm_pract2_instr_txt);
    crdm_pract2_instrComponents.push(crdm_pract2_instr_space_txt);
    crdm_pract2_instrComponents.push(crdm_pract2_instr_key);
    
    for (const thisComponent of crdm_pract2_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract2_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_instr' ---
    // get current time
    t = crdm_pract2_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract2_instr_name_txt* updates
    if (t >= 0.0 && crdm_pract2_instr_name_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_instr_name_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_instr_name_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_instr_name_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract2_instr_txt* updates
    if (t >= 0.0 && crdm_pract2_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_instr_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_instr_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_instr_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract2_instr_space_txt* updates
    if (t >= 0.0 && crdm_pract2_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_pract2_instr_key* updates
    if (t >= 0.0 && crdm_pract2_instr_key.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_instr_key.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_instr_key.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_pract2_instr_key.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_instr_key.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_instr_key.clearEvents(); });
    }
    
    if (crdm_pract2_instr_key.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_pract2_instr_key.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_pract2_instr_key_allKeys = _crdm_pract2_instr_key_allKeys.concat(theseKeys);
      if (_crdm_pract2_instr_key_allKeys.length > 0) {
        crdm_pract2_instr_key.keys = _crdm_pract2_instr_key_allKeys[_crdm_pract2_instr_key_allKeys.length - 1].name;  // just the last key pressed
        crdm_pract2_instr_key.rt = _crdm_pract2_instr_key_allKeys[_crdm_pract2_instr_key_allKeys.length - 1].rt;
        crdm_pract2_instr_key.duration = _crdm_pract2_instr_key_allKeys[_crdm_pract2_instr_key_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract2_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_instr' ---
    for (const thisComponent of crdm_pract2_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_instr.stopped', globalClock.getTime());
    crdm_pract2_instr_key.stop();
    // the Routine "crdm_pract2_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_idx2;
var _crdm_pract2_trial_resp_allKeys;
var crdm_pract2_trialComponents;
function crdm_pract2_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_trial' ---
    t = 0;
    crdm_pract2_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract2_trial_code
    my_loop = eval(crdm_practice_loop2_name);
    crdm_idx2 = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    crdm_sure_pos2 = crdm_pos2[crdm_idx2];
    crdm_sure_resp2 = crdm_resp2[crdm_idx2];
    crdm_pract2_trial_img.setImage(("crdm/" + crdm_img2));
    crdm_pract2_trial_lott_top_txt.setText(("$" + format(crdm_lott_top2).toString()).toString());
    crdm_pract2_trial_lott_bot_txt.setText(("$" + format(crdm_lott_bot2).toString()).toString());
    crdm_pract2_trial_sure_amt_txt.setPos(crdm_sure_pos2);
    crdm_pract2_trial_sure_amt_txt.setText(("$" + format(crdm_sure_amt2).toString()).toString());
    crdm_pract2_trial_resp.keys = undefined;
    crdm_pract2_trial_resp.rt = undefined;
    _crdm_pract2_trial_resp_allKeys = [];
    // keep track of which components have finished
    crdm_pract2_trialComponents = [];
    crdm_pract2_trialComponents.push(crdm_pract2_trial_img);
    crdm_pract2_trialComponents.push(crdm_pract2_trial_lott_top_txt);
    crdm_pract2_trialComponents.push(crdm_pract2_trial_lott_bot_txt);
    crdm_pract2_trialComponents.push(crdm_pract2_trial_sure_amt_txt);
    crdm_pract2_trialComponents.push(GRFX_fix2);
    crdm_pract2_trialComponents.push(crdm_pract2_trial_cue);
    crdm_pract2_trialComponents.push(crdm_pract2_trial_resp);
    
    for (const thisComponent of crdm_pract2_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract2_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_trial' ---
    // get current time
    t = crdm_pract2_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract2_trial_img* updates
    if (t >= 0.0 && crdm_pract2_trial_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_img.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_img.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_trial_img.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_img.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_img.setAutoDraw(false);
    }
    
    // *crdm_pract2_trial_lott_top_txt* updates
    if (t >= 0.0 && crdm_pract2_trial_lott_top_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_lott_top_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_lott_top_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_trial_lott_top_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_lott_top_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_lott_top_txt.setAutoDraw(false);
    }
    
    // *crdm_pract2_trial_lott_bot_txt* updates
    if (t >= 0.0 && crdm_pract2_trial_lott_bot_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_lott_bot_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_lott_bot_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_trial_lott_bot_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_lott_bot_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_lott_bot_txt.setAutoDraw(false);
    }
    
    // *crdm_pract2_trial_sure_amt_txt* updates
    if (t >= 0.0 && crdm_pract2_trial_sure_amt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_sure_amt_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_sure_amt_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_trial_sure_amt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_sure_amt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_sure_amt_txt.setAutoDraw(false);
    }
    
    // *GRFX_fix2* updates
    if (t >= 3 && GRFX_fix2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix2.tStart = t;  // (not accounting for frame time here)
      GRFX_fix2.frameNStart = frameN;  // exact frame index
      
      GRFX_fix2.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix2.setAutoDraw(false);
    }
    
    // *crdm_pract2_trial_cue* updates
    if (t >= 3 && crdm_pract2_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_cue.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_cue.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_cue.setAutoDraw(false);
    }
    
    // *crdm_pract2_trial_resp* updates
    if (t >= 3 && crdm_pract2_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_trial_resp.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_pract2_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_pract2_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_pract2_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _crdm_pract2_trial_resp_allKeys = _crdm_pract2_trial_resp_allKeys.concat(theseKeys);
      if (_crdm_pract2_trial_resp_allKeys.length > 0) {
        crdm_pract2_trial_resp.keys = _crdm_pract2_trial_resp_allKeys[0].name;  // just the first key pressed
        crdm_pract2_trial_resp.rt = _crdm_pract2_trial_resp_allKeys[0].rt;
        crdm_pract2_trial_resp.duration = _crdm_pract2_trial_resp_allKeys[0].duration;
        // was this correct?
        if (crdm_pract2_trial_resp.keys == crdm_sure_resp2) {
            crdm_pract2_trial_resp.corr = 1;
        } else {
            crdm_pract2_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var crdm_pract2_key;
var crdm_pract2_sure_key;
function crdm_pract2_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_trial' ---
    for (const thisComponent of crdm_pract2_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_pract2_trial_code
    crdm_pract2_key = crdm_pract2_trial_resp.keys;
    crdm_pract2_sure_key = crdm_pract2_trial_resp.corr;
    my_loop.addData("crdm_trial_type", "practice2");
    
    // was no response the correct answer?!
    if (crdm_pract2_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(crdm_sure_resp2)) {
         crdm_pract2_trial_resp.corr = 1;  // correct non-response
      } else {
         crdm_pract2_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_pract2_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_pract2_trial_resp.keys', crdm_pract2_trial_resp.keys);
    psychoJS.experiment.addData('crdm_pract2_trial_resp.corr', crdm_pract2_trial_resp.corr);
    if (typeof crdm_pract2_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_pract2_trial_resp.rt', crdm_pract2_trial_resp.rt);
        psychoJS.experiment.addData('crdm_pract2_trial_resp.duration', crdm_pract2_trial_resp.duration);
        routineTimer.reset();
        }
    
    crdm_pract2_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_msg2;
var crdm_pract2_feedbackComponents;
function crdm_pract2_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_feedback' ---
    t = 0;
    crdm_pract2_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract2_feedback_code
    if ((crdm_pract2_key === undefined)) {
        crdm_msg2 = "NO RESPONSE";
    } else {
        if (crdm_pract2_sure_key) {
            crdm_msg2 = ("CERTAIN $" + format(crdm_sure_amt2.toString()));
        } else {
            crdm_msg2 = "LOTTERY";
        }
    }
    
    crdm_pract2_feedback_txt.setText(crdm_msg2);
    // keep track of which components have finished
    crdm_pract2_feedbackComponents = [];
    crdm_pract2_feedbackComponents.push(crdm_pract2_feedback_txt);
    
    for (const thisComponent of crdm_pract2_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract2_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_feedback' ---
    // get current time
    t = crdm_pract2_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract2_feedback_txt* updates
    if (t >= 0.0 && crdm_pract2_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_feedback_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_feedback_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract2_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_feedback' ---
    for (const thisComponent of crdm_pract2_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var conf1_color;
var conf2_color;
var conf3_color;
var conf4_color;
var _crdm_pract2_conf_resp_allKeys;
var crdm_pract2_confComponents;
function crdm_pract2_confRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_conf' ---
    t = 0;
    crdm_pract2_confClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_conf.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract2_conf_code
    if ((crdm_pract2_key === undefined))  {
        continueRoutine = false;
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    crdm_pract2_conf_resp.keys = undefined;
    crdm_pract2_conf_resp.rt = undefined;
    _crdm_pract2_conf_resp_allKeys = [];
    // keep track of which components have finished
    crdm_pract2_confComponents = [];
    crdm_pract2_confComponents.push(crdm_pract2_conf_txt);
    crdm_pract2_confComponents.push(crdm_pract2_conf1);
    crdm_pract2_confComponents.push(crdm_pract2_conf1_txt);
    crdm_pract2_confComponents.push(crdm_pract2_conf2);
    crdm_pract2_confComponents.push(crdm_pract2_conf2_txt);
    crdm_pract2_confComponents.push(crdm_pract2_conf3);
    crdm_pract2_confComponents.push(crdm_pract2_conf3_txt);
    crdm_pract2_confComponents.push(crdm_pract2_conf4);
    crdm_pract2_confComponents.push(crdm_pract2_conf4_txt);
    crdm_pract2_confComponents.push(crdm_pract2_conf_resp);
    
    for (const thisComponent of crdm_pract2_confComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract_conf_key;
function crdm_pract2_confRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_conf' ---
    // get current time
    t = crdm_pract2_confClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from crdm_pract2_conf_code
    crdm_pract_conf_key = crdm_pract2_conf_resp.keys;
    if (!(crdm_pract_conf_key == undefined) && (crdm_pract_conf_key.length === 1)) {
        if ((crdm_pract_conf_key === "1")) {
            conf1_color = "darkgray";
            conf2_color = [0, 0, 0];
            conf3_color = [0, 0, 0];
            conf4_color = [0, 0, 0];
        } else {
            if ((crdm_pract_conf_key === "2")) {
                conf1_color = [0, 0, 0];
                conf2_color = "darkgray";
                conf3_color = [0, 0, 0];
                conf4_color = [0, 0, 0];
            } else {
                if ((crdm_pract_conf_key === "3")) {
                    conf1_color = [0, 0, 0];
                    conf2_color = [0, 0, 0];
                    conf3_color = "darkgray";
                    conf4_color = [0, 0, 0];
                } else {
                    if ((crdm_pract_conf_key === "4")) {
                        conf1_color = [0, 0, 0];
                        conf2_color = [0, 0, 0];
                        conf3_color = [0, 0, 0];
                        conf4_color = "darkgray";
                    }
                }
            }
        }
    }
    
    
    // *crdm_pract2_conf_txt* updates
    if (t >= 0.0 && crdm_pract2_conf_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf_txt.setAutoDraw(false);
    }
    
    if (crdm_pract2_conf1.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_pract2_conf1.setFillColor(new util.Color(conf1_color), false);
    }
    
    // *crdm_pract2_conf1* updates
    if (t >= 0.0 && crdm_pract2_conf1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf1.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf1.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf1.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf1.setAutoDraw(false);
    }
    
    // *crdm_pract2_conf1_txt* updates
    if (t >= 0.0 && crdm_pract2_conf1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf1_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf1_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf1_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf1_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf1_txt.setAutoDraw(false);
    }
    
    if (crdm_pract2_conf2.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_pract2_conf2.setFillColor(new util.Color(conf2_color), false);
    }
    
    // *crdm_pract2_conf2* updates
    if (t >= 0.0 && crdm_pract2_conf2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf2.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf2.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf2.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf2.setAutoDraw(false);
    }
    
    // *crdm_pract2_conf2_txt* updates
    if (t >= 0.0 && crdm_pract2_conf2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf2_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf2_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf2_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf2_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf2_txt.setAutoDraw(false);
    }
    
    if (crdm_pract2_conf3.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_pract2_conf3.setFillColor(new util.Color(conf3_color), false);
    }
    
    // *crdm_pract2_conf3* updates
    if (t >= 0.0 && crdm_pract2_conf3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf3.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf3.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf3.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf3.setAutoDraw(false);
    }
    
    // *crdm_pract2_conf3_txt* updates
    if (t >= 0.0 && crdm_pract2_conf3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf3_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf3_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf3_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf3_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf3_txt.setAutoDraw(false);
    }
    
    if (crdm_pract2_conf4.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_pract2_conf4.setFillColor(new util.Color(conf4_color), false);
    }
    
    // *crdm_pract2_conf4* updates
    if (t >= 0.0 && crdm_pract2_conf4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf4.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf4.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf4.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf4.setAutoDraw(false);
    }
    
    // *crdm_pract2_conf4_txt* updates
    if (t >= 0.0 && crdm_pract2_conf4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf4_txt.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf4_txt.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_conf4_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf4_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf4_txt.setAutoDraw(false);
    }
    
    // *crdm_pract2_conf_resp* updates
    if (t >= 0.0 && crdm_pract2_conf_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_conf_resp.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_conf_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_pract2_conf_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_conf_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_pract2_conf_resp.clearEvents(); });
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_conf_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_conf_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_pract2_conf_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_pract2_conf_resp.getKeys({keyList: ['1', '2', '3', '4'], waitRelease: false});
      _crdm_pract2_conf_resp_allKeys = _crdm_pract2_conf_resp_allKeys.concat(theseKeys);
      if (_crdm_pract2_conf_resp_allKeys.length > 0) {
        crdm_pract2_conf_resp.keys = _crdm_pract2_conf_resp_allKeys[_crdm_pract2_conf_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_pract2_conf_resp.rt = _crdm_pract2_conf_resp_allKeys[_crdm_pract2_conf_resp_allKeys.length - 1].rt;
        crdm_pract2_conf_resp.duration = _crdm_pract2_conf_resp_allKeys[_crdm_pract2_conf_resp_allKeys.length - 1].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_confComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract2_confRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_conf' ---
    for (const thisComponent of crdm_pract2_confComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_conf.stopped', globalClock.getTime());
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    crdm_conf1.setFillColor(new util.Color(conf1_color), false);
    crdm_conf2.setFillColor(new util.Color(conf2_color), false);
    crdm_conf3.setFillColor(new util.Color(conf3_color), false);
    crdm_conf4.setFillColor(new util.Color(conf4_color), false);
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_pract2_conf_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_pract2_conf_resp.keys', crdm_pract2_conf_resp.keys);
    if (typeof crdm_pract2_conf_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_pract2_conf_resp.rt', crdm_pract2_conf_resp.rt);
        psychoJS.experiment.addData('crdm_pract2_conf_resp.duration', crdm_pract2_conf_resp.duration);
        }
    
    crdm_pract2_conf_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract2_iti1Components;
function crdm_pract2_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_iti1' ---
    t = 0;
    crdm_pract2_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract2_iti1_code
    if (!(crdm_pract2_trials1.thisTrialN === undefined) && (crdm_pract2_trials1.thisTrialN === 2)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    crdm_pract2_iti1Components = [];
    crdm_pract2_iti1Components.push(crdm_pract2_iti1_poly);
    
    for (const thisComponent of crdm_pract2_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract2_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_iti1' ---
    // get current time
    t = crdm_pract2_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract2_iti1_poly* updates
    if (t >= 0.0 && crdm_pract2_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_iti1_poly.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_iti1_poly.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract2_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_iti1' ---
    for (const thisComponent of crdm_pract2_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_iti1.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_task_resps;
var crdm_conf_resps;
var crdm_catch_trials;
var crdm_iti_list;
var crdm_s;
var _crdm_trial_instr_resp_allKeys;
var crdm_trial_instrComponents;
function crdm_trial_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_trial_instr' ---
    t = 0;
    crdm_trial_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_trial_instr.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_trial_instr_code
    crdm_task_resps = [];
    crdm_conf_resps = [];
    crdm_catch_trials = [];
    crdm_iti_list = function () {
        var _pj_a = [], _pj_b = util.range(72);
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(random.random());
        }
        return _pj_a;
    }
    .call(this);
    crdm_s = util.sum(crdm_iti_list);
    crdm_iti_list = function () {
        var _pj_a = [], _pj_b = crdm_iti_list;
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(((i * 72) / crdm_s));
        }
        return _pj_a;
    }
    .call(this);
    
    crdm_trial_instr_resp.keys = undefined;
    crdm_trial_instr_resp.rt = undefined;
    _crdm_trial_instr_resp_allKeys = [];
    // keep track of which components have finished
    crdm_trial_instrComponents = [];
    crdm_trial_instrComponents.push(crdm_trial_instr_title_txt);
    crdm_trial_instrComponents.push(crdm_trial_instr_txt);
    crdm_trial_instrComponents.push(crdm_trial_instr_space_txt);
    crdm_trial_instrComponents.push(crdm_trial_instr_resp);
    
    for (const thisComponent of crdm_trial_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_trial_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_trial_instr' ---
    // get current time
    t = crdm_trial_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_trial_instr_title_txt* updates
    if (t >= 0.0 && crdm_trial_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_trial_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_trial_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_trial_instr_txt* updates
    if (t >= 0.0 && crdm_trial_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_instr_txt.tStart = t;  // (not accounting for frame time here)
      crdm_trial_instr_txt.frameNStart = frameN;  // exact frame index
      
      crdm_trial_instr_txt.setAutoDraw(true);
    }
    
    
    // *crdm_trial_instr_space_txt* updates
    if (t >= 0.0 && crdm_trial_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_trial_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_trial_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_trial_instr_resp* updates
    if (t >= 0.0 && crdm_trial_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_instr_resp.tStart = t;  // (not accounting for frame time here)
      crdm_trial_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_trial_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_trial_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_trial_instr_resp.clearEvents(); });
    }
    
    if (crdm_trial_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_trial_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_trial_instr_resp_allKeys = _crdm_trial_instr_resp_allKeys.concat(theseKeys);
      if (_crdm_trial_instr_resp_allKeys.length > 0) {
        crdm_trial_instr_resp.keys = _crdm_trial_instr_resp_allKeys[_crdm_trial_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_trial_instr_resp.rt = _crdm_trial_instr_resp_allKeys[_crdm_trial_instr_resp_allKeys.length - 1].rt;
        crdm_trial_instr_resp.duration = _crdm_trial_instr_resp_allKeys[_crdm_trial_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_trial_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_trial_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_trial_instr' ---
    for (const thisComponent of crdm_trial_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_trial_instr.stopped', globalClock.getTime());
    crdm_trial_instr_resp.stop();
    // the Routine "crdm_trial_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_stop_timer;
var crdm_stopped_time;
var crdm_lott_outcome;
var crdm_conf_key;
var crdm_idx;
var crdm_sure_amt;
var crdm_sure_p;
var crdm_lott_p;
var crdm_amb_lev;
var crdm_domain;
var crdm_deltaSV;
var crdm_safeSV;
var crdm_lottSV;
var crdm_lott_top;
var crdm_lott_bot;
var crdm_img;
var _crdm_trial_resp_allKeys;
var crdm_trialComponents;
function crdm_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_trial' ---
    t = 0;
    crdm_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_trial_JS
    my_loop = eval(crdm_loop_name);
    crdm_stop_timer = null;
    crdm_stopped_time = 0;
    crdm_lott_outcome = 0;
    crdm_conf_key = [];
    crdm_idx = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    crdm_sure_pos = crdm_pos[crdm_idx];
    crdm_sure_resp = crdm_resp[crdm_idx];
    
    //assign QuestPlus generated variables for trial presentation
    crdm_sure_amt = crdm_trials_dict["crdm_sure_amt"][crdm_trial_idx];
    crdm_sure_p = 100;
    crdm_lott_p = crdm_trials_dict["crdm_lott_p"][crdm_trial_idx];
    crdm_amb_lev = crdm_trials_dict["crdm_amb_lev"][crdm_trial_idx];
    crdm_domain = crdm_trials_dict["crdm_domain"][crdm_trial_idx];
    crdm_deltaSV = crdm_trials_dict["crdm_delta_sv"][crdm_trial_idx];
    crdm_safeSV = crdm_trials_dict["crdm_safe_sv"][crdm_trial_idx];
    crdm_lottSV = crdm_trials_dict["crdm_lott_sv"][crdm_trial_idx];
    crdm_lott_top = "";
    crdm_lott_bot = "";
    crdm_img = "";
    
    if (crdm_nonzero_side == "top") {
        crdm_lott_top = crdm_trials_dict["crdm_lott"][crdm_trial_idx];
        crdm_lott_bot = 0;
        if (crdm_trials_dict["crdm_amb_lev"][crdm_trial_idx] != 0) { //check if ambiguity trial
            crdm_img = "ambig_" + parseInt(crdm_trials_dict["crdm_amb_lev"][crdm_trial_idx] * 100) + ".bmp";
        } else { 
            crdm_img = "risk_red_" + parseInt(crdm_trials_dict["crdm_lott_p"][crdm_trial_idx] * 100) + ".bmp";
        }
    } else {
        crdm_lott_top = 0 
        crdm_lott_bot = crdm_trials_dict["crdm_lott"][crdm_trial_idx];
        if (crdm_trials_dict["crdm_amb_lev"][crdm_trial_idx] != 0) { //check if ambiguity trial
            crdm_img = "ambig_" + parseInt(crdm_trials_dict["crdm_amb_lev"][crdm_trial_idx] * 100) + ".bmp";
        } else { 
            crdm_img = "risk_blue_" + parseInt(crdm_trials_dict["crdm_lott_p"][crdm_trial_idx] * 100) + ".bmp";
        }
    }
    
    //save QuestPlus generated variables to output csv
    my_loop.addData("crdm_sure_amt", crdm_sure_amt);
    my_loop.addData("crdm_lott_top", crdm_lott_top);
    my_loop.addData("crdm_lott_bot", crdm_lott_bot);
    my_loop.addData("crdm_sure_p", crdm_sure_p);
    my_loop.addData("crdm_lott_p", crdm_lott_p);
    my_loop.addData("crdm_amb_lev", crdm_amb_lev);
    my_loop.addData("crdm_domain", crdm_domain);
    my_loop.addData("crdm_img", crdm_img);
    my_loop.addData("crdm_delta_SV", crdm_deltaSV); //lottery - safe
    my_loop.addData("crdm_safe_SV", crdm_safeSV); //SV for safe option
    my_loop.addData("crdm_lott_SV", crdm_lottSV); //SV for lottery option
    crdm_trial_img.setImage(("crdm/" + crdm_img));
    crdm_trial_lott_top.setText(("$" + format(crdm_lott_top).toString()).toString());
    crdm_trial_lott_bot.setText(("$" + format(crdm_lott_bot).toString()).toString());
    crdm_trial_sure_amt.setPos(crdm_sure_pos);
    crdm_trial_sure_amt.setText(("$" + format(crdm_sure_amt).toString()).toString());
    crdm_trial_resp.keys = undefined;
    crdm_trial_resp.rt = undefined;
    _crdm_trial_resp_allKeys = [];
    // keep track of which components have finished
    crdm_trialComponents = [];
    crdm_trialComponents.push(crdm_trial_img);
    crdm_trialComponents.push(crdm_trial_lott_top);
    crdm_trialComponents.push(crdm_trial_lott_bot);
    crdm_trialComponents.push(crdm_trial_sure_amt);
    crdm_trialComponents.push(GRFX_fix);
    crdm_trialComponents.push(crdm_trial_cue);
    crdm_trialComponents.push(crdm_trial_resp);
    
    for (const thisComponent of crdm_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_trial' ---
    // get current time
    t = crdm_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from crdm_trial_JS
    if (!(crdm_trial_resp.keys == undefined) && (crdm_trial_resp.keys.length === 1)) {
        if ((crdm_stop_timer === null)) {
            crdm_stop_timer = new util.Clock();
        } else {
            if ((crdm_stop_timer.getTime() >= 0.5)) {
                continueRoutine = false;
            }
        }
    }
    
    // *crdm_trial_img* updates
    if (t >= 0.0 && crdm_trial_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_img.tStart = t;  // (not accounting for frame time here)
      crdm_trial_img.frameNStart = frameN;  // exact frame index
      
      crdm_trial_img.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_img.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_img.setAutoDraw(false);
    }
    
    // *crdm_trial_lott_top* updates
    if (t >= 0.0 && crdm_trial_lott_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_lott_top.tStart = t;  // (not accounting for frame time here)
      crdm_trial_lott_top.frameNStart = frameN;  // exact frame index
      
      crdm_trial_lott_top.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_lott_top.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_lott_top.setAutoDraw(false);
    }
    
    // *crdm_trial_lott_bot* updates
    if (t >= 0.0 && crdm_trial_lott_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_lott_bot.tStart = t;  // (not accounting for frame time here)
      crdm_trial_lott_bot.frameNStart = frameN;  // exact frame index
      
      crdm_trial_lott_bot.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_lott_bot.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_lott_bot.setAutoDraw(false);
    }
    
    // *crdm_trial_sure_amt* updates
    if (t >= 0.0 && crdm_trial_sure_amt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_sure_amt.tStart = t;  // (not accounting for frame time here)
      crdm_trial_sure_amt.frameNStart = frameN;  // exact frame index
      
      crdm_trial_sure_amt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_sure_amt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_sure_amt.setAutoDraw(false);
    }
    
    // *GRFX_fix* updates
    if (t >= 3 && GRFX_fix.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix.tStart = t;  // (not accounting for frame time here)
      GRFX_fix.frameNStart = frameN;  // exact frame index
      
      GRFX_fix.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix.setAutoDraw(false);
    }
    
    // *crdm_trial_cue* updates
    if (t >= 3 && crdm_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_cue.tStart = t;  // (not accounting for frame time here)
      crdm_trial_cue.frameNStart = frameN;  // exact frame index
      
      crdm_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_cue.setAutoDraw(false);
    }
    
    // *crdm_trial_resp* updates
    if (t >= 3 && crdm_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trial_resp.tStart = t;  // (not accounting for frame time here)
      crdm_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _crdm_trial_resp_allKeys = _crdm_trial_resp_allKeys.concat(theseKeys);
      if (_crdm_trial_resp_allKeys.length > 0) {
        crdm_trial_resp.keys = _crdm_trial_resp_allKeys[_crdm_trial_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_trial_resp.rt = _crdm_trial_resp_allKeys[_crdm_trial_resp_allKeys.length - 1].rt;
        crdm_trial_resp.duration = _crdm_trial_resp_allKeys[_crdm_trial_resp_allKeys.length - 1].duration;
        // was this correct?
        if (crdm_trial_resp.keys == crdm_sure_resp) {
            crdm_trial_resp.corr = 1;
        } else {
            crdm_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var lott_outcome;
var crdm_key;
var crdm_sure_key;
function crdm_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_trial' ---
    for (const thisComponent of crdm_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_trial.stopped', globalClock.getTime());
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    
    lott_outcome = 0;
    crdm_key = crdm_trial_resp.keys;
    crdm_sure_key = crdm_trial_resp.corr;
    my_loop.addData("crdm_trial_type", "task");
    if (_pj.in_es6(crdm_key, ["1", "2"])) {
        crdm_task_resps.push(crdm_key);
    }
    
    if ((((crdm_trial_resp.rt) === undefined) || (crdm_trial_resp.rt >= (2 - 0.5)))) {
        crdm_delta_time = 0;
    } else {
        crdm_delta_time = Math.max(0, (2 - (crdm_trial_resp.rt + crdm_stopped_time)));
    }
    if (!(crdm_key === undefined) && (crdm_key.length === 1)) {
        if ((crdm_sure_key === 1)) {
            crdm_bonus_trials.push(["crdm", "sure", crdm_sure_amt, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, (- 1), crdm_nonzero_side, crdm_domain]);
            my_loop.addData("crdm_choice", 0);
            my_loop.addData("crdm_choice2", "sure");
            my_loop.addData("crdm_lott", -1);
            my_loop.addData("crdm_lott2", "sure");
            if ((crdm_domain === 1)) {
                my_loop.addData("crdm_domain2", "gain");
            } else { 
                my.loop.addData("crdm_domain2", "loss");
            }
                
        } else {
            lott_outcome = random_weighted_choice([0, 1], [100 - Number.parseInt(crdm_lott_p * 100), Number.parseInt(crdm_lott_p * 100)]);
            my_loop.addData("crdm_choice", 1);
            my_loop.addData("crdm_choice2", "lott");
            my_loop.addData("crdm_lott", lott_outcome);
            if ((lott_outcome === 1)) {
                my_loop.addData("crdm_lott2", "win");
                if ((crdm_domain === 1)) { //gain
                    my_loop.addData("crdm_domain2", "gain");
                    if ((Number.parseInt(crdm_lott_top) !== 0)) {
                        crdm_bonus_trials.push(["crdm", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                    } else {
                        crdm_bonus_trials.push(["crdm", "lott", crdm_lott_bot, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                    }
                } else {
                    if ((crdm_domain === -1)) { //loss
                        my_loop.addData("crdm_domain2", "loss");
                        if ((Number.parseInt(crdm_lott_top) === 0)) {
                            crdm_bonus_trials.push(["crdm", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                        } else {
                            crdm_bonus_trials.push(["crdm", "lott", crdm_lott_bot, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                        }
                    }
                }
            } else {
                my_loop.addData("crdm_lott2", "lose");
                if ((crdm_domain === 1)) { //gain
                    my_loop.addData("crdm_domain2", "gain");
                    if ((Number.parseInt(crdm_lott_top) === 0)) {
                        crdm_bonus_trials.push(["crdm", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                    } else {
                        crdm_bonus_trials.push(["crdm", "lott", crdm_lott_bot, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                    }
                } else {
                    if ((crdm_domain === -1)) { //loss
                        my_loop.addData("crdm_domain2", "loss");
                        if ((Number.parseInt(crdm_lott_top) < 0)) {
                            crdm_bonus_trials.push(["crdm", "lott", crdm_lott_top, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                        } else {
                            crdm_bonus_trials.push(["crdm", "lott", crdm_lott_bot, crdm_sure_amt, crdm_img, crdm_lott_top, crdm_lott_bot, lott_outcome, crdm_nonzero_side, crdm_domain]);
                        }
                    }
                }
            }
        }
    }
    // was no response the correct answer?!
    if (crdm_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(crdm_sure_resp)) {
         crdm_trial_resp.corr = 1;  // correct non-response
      } else {
         crdm_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_trial_resp.keys', crdm_trial_resp.keys);
    psychoJS.experiment.addData('crdm_trial_resp.corr', crdm_trial_resp.corr);
    if (typeof crdm_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_trial_resp.rt', crdm_trial_resp.rt);
        psychoJS.experiment.addData('crdm_trial_resp.duration', crdm_trial_resp.duration);
        routineTimer.reset();
        }
    
    crdm_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_feedbackComponents;
function crdm_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_feedback' ---
    t = 0;
    crdm_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_feedback_code
    if ((crdm_key === undefined)) {
        crdm_msg = "NO RESPONSE";
    } else {
        if (crdm_sure_key) {
            crdm_msg = ("CERTAIN $" + format(crdm_sure_amt.toString()));
        } else {
            crdm_msg = "LOTTERY";
        }
    }
    crdm_feedback_txt.setText(crdm_msg);
    // keep track of which components have finished
    crdm_feedbackComponents = [];
    crdm_feedbackComponents.push(crdm_feedback_txt);
    
    for (const thisComponent of crdm_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_feedback' ---
    // get current time
    t = crdm_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_feedback_txt* updates
    if (t >= 0.0 && crdm_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_feedback_txt.tStart = t;  // (not accounting for frame time here)
      crdm_feedback_txt.frameNStart = frameN;  // exact frame index
      
      crdm_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_feedback' ---
    for (const thisComponent of crdm_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _crdm_conf_resp_allKeys;
var crdm_confComponents;
function crdm_confRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_conf' ---
    t = 0;
    crdm_confClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_conf.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_conf_code
    if ((crdm_key === undefined)) {
        continueRoutine = false;
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    crdm_conf_resp.keys = undefined;
    crdm_conf_resp.rt = undefined;
    _crdm_conf_resp_allKeys = [];
    // keep track of which components have finished
    crdm_confComponents = [];
    crdm_confComponents.push(crdm_conf_txt);
    crdm_confComponents.push(crdm_conf1);
    crdm_confComponents.push(crdm_conf1_txt);
    crdm_confComponents.push(crdm_conf2);
    crdm_confComponents.push(crdm_conf2_txt);
    crdm_confComponents.push(crdm_conf3);
    crdm_confComponents.push(crdm_conf3_txt);
    crdm_confComponents.push(crdm_conf4);
    crdm_confComponents.push(crdm_conf4_txt);
    crdm_confComponents.push(crdm_conf_resp);
    
    for (const thisComponent of crdm_confComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_confRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_conf' ---
    // get current time
    t = crdm_confClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from crdm_conf_code
    crdm_conf_key = crdm_conf_resp.keys;
    if (!(crdm_conf_key == undefined) && (crdm_conf_key.length === 1)) {
        if ((crdm_conf_key === "1")) {
            conf1_color = "darkgray";
            conf2_color = [0, 0, 0];
            conf3_color = [0, 0, 0];
            conf4_color = [0, 0, 0];
        } else {
            if ((crdm_conf_key === "2")) {
                conf1_color = [0, 0, 0];
                conf2_color = "darkgray";
                conf3_color = [0, 0, 0];
                conf4_color = [0, 0, 0];
            } else {
                if ((crdm_conf_key === "3")) {
                    conf1_color = [0, 0, 0];
                    conf2_color = [0, 0, 0];
                    conf3_color = "darkgray";
                    conf4_color = [0, 0, 0];
                } else {
                    if ((crdm_conf_key === "4")) {
                        conf1_color = [0, 0, 0];
                        conf2_color = [0, 0, 0];
                        conf3_color = [0, 0, 0];
                        conf4_color = "darkgray";
                    }
                }
            }
        }
    }
    
    
    // *crdm_conf_txt* updates
    if (t >= 0.0 && crdm_conf_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf_txt.tStart = t;  // (not accounting for frame time here)
      crdm_conf_txt.frameNStart = frameN;  // exact frame index
      
      crdm_conf_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf_txt.setAutoDraw(false);
    }
    
    if (crdm_conf1.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_conf1.setFillColor(new util.Color(conf1_color), false);
    }
    
    // *crdm_conf1* updates
    if (t >= 0.0 && crdm_conf1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf1.tStart = t;  // (not accounting for frame time here)
      crdm_conf1.frameNStart = frameN;  // exact frame index
      
      crdm_conf1.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf1.setAutoDraw(false);
    }
    
    // *crdm_conf1_txt* updates
    if (t >= 0.0 && crdm_conf1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf1_txt.tStart = t;  // (not accounting for frame time here)
      crdm_conf1_txt.frameNStart = frameN;  // exact frame index
      
      crdm_conf1_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf1_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf1_txt.setAutoDraw(false);
    }
    
    if (crdm_conf2.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_conf2.setFillColor(new util.Color(conf2_color), false);
    }
    
    // *crdm_conf2* updates
    if (t >= 0.0 && crdm_conf2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf2.tStart = t;  // (not accounting for frame time here)
      crdm_conf2.frameNStart = frameN;  // exact frame index
      
      crdm_conf2.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf2.setAutoDraw(false);
    }
    
    // *crdm_conf2_txt* updates
    if (t >= 0.0 && crdm_conf2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf2_txt.tStart = t;  // (not accounting for frame time here)
      crdm_conf2_txt.frameNStart = frameN;  // exact frame index
      
      crdm_conf2_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf2_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf2_txt.setAutoDraw(false);
    }
    
    if (crdm_conf3.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_conf3.setFillColor(new util.Color(conf3_color), false);
    }
    
    // *crdm_conf3* updates
    if (t >= 0.0 && crdm_conf3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf3.tStart = t;  // (not accounting for frame time here)
      crdm_conf3.frameNStart = frameN;  // exact frame index
      
      crdm_conf3.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf3.setAutoDraw(false);
    }
    
    // *crdm_conf3_txt* updates
    if (t >= 0.0 && crdm_conf3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf3_txt.tStart = t;  // (not accounting for frame time here)
      crdm_conf3_txt.frameNStart = frameN;  // exact frame index
      
      crdm_conf3_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf3_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf3_txt.setAutoDraw(false);
    }
    
    if (crdm_conf4.status === PsychoJS.Status.STARTED){ // only update if being drawn
      crdm_conf4.setFillColor(new util.Color(conf4_color), false);
    }
    
    // *crdm_conf4* updates
    if (t >= 0.0 && crdm_conf4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf4.tStart = t;  // (not accounting for frame time here)
      crdm_conf4.frameNStart = frameN;  // exact frame index
      
      crdm_conf4.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf4.setAutoDraw(false);
    }
    
    // *crdm_conf4_txt* updates
    if (t >= 0.0 && crdm_conf4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf4_txt.tStart = t;  // (not accounting for frame time here)
      crdm_conf4_txt.frameNStart = frameN;  // exact frame index
      
      crdm_conf4_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf4_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf4_txt.setAutoDraw(false);
    }
    
    // *crdm_conf_resp* updates
    if (t >= 0.0 && crdm_conf_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_conf_resp.tStart = t;  // (not accounting for frame time here)
      crdm_conf_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_conf_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_conf_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_conf_resp.clearEvents(); });
    }
    
    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_conf_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_conf_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (crdm_conf_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_conf_resp.getKeys({keyList: ['1', '2', '3', '4'], waitRelease: false});
      _crdm_conf_resp_allKeys = _crdm_conf_resp_allKeys.concat(theseKeys);
      if (_crdm_conf_resp_allKeys.length > 0) {
        crdm_conf_resp.keys = _crdm_conf_resp_allKeys[_crdm_conf_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_conf_resp.rt = _crdm_conf_resp_allKeys[_crdm_conf_resp_allKeys.length - 1].rt;
        crdm_conf_resp.duration = _crdm_conf_resp_allKeys[_crdm_conf_resp_allKeys.length - 1].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_confComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_confRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_conf' ---
    for (const thisComponent of crdm_confComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_conf.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_conf_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    if (!(crdm_conf_key == undefined) && (crdm_conf_key.length === 1)) {
        if ((Array.isArray(crdm_conf_key))) {
            if (_pj.in_es6(crdm_conf_key.slice((- 1))[0], ["1", "2", "3", "4"])) {
                crdm_conf_resps.push(crdm_conf_key);
            }
        } else {
            if (_pj.in_es6(crdm_conf_key, ["1", "2", "3", "4"])) {
                crdm_conf_resps.push(crdm_conf_key);
            }
        }
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    crdm_conf1.setFillColor(new util.Color(conf1_color), false);
    crdm_conf2.setFillColor(new util.Color(conf2_color), false);
    crdm_conf3.setFillColor(new util.Color(conf3_color), false);
    crdm_conf4.setFillColor(new util.Color(conf4_color), false);
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(crdm_conf_resp.corr, level);
    }
    psychoJS.experiment.addData('crdm_conf_resp.keys', crdm_conf_resp.keys);
    if (typeof crdm_conf_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('crdm_conf_resp.rt', crdm_conf_resp.rt);
        psychoJS.experiment.addData('crdm_conf_resp.duration', crdm_conf_resp.duration);
        }
    
    crdm_conf_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_iti_time;
var crdm_trials_iti1Components;
function crdm_trials_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_trials_iti1' ---
    t = 0;
    crdm_trials_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_trials_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_trials_iti1_code
    crdm_iti_time = (crdm_iti_list[my_loop.thisIndex] + crdm_delta_time);
    if (!(crdm_trials1.thisTrialN == undefined) && (crdm_trials1.thisTrialN === 71)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    crdm_trials_iti1Components = [];
    crdm_trials_iti1Components.push(crdm_trials_iti1_poly);
    
    for (const thisComponent of crdm_trials_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_trials_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_trials_iti1' ---
    // get current time
    t = crdm_trials_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_trials_iti1_poly* updates
    if (t >= 0.0 && crdm_trials_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trials_iti1_poly.tStart = t;  // (not accounting for frame time here)
      crdm_trials_iti1_poly.frameNStart = frameN;  // exact frame index
      
      crdm_trials_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + crdm_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trials_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trials_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_trials_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_trials_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_trials_iti1' ---
    for (const thisComponent of crdm_trials_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_trials_iti1.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_trials_iti1_code
    my_loop.addData("crdm_delta_time", crdm_delta_time);
    my_loop.addData("crdm_iti_time", crdm_iti_time);
    
    // the Routine "crdm_trials_iti1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_unique_resps;
var crdm_unique_count;
var _crdm_end_resp_allKeys;
var crdm_endComponents;
function crdm_endRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_end' ---
    t = 0;
    crdm_endClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_end.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_end_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    crdm_unique_resps = [];
    crdm_unique_count = 0;
    for (var i, _pj_c = 0, _pj_a = crdm_task_resps, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        if ((! _pj.in_es6(i, crdm_unique_resps))) {
            crdm_unique_count += 1;
            crdm_unique_resps.push(i);
        }
    }
    crdm_task_end_text = "";
    crdm_space_text = "";
    if (((crdm_task_resps.length < 68) || (crdm_conf_resps.length < 68))) {
        if ((crdm_task_resps.length < 68)) {
            crdm_task_end_text = (("You failed to respond to " + (72 - crdm_task_resps.length).toString()) + " task trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close.");
        }
        if ((crdm_conf_resps.length < 68)) {
            crdm_task_end_text = (("You failed to respond to both parts of " + (72 - crdm_conf_resps.length).toString()) + " trials and did not meet the 95% response rate requirement. \n \n The Risk & Ambiguity Task will now close.");
        }
        crdm_space_text = "Press SPACE to end.";
        exp_proceed = false;
        my_loop.addData("crdm_subReject1", "< 95% resp rate");
        my_loop.addData("crdm_subReject1_nonresps-task", (72 - crdm_task_resps.length));
        my_loop.addData("crdm_subReject1_nonresps-conf", (72 - crdm_conf_resps.length));
    } else {
        if ((crdm_unique_count < 2)) {
            crdm_task_end_text = (("You provided the same response to all " + crdm_task_resps.length.toString()) + " trials. \n \n You did not follow task instructions. \n \n The Risk & Ambiguity Task will now close.");
            crdm_space_text = "Press SPACE to end.";
            exp_proceed = false;
            my_loop.addData("crdm_subReject2", "1key response");
            my_loop.addData("crdm_subReject2_key", crdm_task_resps[0]);
        } else {
            crdm_task_end_text = "You have completed the Risk & Ambiguity Task!";
            crdm_space_text = "Press SPACE to continue.";
        }
    }
    
    crdm_end_txt_ON.setText(crdm_task_end_text);
    crdm_end_space_ON.setText(crdm_space_text);
    crdm_end_resp.keys = undefined;
    crdm_end_resp.rt = undefined;
    _crdm_end_resp_allKeys = [];
    // keep track of which components have finished
    crdm_endComponents = [];
    crdm_endComponents.push(crdm_end_title_txt);
    crdm_endComponents.push(crdm_end_txt_ON);
    crdm_endComponents.push(crdm_end_space_ON);
    crdm_endComponents.push(crdm_end_resp);
    
    for (const thisComponent of crdm_endComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_endRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_end' ---
    // get current time
    t = crdm_endClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_end_title_txt* updates
    if (t >= 0.0 && crdm_end_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_end_title_txt.tStart = t;  // (not accounting for frame time here)
      crdm_end_title_txt.frameNStart = frameN;  // exact frame index
      
      crdm_end_title_txt.setAutoDraw(true);
    }
    
    
    // *crdm_end_txt_ON* updates
    if (t >= 0.0 && crdm_end_txt_ON.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_end_txt_ON.tStart = t;  // (not accounting for frame time here)
      crdm_end_txt_ON.frameNStart = frameN;  // exact frame index
      
      crdm_end_txt_ON.setAutoDraw(true);
    }
    
    
    // *crdm_end_space_ON* updates
    if (t >= 0.0 && crdm_end_space_ON.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_end_space_ON.tStart = t;  // (not accounting for frame time here)
      crdm_end_space_ON.frameNStart = frameN;  // exact frame index
      
      crdm_end_space_ON.setAutoDraw(true);
    }
    
    
    // *crdm_end_resp* updates
    if (t >= 0.0 && crdm_end_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_end_resp.tStart = t;  // (not accounting for frame time here)
      crdm_end_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_end_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_end_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_end_resp.clearEvents(); });
    }
    
    if (crdm_end_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_end_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_end_resp_allKeys = _crdm_end_resp_allKeys.concat(theseKeys);
      if (_crdm_end_resp_allKeys.length > 0) {
        crdm_end_resp.keys = _crdm_end_resp_allKeys[_crdm_end_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_end_resp.rt = _crdm_end_resp_allKeys[_crdm_end_resp_allKeys.length - 1].rt;
        crdm_end_resp.duration = _crdm_end_resp_allKeys[_crdm_end_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_endComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_endRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_end' ---
    for (const thisComponent of crdm_endComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_end.stopped', globalClock.getTime());
    crdm_end_resp.stop();
    // the Routine "crdm_end" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_practice_loop1_name;
var cdd_questplus_loop_name;
var cdd_practice_loop2_name;
var cdd_loop_name;
var cdd_namer1Components;
function cdd_namer1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_namer1' ---
    t = 0;
    cdd_namer1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_namer1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_namer1_code
    cdd_practice_loop1_name = "cdd_pract1_trials1";
    cdd_questplus_loop_name = "cdd_qp_trials1";
    cdd_practice_loop2_name = "cdd_pract2_trials1";
    cdd_loop_name = "cdd_trials1";
    
    // keep track of which components have finished
    cdd_namer1Components = [];
    
    for (const thisComponent of cdd_namer1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_namer1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_namer1' ---
    // get current time
    t = cdd_namer1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_namer1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_namer1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_namer1' ---
    for (const thisComponent of cdd_namer1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_namer1.stopped', globalClock.getTime());
    // the Routine "cdd_namer1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_instr1_resp_allKeys;
var cdd_instr1Components;
function cdd_instr1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_instr1' ---
    t = 0;
    cdd_instr1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_instr1.started', globalClock.getTime());
    cdd_instr1_resp.keys = undefined;
    cdd_instr1_resp.rt = undefined;
    _cdd_instr1_resp_allKeys = [];
    // keep track of which components have finished
    cdd_instr1Components = [];
    cdd_instr1Components.push(cdd_instr1_title_txt);
    cdd_instr1Components.push(cdd_instr1_txt);
    cdd_instr1Components.push(cdd_instr1_space_txt);
    cdd_instr1Components.push(cdd_instr1_resp);
    
    for (const thisComponent of cdd_instr1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_instr1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_instr1' ---
    // get current time
    t = cdd_instr1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_instr1_title_txt* updates
    if (t >= 0.0 && cdd_instr1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr1_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr1_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr1_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr1_txt* updates
    if (t >= 0.0 && cdd_instr1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr1_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr1_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr1_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr1_space_txt* updates
    if (t >= 0.0 && cdd_instr1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr1_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr1_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr1_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr1_resp* updates
    if (t >= 0.0 && cdd_instr1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr1_resp.tStart = t;  // (not accounting for frame time here)
      cdd_instr1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_instr1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr1_resp.clearEvents(); });
    }
    
    if (cdd_instr1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_instr1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_instr1_resp_allKeys = _cdd_instr1_resp_allKeys.concat(theseKeys);
      if (_cdd_instr1_resp_allKeys.length > 0) {
        cdd_instr1_resp.keys = _cdd_instr1_resp_allKeys[_cdd_instr1_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_instr1_resp.rt = _cdd_instr1_resp_allKeys[_cdd_instr1_resp_allKeys.length - 1].rt;
        cdd_instr1_resp.duration = _cdd_instr1_resp_allKeys[_cdd_instr1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_instr1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_instr1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_instr1' ---
    for (const thisComponent of cdd_instr1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_instr1.stopped', globalClock.getTime());
    cdd_instr1_resp.stop();
    // the Routine "cdd_instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_instr2_resp_allKeys;
var cdd_instr2Components;
function cdd_instr2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_instr2' ---
    t = 0;
    cdd_instr2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_instr2.started', globalClock.getTime());
    cdd_instr2_resp.keys = undefined;
    cdd_instr2_resp.rt = undefined;
    _cdd_instr2_resp_allKeys = [];
    // keep track of which components have finished
    cdd_instr2Components = [];
    cdd_instr2Components.push(cdd_instr2_title_txt);
    cdd_instr2Components.push(cdd_instr2_txt);
    cdd_instr2Components.push(cdd_instr2_img);
    cdd_instr2Components.push(cdd_instr2_space_txt);
    cdd_instr2Components.push(cdd_instr2_resp);
    
    for (const thisComponent of cdd_instr2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_instr2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_instr2' ---
    // get current time
    t = cdd_instr2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_instr2_title_txt* updates
    if (t >= 0.0 && cdd_instr2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr2_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr2_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr2_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr2_txt* updates
    if (t >= 0.0 && cdd_instr2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr2_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr2_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr2_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr2_img* updates
    if (t >= 0.0 && cdd_instr2_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr2_img.tStart = t;  // (not accounting for frame time here)
      cdd_instr2_img.frameNStart = frameN;  // exact frame index
      
      cdd_instr2_img.setAutoDraw(true);
    }
    
    
    // *cdd_instr2_space_txt* updates
    if (t >= 0.0 && cdd_instr2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr2_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr2_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr2_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr2_resp* updates
    if (t >= 0.0 && cdd_instr2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr2_resp.tStart = t;  // (not accounting for frame time here)
      cdd_instr2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_instr2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr2_resp.clearEvents(); });
    }
    
    if (cdd_instr2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_instr2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_instr2_resp_allKeys = _cdd_instr2_resp_allKeys.concat(theseKeys);
      if (_cdd_instr2_resp_allKeys.length > 0) {
        cdd_instr2_resp.keys = _cdd_instr2_resp_allKeys[_cdd_instr2_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_instr2_resp.rt = _cdd_instr2_resp_allKeys[_cdd_instr2_resp_allKeys.length - 1].rt;
        cdd_instr2_resp.duration = _cdd_instr2_resp_allKeys[_cdd_instr2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_instr2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_instr2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_instr2' ---
    for (const thisComponent of cdd_instr2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_instr2.stopped', globalClock.getTime());
    cdd_instr2_resp.stop();
    // the Routine "cdd_instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_instr3_resp_allKeys;
var cdd_instr3Components;
function cdd_instr3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_instr3' ---
    t = 0;
    cdd_instr3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_instr3.started', globalClock.getTime());
    cdd_instr3_resp.keys = undefined;
    cdd_instr3_resp.rt = undefined;
    _cdd_instr3_resp_allKeys = [];
    // keep track of which components have finished
    cdd_instr3Components = [];
    cdd_instr3Components.push(cdd_instr3_title_txt);
    cdd_instr3Components.push(cdd_instr3_txt);
    cdd_instr3Components.push(cdd_instr3_img);
    cdd_instr3Components.push(cdd_instr3_space_txt);
    cdd_instr3Components.push(cdd_instr3_resp);
    
    for (const thisComponent of cdd_instr3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_instr3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_instr3' ---
    // get current time
    t = cdd_instr3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_instr3_title_txt* updates
    if (t >= 0.0 && cdd_instr3_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr3_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr3_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr3_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr3_txt* updates
    if (t >= 0.0 && cdd_instr3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr3_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr3_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr3_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr3_img* updates
    if (t >= 0.0 && cdd_instr3_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr3_img.tStart = t;  // (not accounting for frame time here)
      cdd_instr3_img.frameNStart = frameN;  // exact frame index
      
      cdd_instr3_img.setAutoDraw(true);
    }
    
    
    // *cdd_instr3_space_txt* updates
    if (t >= 0.0 && cdd_instr3_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr3_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_instr3_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_instr3_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_instr3_resp* updates
    if (t >= 0.0 && cdd_instr3_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_instr3_resp.tStart = t;  // (not accounting for frame time here)
      cdd_instr3_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_instr3_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr3_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_instr3_resp.clearEvents(); });
    }
    
    if (cdd_instr3_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_instr3_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_instr3_resp_allKeys = _cdd_instr3_resp_allKeys.concat(theseKeys);
      if (_cdd_instr3_resp_allKeys.length > 0) {
        cdd_instr3_resp.keys = _cdd_instr3_resp_allKeys[_cdd_instr3_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_instr3_resp.rt = _cdd_instr3_resp_allKeys[_cdd_instr3_resp_allKeys.length - 1].rt;
        cdd_instr3_resp.duration = _cdd_instr3_resp_allKeys[_cdd_instr3_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_instr3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_instr3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_instr3' ---
    for (const thisComponent of cdd_instr3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_instr3.stopped', globalClock.getTime());
    cdd_instr3_resp.stop();
    // the Routine "cdd_instr3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_warn1_resp_allKeys;
var cdd_warnComponents;
function cdd_warnRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_warn' ---
    t = 0;
    cdd_warnClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_warn.started', globalClock.getTime());
    cdd_warn1_resp.keys = undefined;
    cdd_warn1_resp.rt = undefined;
    _cdd_warn1_resp_allKeys = [];
    // keep track of which components have finished
    cdd_warnComponents = [];
    cdd_warnComponents.push(cdd_warn1_title_txt);
    cdd_warnComponents.push(cdd_warn1_txt);
    cdd_warnComponents.push(cdd_warn1_space_txt);
    cdd_warnComponents.push(cdd_warn1_resp);
    
    for (const thisComponent of cdd_warnComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_warnRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_warn' ---
    // get current time
    t = cdd_warnClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_warn1_title_txt* updates
    if (t >= 0.0 && cdd_warn1_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_warn1_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_warn1_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_warn1_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_warn1_txt* updates
    if (t >= 0.0 && cdd_warn1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_warn1_txt.tStart = t;  // (not accounting for frame time here)
      cdd_warn1_txt.frameNStart = frameN;  // exact frame index
      
      cdd_warn1_txt.setAutoDraw(true);
    }
    
    
    // *cdd_warn1_space_txt* updates
    if (t >= 0.0 && cdd_warn1_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_warn1_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_warn1_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_warn1_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_warn1_resp* updates
    if (t >= 0.0 && cdd_warn1_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_warn1_resp.tStart = t;  // (not accounting for frame time here)
      cdd_warn1_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_warn1_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_warn1_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_warn1_resp.clearEvents(); });
    }
    
    if (cdd_warn1_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_warn1_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_warn1_resp_allKeys = _cdd_warn1_resp_allKeys.concat(theseKeys);
      if (_cdd_warn1_resp_allKeys.length > 0) {
        cdd_warn1_resp.keys = _cdd_warn1_resp_allKeys[_cdd_warn1_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_warn1_resp.rt = _cdd_warn1_resp_allKeys[_cdd_warn1_resp_allKeys.length - 1].rt;
        cdd_warn1_resp.duration = _cdd_warn1_resp_allKeys[_cdd_warn1_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_warnComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_warnRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_warn' ---
    for (const thisComponent of cdd_warnComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_warn.stopped', globalClock.getTime());
    cdd_warn1_resp.stop();
    // the Routine "cdd_warn" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_pract1_instr_resp_allKeys;
var cdd_pract1_instrComponents;
function cdd_pract1_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract1_instr' ---
    t = 0;
    cdd_pract1_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract1_instr.started', globalClock.getTime());
    cdd_pract1_instr_resp.keys = undefined;
    cdd_pract1_instr_resp.rt = undefined;
    _cdd_pract1_instr_resp_allKeys = [];
    // keep track of which components have finished
    cdd_pract1_instrComponents = [];
    cdd_pract1_instrComponents.push(cdd_pract1_instr_left_poly);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_right_poly);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_txt);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_immed_txt);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_delay_txt);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_or_txt);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_space_txt);
    cdd_pract1_instrComponents.push(cdd_pract1_instr_resp);
    
    for (const thisComponent of cdd_pract1_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract1_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract1_instr' ---
    // get current time
    t = cdd_pract1_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract1_instr_left_poly* updates
    if (t >= 0.0 && cdd_pract1_instr_left_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_left_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_left_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_left_poly.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_right_poly* updates
    if (t >= 0.0 && cdd_pract1_instr_right_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_right_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_right_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_right_poly.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_txt* updates
    if (t >= 0.0 && cdd_pract1_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_immed_txt* updates
    if (t >= 0.0 && cdd_pract1_instr_immed_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_immed_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_immed_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_immed_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_delay_txt* updates
    if (t >= 0.0 && cdd_pract1_instr_delay_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_delay_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_delay_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_delay_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_or_txt* updates
    if (t >= 0.0 && cdd_pract1_instr_or_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_or_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_or_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_or_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_space_txt* updates
    if (t >= 0.0 && cdd_pract1_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract1_instr_resp* updates
    if (t >= 0.0 && cdd_pract1_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_instr_resp.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_pract1_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract1_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract1_instr_resp.clearEvents(); });
    }
    
    if (cdd_pract1_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_pract1_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_pract1_instr_resp_allKeys = _cdd_pract1_instr_resp_allKeys.concat(theseKeys);
      if (_cdd_pract1_instr_resp_allKeys.length > 0) {
        cdd_pract1_instr_resp.keys = _cdd_pract1_instr_resp_allKeys[_cdd_pract1_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_pract1_instr_resp.rt = _cdd_pract1_instr_resp_allKeys[_cdd_pract1_instr_resp_allKeys.length - 1].rt;
        cdd_pract1_instr_resp.duration = _cdd_pract1_instr_resp_allKeys[_cdd_pract1_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract1_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract1_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract1_instr' ---
    for (const thisComponent of cdd_pract1_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract1_instr.stopped', globalClock.getTime());
    cdd_pract1_instr_resp.stop();
    // the Routine "cdd_pract1_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_init_fixComponents;
function cdd_init_fixRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_init_fix' ---
    t = 0;
    cdd_init_fixClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_init_fix.started', globalClock.getTime());
    // keep track of which components have finished
    cdd_init_fixComponents = [];
    cdd_init_fixComponents.push(cdd_init_fix_polygon);
    
    for (const thisComponent of cdd_init_fixComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_init_fixRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_init_fix' ---
    // get current time
    t = cdd_init_fixClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_init_fix_polygon* updates
    if (t >= 0.0 && cdd_init_fix_polygon.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_init_fix_polygon.tStart = t;  // (not accounting for frame time here)
      cdd_init_fix_polygon.frameNStart = frameN;  // exact frame index
      
      cdd_init_fix_polygon.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_init_fix_polygon.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_init_fix_polygon.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_init_fixComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_init_fixRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_init_fix' ---
    for (const thisComponent of cdd_init_fixComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_init_fix.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_idx1;
var _cdd_pract1_trial_resp_allKeys;
var cdd_pract1_trialComponents;
function cdd_pract1_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract1_trial' ---
    t = 0;
    cdd_pract1_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract1_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract1_trial_code
    my_loop = eval(cdd_practice_loop1_name);
    cdd_idx1 = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    cdd_immed_pos1 = cdd_pos1[cdd_idx1];
    cdd_immed_resp1 = cdd_resp1[cdd_idx1];
    
    if ((cdd_idx1 === 0)) {
        cdd_delay_pos1 = cdd_pos1[1];
    } else {
        cdd_delay_pos1 = cdd_pos1[0];
    }
    cdd_pract1_trial_immed_txt.setPos(cdd_immed_pos1);
    cdd_pract1_trial_immed_txt.setText((((("$" + format(cdd_immed_amt1).toString()).toString() + "\n") + "\n") + " TODAY"));
    cdd_pract1_trial_delay_txt.setPos(cdd_delay_pos1);
    cdd_pract1_trial_delay_txt.setText(((((("$" + format(cdd_delay_amt1).toString()).toString() + "\n") + "\n") + cdd_delay_wait1.toString()) + " DAYS"));
    cdd_pract1_trial_resp.keys = undefined;
    cdd_pract1_trial_resp.rt = undefined;
    _cdd_pract1_trial_resp_allKeys = [];
    // keep track of which components have finished
    cdd_pract1_trialComponents = [];
    cdd_pract1_trialComponents.push(cdd_pract1_trial_left_poly);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_right_poly);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_prompt_txt);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_immed_txt);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_or_txt);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_delay_txt);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_cue);
    cdd_pract1_trialComponents.push(cdd_pract1_trial_resp);
    
    for (const thisComponent of cdd_pract1_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract1_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract1_trial' ---
    // get current time
    t = cdd_pract1_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract1_trial_left_poly* updates
    if (t >= 0.0 && cdd_pract1_trial_left_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_left_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_left_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_left_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_left_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_left_poly.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_right_poly* updates
    if (t >= 0.0 && cdd_pract1_trial_right_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_right_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_right_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_right_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_right_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_right_poly.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_prompt_txt* updates
    if (t >= 0.0 && cdd_pract1_trial_prompt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_prompt_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_prompt_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_prompt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_prompt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_prompt_txt.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_immed_txt* updates
    if (t >= 0.0 && cdd_pract1_trial_immed_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_immed_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_immed_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_immed_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_immed_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_immed_txt.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_or_txt* updates
    if (t >= 0.0 && cdd_pract1_trial_or_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_or_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_or_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_or_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_or_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_or_txt.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_delay_txt* updates
    if (t >= 0.0 && cdd_pract1_trial_delay_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_delay_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_delay_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_delay_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_delay_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_delay_txt.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_cue* updates
    if (t >= 3 && cdd_pract1_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_cue.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_cue.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_cue.setAutoDraw(false);
    }
    
    // *cdd_pract1_trial_resp* updates
    if (t >= 3 && cdd_pract1_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_trial_resp.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_pract1_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract1_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract1_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_pract1_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_pract1_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _cdd_pract1_trial_resp_allKeys = _cdd_pract1_trial_resp_allKeys.concat(theseKeys);
      if (_cdd_pract1_trial_resp_allKeys.length > 0) {
        cdd_pract1_trial_resp.keys = _cdd_pract1_trial_resp_allKeys[_cdd_pract1_trial_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_pract1_trial_resp.rt = _cdd_pract1_trial_resp_allKeys[_cdd_pract1_trial_resp_allKeys.length - 1].rt;
        cdd_pract1_trial_resp.duration = _cdd_pract1_trial_resp_allKeys[_cdd_pract1_trial_resp_allKeys.length - 1].duration;
        // was this correct?
        if (cdd_pract1_trial_resp.keys == cdd_immed_resp1) {
            cdd_pract1_trial_resp.corr = 1;
        } else {
            cdd_pract1_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract1_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var cdd_pract1_key;
var cdd_pract1_immed_key;
function cdd_pract1_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract1_trial' ---
    for (const thisComponent of cdd_pract1_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract1_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from cdd_pract1_trial_code
    cdd_pract1_key = cdd_pract1_trial_resp.keys;
    cdd_pract1_immed_key = cdd_pract1_trial_resp.corr;
    my_loop.addData("cdd_trial_type", "practice1");
    
    // was no response the correct answer?!
    if (cdd_pract1_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(cdd_immed_resp1)) {
         cdd_pract1_trial_resp.corr = 1;  // correct non-response
      } else {
         cdd_pract1_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_pract1_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_pract1_trial_resp.keys', cdd_pract1_trial_resp.keys);
    psychoJS.experiment.addData('cdd_pract1_trial_resp.corr', cdd_pract1_trial_resp.corr);
    if (typeof cdd_pract1_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_pract1_trial_resp.rt', cdd_pract1_trial_resp.rt);
        psychoJS.experiment.addData('cdd_pract1_trial_resp.duration', cdd_pract1_trial_resp.duration);
        routineTimer.reset();
        }
    
    cdd_pract1_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract1_feedbackComponents;
function cdd_pract1_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract1_feedback' ---
    t = 0;
    cdd_pract1_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract1_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract1_feedback_py
    if ((cdd_pract1_key === undefined)) {
        cdd_msg1 = "NO RESPONSE";
    } else {
        if (cdd_pract1_immed_key) {
            cdd_msg1 = "$ NOW";
        } else {
            cdd_msg1 = "$ LATER";
        }
    }
    
    cdd_pract1_feedback_txt.setText(cdd_msg1);
    // keep track of which components have finished
    cdd_pract1_feedbackComponents = [];
    cdd_pract1_feedbackComponents.push(cdd_pract1_feedback_txt);
    
    for (const thisComponent of cdd_pract1_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract1_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract1_feedback' ---
    // get current time
    t = cdd_pract1_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract1_feedback_txt* updates
    if (t >= 0.0 && cdd_pract1_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract1_feedback_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract1_feedback_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract1_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract1_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract1_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract1_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract1_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract1_feedback' ---
    for (const thisComponent of cdd_pract1_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract1_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_qp_instr_resp_allKeys;
var cdd_qp_instrComponents;
function cdd_qp_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_qp_instr' ---
    t = 0;
    cdd_qp_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_qp_instr.started', globalClock.getTime());
    cdd_qp_instr_resp.keys = undefined;
    cdd_qp_instr_resp.rt = undefined;
    _cdd_qp_instr_resp_allKeys = [];
    // keep track of which components have finished
    cdd_qp_instrComponents = [];
    cdd_qp_instrComponents.push(cdd_qp_instr_title_txt);
    cdd_qp_instrComponents.push(cdd_qp_instr_txt);
    cdd_qp_instrComponents.push(cdd_qp_instr_space_txt);
    cdd_qp_instrComponents.push(cdd_qp_instr_resp);
    
    for (const thisComponent of cdd_qp_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_qp_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_qp_instr' ---
    // get current time
    t = cdd_qp_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_qp_instr_title_txt* updates
    if (t >= 0.0 && cdd_qp_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_qp_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_qp_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_qp_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_qp_instr_txt* updates
    if (t >= 0.0 && cdd_qp_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_qp_instr_txt.tStart = t;  // (not accounting for frame time here)
      cdd_qp_instr_txt.frameNStart = frameN;  // exact frame index
      
      cdd_qp_instr_txt.setAutoDraw(true);
    }
    
    
    // *cdd_qp_instr_space_txt* updates
    if (t >= 0.0 && cdd_qp_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_qp_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_qp_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_qp_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_qp_instr_resp* updates
    if (t >= 0.0 && cdd_qp_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_qp_instr_resp.tStart = t;  // (not accounting for frame time here)
      cdd_qp_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_qp_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_qp_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_qp_instr_resp.clearEvents(); });
    }
    
    if (cdd_qp_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_qp_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_qp_instr_resp_allKeys = _cdd_qp_instr_resp_allKeys.concat(theseKeys);
      if (_cdd_qp_instr_resp_allKeys.length > 0) {
        cdd_qp_instr_resp.keys = _cdd_qp_instr_resp_allKeys[_cdd_qp_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_qp_instr_resp.rt = _cdd_qp_instr_resp_allKeys[_cdd_qp_instr_resp_allKeys.length - 1].rt;
        cdd_qp_instr_resp.duration = _cdd_qp_instr_resp_allKeys[_cdd_qp_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_qp_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_qp_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_qp_instr' ---
    for (const thisComponent of cdd_qp_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_qp_instr.stopped', globalClock.getTime());
    cdd_qp_instr_resp.stop();
    // the Routine "cdd_qp_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_idx_qp;
var packed_qp_trial;
var cdd_delay_amt_qp;
var cdd_delay_wait_qp;
var cdd_immed_amt_qp;
var _cdd_questplus_trial_resp_allKeys;
var cdd_questplusComponents;
function cdd_questplusRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_questplus' ---
    t = 0;
    cdd_questplusClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_questplus.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_questplus_JS
    my_loop = eval(cdd_questplus_loop_name);
    cdd_idx_qp = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    cdd_immed_pos_qp = cdd_pos_qp[cdd_idx_qp];
    cdd_immed_resp_qp = cdd_resp_qp[cdd_idx_qp];
    
    if ((cdd_idx_qp === 0)) {
        cdd_delay_pos_qp = cdd_pos_qp[1];
    } else {
        cdd_delay_pos_qp = cdd_pos_qp[0];
    }
    
    packed_qp_trial = cdd_stim_space[cdd_contrast_idx];
    cdd_delay_amt_qp = packed_qp_trial[0];
    cdd_delay_wait_qp = packed_qp_trial[1];
    cdd_immed_amt_qp = packed_qp_trial[2];
    cdd_questplus_trial_immed_txt.setPos(cdd_immed_pos_qp);
    cdd_questplus_trial_immed_txt.setText((((("$" + format(cdd_immed_amt_qp).toString()).toString() + "\n") + "\n") + " TODAY"));
    cdd_questplus_trial_delay_txt.setPos(cdd_delay_pos_qp);
    cdd_questplus_trial_delay_txt.setText(((((("$" + format(cdd_delay_amt_qp).toString()).toString() + "\n") + "\n") + cdd_delay_wait_qp.toString()) + " DAYS"));
    cdd_questplus_trial_resp.keys = undefined;
    cdd_questplus_trial_resp.rt = undefined;
    _cdd_questplus_trial_resp_allKeys = [];
    // keep track of which components have finished
    cdd_questplusComponents = [];
    cdd_questplusComponents.push(cdd_questplus_trial_left_poly);
    cdd_questplusComponents.push(cdd_questplus_trial_right_poly);
    cdd_questplusComponents.push(cdd_questplus_trial_prompt_txt);
    cdd_questplusComponents.push(cdd_questplus_trial_immed_txt);
    cdd_questplusComponents.push(cdd_questplus_trial_or_txt);
    cdd_questplusComponents.push(cdd_questplus_trial_delay_txt);
    cdd_questplusComponents.push(GRFX_fix2_2);
    cdd_questplusComponents.push(cdd_questplus_trial_cue);
    cdd_questplusComponents.push(cdd_questplus_trial_resp);
    
    for (const thisComponent of cdd_questplusComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_questplusRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_questplus' ---
    // get current time
    t = cdd_questplusClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_questplus_trial_left_poly* updates
    if (t >= 0.0 && cdd_questplus_trial_left_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_left_poly.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_left_poly.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_left_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_left_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_left_poly.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_right_poly* updates
    if (t >= 0.0 && cdd_questplus_trial_right_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_right_poly.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_right_poly.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_right_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_right_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_right_poly.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_prompt_txt* updates
    if (t >= 0.0 && cdd_questplus_trial_prompt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_prompt_txt.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_prompt_txt.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_prompt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_prompt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_prompt_txt.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_immed_txt* updates
    if (t >= 0.0 && cdd_questplus_trial_immed_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_immed_txt.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_immed_txt.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_immed_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_immed_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_immed_txt.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_or_txt* updates
    if (t >= 0.0 && cdd_questplus_trial_or_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_or_txt.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_or_txt.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_or_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_or_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_or_txt.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_delay_txt* updates
    if (t >= 0.0 && cdd_questplus_trial_delay_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_delay_txt.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_delay_txt.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_delay_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_delay_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_delay_txt.setAutoDraw(false);
    }
    
    // *GRFX_fix2_2* updates
    if (t >= 3 && GRFX_fix2_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix2_2.tStart = t;  // (not accounting for frame time here)
      GRFX_fix2_2.frameNStart = frameN;  // exact frame index
      
      GRFX_fix2_2.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix2_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix2_2.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_cue* updates
    if (t >= 3 && cdd_questplus_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_cue.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_cue.frameNStart = frameN;  // exact frame index
      
      cdd_questplus_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_cue.setAutoDraw(false);
    }
    
    // *cdd_questplus_trial_resp* updates
    if (t >= 3 && cdd_questplus_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_questplus_trial_resp.tStart = t;  // (not accounting for frame time here)
      cdd_questplus_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_questplus_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_questplus_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_questplus_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_questplus_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_questplus_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_questplus_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_questplus_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _cdd_questplus_trial_resp_allKeys = _cdd_questplus_trial_resp_allKeys.concat(theseKeys);
      if (_cdd_questplus_trial_resp_allKeys.length > 0) {
        cdd_questplus_trial_resp.keys = _cdd_questplus_trial_resp_allKeys[_cdd_questplus_trial_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_questplus_trial_resp.rt = _cdd_questplus_trial_resp_allKeys[_cdd_questplus_trial_resp_allKeys.length - 1].rt;
        cdd_questplus_trial_resp.duration = _cdd_questplus_trial_resp_allKeys[_cdd_questplus_trial_resp_allKeys.length - 1].duration;
        // was this correct?
        if (cdd_questplus_trial_resp.keys == cdd_immed_resp_qp) {
            cdd_questplus_trial_resp.corr = 1;
        } else {
            cdd_questplus_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_questplusComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var cdd_qp_key;
var cdd_qp_immed_key;
var cdd_post_mean;
var cdd_post_sd;
function cdd_questplusRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_questplus' ---
    for (const thisComponent of cdd_questplusComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_questplus.stopped', globalClock.getTime());
    cdd_qp_key = cdd_questplus_trial_resp.keys;
    cdd_qp_immed_key = cdd_questplus_trial_resp.corr;
    
    cdd_response = !cdd_qp_immed_key;
    cdd_q.update(cdd_contrast_idx, cdd_response); //# update posterior
    cdd_contrast_idx = cdd_q.next_contrast(); //# find next contrast index
    cdd_post_mean = weighted_avg(cdd_q);
    cdd_post_sd = weighted_sd(cdd_q);
    
    my_loop.addData("cdd_trial_type", "questplus");
    my_loop.addData("cdd_response", cdd_response);
    my_loop.addData("cdd_mean_alpha", cdd_post_mean[0]);
    my_loop.addData("cdd_mean_kappa", cdd_post_mean[1]);
    my_loop.addData("cdd_mean_gamma", cdd_post_mean[2]);
    my_loop.addData("cdd_sd_alpha", cdd_post_sd[0]); 
    my_loop.addData("cdd_sd_kappa", cdd_post_sd[1]);
    my_loop.addData("cdd_sd_gamma", cdd_post_sd[2]);
    my_loop.addData("cdd_immed_amt_qp", cdd_immed_amt_qp);
    my_loop.addData("cdd_delay_amt_qp", cdd_delay_amt_qp);
    my_loop.addData("cdd_delay_wait_qp", cdd_delay_wait_qp);
    // was no response the correct answer?!
    if (cdd_questplus_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(cdd_immed_resp_qp)) {
         cdd_questplus_trial_resp.corr = 1;  // correct non-response
      } else {
         cdd_questplus_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_questplus_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_questplus_trial_resp.keys', cdd_questplus_trial_resp.keys);
    psychoJS.experiment.addData('cdd_questplus_trial_resp.corr', cdd_questplus_trial_resp.corr);
    if (typeof cdd_questplus_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_questplus_trial_resp.rt', cdd_questplus_trial_resp.rt);
        psychoJS.experiment.addData('cdd_questplus_trial_resp.duration', cdd_questplus_trial_resp.duration);
        routineTimer.reset();
        }
    
    cdd_questplus_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_questplus_fbComponents;
function cdd_questplus_fbRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_questplus_fb' ---
    t = 0;
    cdd_questplus_fbClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_questplus_fb.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_questplus_fb_code
    if ((cdd_qp_key === undefined)) {
        cdd_msg_qp = "NO RESPONSE";
    } else {
        if (cdd_qp_immed_key) {
            cdd_msg_qp = "$ NOW";
        } else {
            cdd_msg_qp = "$ LATER";
        }
    }
    
    cdd_qp_fb_txt.setText(cdd_msg_qp);
    // keep track of which components have finished
    cdd_questplus_fbComponents = [];
    cdd_questplus_fbComponents.push(cdd_qp_fb_txt);
    
    for (const thisComponent of cdd_questplus_fbComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_questplus_fbRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_questplus_fb' ---
    // get current time
    t = cdd_questplus_fbClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_qp_fb_txt* updates
    if (t >= 0.0 && cdd_qp_fb_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_qp_fb_txt.tStart = t;  // (not accounting for frame time here)
      cdd_qp_fb_txt.frameNStart = frameN;  // exact frame index
      
      cdd_qp_fb_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_qp_fb_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_qp_fb_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_questplus_fbComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_questplus_fbRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_questplus_fb' ---
    for (const thisComponent of cdd_questplus_fbComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_questplus_fb.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var kappa;
var alpha;
var amt_immed_options;
var amt_del_options;
var V_max;
var V_min;
var max_time;
var min_time;
var Amp;
var num_steps;
var d0;
var time_options_1;
var l;
var time_options;
var keys_order;
var order_keys;
var flatten;
var round_to_closest_half;
var zippy;
var mighty_numeration;
var value_repeat;
var add_SV;
var get_SE;
var max_neg_delta;
var SE_trials;
var min_trials;
var min_SV_trials;
var min_trials_keys;
var target_SVdiff;
var tmp;
var target_SV_deltas_pos;
var target_SV_deltas_neg;
var get_int_pos_SV_delta;
var Int_pos;
var get_int_neg_SV_delta;
var Int_neg;
var array_of_repetitions;
var get_Max_SVdelta;
var Max_trials;
var Max_SV_trials;
var dict_merge;
var trials;
var length_int_trials;
var needed_categories;
var grab_additional_trial;
var add_trials;
var standard_trial_number;
var cdd_desired_trials;
var repeated_trials;
var tmp_trials;
var cdd_trials_dict;
var cdd_schedule_genComponents;
function cdd_schedule_genRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_schedule_gen' ---
    t = 0;
    cdd_schedule_genClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_schedule_gen.started', globalClock.getTime());
    var valence;
    kappa = cdd_post_mean[1];
    alpha = 1;
    //kappa = 0.5;
    
    amt_immed_options = [2.0, 5.0, 10.0, 15.0, 18.0, 20.0, 27.0, 30.0, 34.0, 
                         35.0, 41.0, 43.0, 44.0, 47.0, 51.0, 62.0, 63.0, 64.0]; // possible immediate $ options
    amt_del_options = [5.0, 10.0, 20.0, 35.0, 50.0, 65.0]; // possible delay $ options
    
    V_max= 65.0; // maximum pay
    V_min = 2.0; // minimum pay
    max_time = 180; // longest delay
    min_time = 2; // shortest delay 
    
    // parameter to modulate how many intermediate trials we want
    Amp = 1/5.0; // fraction of SVmax to match final time option
    if (kappa < 0.003) {
        Amp = 1/4.0;
    }
    
    // calculate time options
    num_steps = 5; // number of delay options
    
    // longest possible delay to sample from to equally sample SVdelta pos and neg
    d0 = (1/Amp - 1) / kappa;
    if (d0 > max_time) {
        d0 = max_time; // ensure 180 days is max limit for peopke with low kappa
    }
    
    // initialize time_options_1 list with time options we always want
    time_options_1 = [7, 15]
    
    if (d0 < max_time) {
        num_steps = 3;
        time_options_1.push(...[round(d0 + ((max_time - d0)/2)), max_time]); // ensure longest delays are always included for participant's with high kappa
    }
    
    // loop through number of time_options (num_steps)
    l = arange_round(0, num_steps+1, 1);
    var i
    for (i = 0; i < l.length; i++) {
        if (i > 0){
            time_options_1.push(round(i * (d0 / num_steps)));
        } else {
            time_options_1.push(min_time);
            }
    }
    
    time_options = [];
    time_options.push(...time_options_1);
    
    amt_immed_options = amt_immed_options.sort((a, b) => a < b);
    amt_del_options = amt_del_options.sort((a, b) => a < b);
    time_options = time_options.sort((a, b) => a < b);
    
    
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    
    
    keys_order = ["category", "cdd_immed_amt", "cdd_delay_amt", "cdd_delay_wait", "delay_SV", "deltaSV", "immed_SV"];
    order_keys = function(dict, keys_order) {
        var ordered_dict;
        ordered_dict = {};
        for (var key, _pj_c = 0, _pj_a = keys_order, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            key = _pj_a[_pj_c];
            if (_pj.in_es6(key, dict)) {
                ordered_dict[key] = dict[key];
            }
        }
        return ordered_dict;
    }
    
    
    flatten = function(list) {
        //#flatten list of lists
        return list.flatten();
    }
    
    
    round_to_closest_half = function(number) {
        var rounded_number;
        rounded_number = (Math.round((number * 2))/2);
        return ((rounded_number === 0) ? 0.5 : rounded_number);
    }
    
    
    zippy = function(x, y) {
        var zipper;
        zipper = [];
        for (var i = 0, _pj_a = x.length; (i < _pj_a); i += 1) {
            zipper.push({"x": x[i], "y": y[i]});
        }
        return zipper;
    }
    
    
    mighty_numeration = function(iterable, start = 0) {
        var n;
        n = start;
        var arr = [];
        for (var elem, _pj_c = 0, _pj_a = iterable, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            elem = _pj_a[_pj_c];
            arr.push([n, elem]);
            n += 1;
        }
        return arr;
    }
    
    
    value_repeat = function(value, repetitions) {
        var tmp = [];
        for (var i = 0; i < repetitions; i++) {
            tmp.push(value);
        }
        return tmp;
    }
    
    
    add_SV = function(trials, kappa) {
        //# adds SV and delta SV to a trials dictionary
        var delay, sv_del, sv_immed, value, zip_data, zip_data2;
        trials["delay_SV"] = [];
        trials["immed_SV"] = [];
        trials["deltaSV"] = [];
        zip_data = zippy(trials["cdd_delay_amt"], trials["cdd_delay_wait"]);
        for (var data, _pj_c = 0, _pj_a = zip_data, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            data = _pj_a[_pj_c];
            value = data["x"];
            delay = data["y"];
            trials["delay_SV"].push((value**alpha/(1 + (kappa * delay)))); //#Silvia instructed us to assume alpha = 1
            trials["immed_SV"].push((trials["cdd_immed_amt"][_pj_c]**alpha/(1 + (kappa * 0))));
        }
        zip_data2 = zippy(trials["delay_SV"], trials["immed_SV"]);
        for (var data2, _pj_c = 0, _pj_a = zip_data2, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            data2 = _pj_a[_pj_c];
            sv_del = data2["x"];
            sv_immed = data2["y"];
            trials["deltaSV"].push((sv_del - sv_immed));
        }
        return trials;
    }
    
    
    get_SE = function(kappa, amt_del_options, time_options) {
        /*Creates trials of subjective equality
        Inputs:
        - kappa
        - amt_del_options: List of delayed amounts
        - time_options: List of delay times
        Output:
        - SE_trials: dictionary containing immediate options with same subjective value as delayed options
        */
        var SE_trials, amt_immed_for_D;
        SE_trials = {"category": [], "cdd_delay_wait": [], "cdd_immed_amt": [], "cdd_delay_amt": []};
        amt_del_options = [5.0, 20.0, 40.0];
        for (var delay, _pj_c = 0, _pj_a = time_options, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            delay = _pj_a[_pj_c];
            amt_immed_for_D = []; //#immediate amount with same SV as delay
            for (var value, _pj_f = 0, _pj_d = amt_del_options, _pj_e = _pj_d.length; (_pj_f < _pj_e); _pj_f += 1) {
                value = _pj_d[_pj_f];
                amt_immed_for_D.push(round_to_closest_half((value**alpha/(1 + (kappa * delay)))));
            }
            SE_trials["cdd_immed_amt"].push(...amt_immed_for_D);
            SE_trials["cdd_delay_amt"].push(...amt_del_options);
            SE_trials["cdd_delay_wait"].push(...value_repeat(round(delay), amt_del_options.length));
        }
        SE_trials["category"] = value_repeat("SE_trials", SE_trials["cdd_immed_amt"].length);
        return SE_trials;
    }
    
    
    max_neg_delta = function(kappa, amt_immed_options, amt_del_options, time_options) {
        //#Creates trials with max negative delta SV that are not catch trials (Vdel > Vn)
        var SV_diff, iSV_diff, ivl, ivn, min_SV_trials;
        min_SV_trials = {"category": [], "cdd_delay_wait": [], "cdd_immed_amt": [], "cdd_delay_amt": [], "deltaSV": []};
        for (var delay, _pj_c = 0, _pj_a = time_options, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            delay = _pj_a[_pj_c];
            SV_diff = 0;
            ivn = 0;
            ivl = 0;
            for (var vn, _pj_f = 0, _pj_d = amt_immed_options, _pj_e = _pj_d.length; (_pj_f < _pj_e); _pj_f += 1) {
                vn = _pj_d[_pj_f];
                for (var vl, _pj_i = 0, _pj_g = amt_del_options, _pj_h = _pj_g.length; (_pj_i < _pj_h); _pj_i += 1) {
                    vl = _pj_g[_pj_i];
                    if ((vl <= vn)) {
                        continue;
                    }
                    iSV_diff = ((vl**alpha / (1 + (kappa * delay))) - vn);
                    if ((iSV_diff < SV_diff)) {
                        SV_diff = iSV_diff;
                        [ivn, ivl] = [vn, vl];
                    }
                }
            }
            min_SV_trials["category"].push("minSV");
            min_SV_trials["cdd_delay_wait"].push(round(delay));
            min_SV_trials["cdd_immed_amt"].push(ivn);
            min_SV_trials["cdd_delay_amt"].push(ivl);
            min_SV_trials["deltaSV"].push(SV_diff);
        }
        return min_SV_trials;
    }
    
    
    SE_trials = get_SE(kappa, amt_del_options, time_options);
    SE_trials = add_SV(SE_trials, kappa);
    min_trials = max_neg_delta(kappa, amt_immed_options, amt_del_options, time_options);
    
    min_SV_trials = {};
    min_trials_keys = ['category', 'cdd_delay_amt', 'cdd_delay_wait', 'cdd_immed_amt'];
    for (var key, _pj_c = 0, _pj_a = min_trials_keys, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        key = _pj_a[_pj_c];
        min_SV_trials[key] = [];
        min_SV_trials[key].push(...min_trials[key]);
        min_SV_trials[key].push(...min_trials[key]);
    }
    min_SV_trials = add_SV(min_SV_trials, kappa);
    
    
    target_SVdiff = function(min_SV_trials, Vmax, Amp) {
        //#Defines target SV_deltas to sample given SV range
        var SV_range_neg, SV_range_pos, min_sv_diff, sv_deltas;
        sv_deltas = [];
        for (var delta_sv, _pj_c = 0, _pj_a = min_SV_trials["deltaSV"], _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            delta_sv = _pj_a[_pj_c];
            sv_deltas.push(delta_sv);
        }
        min_sv_diff = Math.min(...sv_deltas);
        SV_range_pos = [];
        SV_range_neg = [];
        for (var g = 0, _pj_a = Number.parseInt((1/Amp)); (g < _pj_a); g += 1) {
            if ((g !== 0)) {
                SV_range_pos.push(((Amp * Vmax) * g));
                SV_range_neg.push(((Amp * min_sv_diff) * g));
            }
        }
        return [SV_range_pos, SV_range_neg];
    }
    
    
    tmp = target_SVdiff(min_SV_trials, V_max, Amp);
    target_SV_deltas_pos = tmp[0];
    target_SV_deltas_neg = tmp[1];
    
    
    get_int_pos_SV_delta = function(target_SV_deltas, amt_immed_options, time_options, Vmax = V_max, valence = "pos") {
        var Vdel, Vimm, category, category_value, delta_sv, index, max_sv_trials, valence;
        max_sv_trials = {"category": [], "cdd_delay_wait": [], "cdd_immed_amt": [], "cdd_delay_amt": []};
        Vimm = Math.min(...amt_immed_options);
        category = "Int+";
        if ((valence === "neg")) {
            Vimm = 10.0;
            category = "Int-";
        }
        for (var tmp, _pj_c = 0, _pj_a = mighty_numeration(target_SV_deltas, 1), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            tmp = _pj_a[_pj_c];
            index = tmp[0];
            delta_sv = tmp[1];
            category_value = index;
            for (var delay, _pj_f = 0, _pj_d = time_options, _pj_e = _pj_d.length; (_pj_f < _pj_e); _pj_f += 1) {
                delay = _pj_d[_pj_f];
                Vdel = [round_to_closest_half(((delta_sv + Vimm)**(1/alpha) * (1 + (kappa * delay))))];
                for (var v, _pj_i = 0, _pj_g = Vdel, _pj_h = _pj_g.length; (_pj_i < _pj_h); _pj_i += 1) {
                    v = _pj_g[_pj_i];
                    if ((v <= Vmax)) {
                        max_sv_trials["cdd_delay_amt"].push(v);
                        max_sv_trials["cdd_delay_wait"].push(round(delay));
                        max_sv_trials["cdd_immed_amt"].push(Vimm);
                        max_sv_trials["category"].push((category + category_value.toString()));
                    }
                }
            }
        }
        return max_sv_trials;
    }
    
    
    Int_pos = get_int_pos_SV_delta(target_SV_deltas_pos, amt_immed_options, time_options);
    Int_pos = add_SV(Int_pos, kappa);
    
    
    get_int_neg_SV_delta = function(target_SV_deltas, amt_immed_options, time_options, Vmax, d0 = 180, valence = "pos") {
        var Vdel, Vimm, category, category_value, delta_sv, index, max_sv_trials, valence;
        max_sv_trials = {"category": [], "cdd_delay_wait": [], "cdd_immed_amt": [], "cdd_delay_amt": []};
        Vimm = Math.max(...amt_immed_options);
        category = "Int+";
        if ((valence === "neg")) {
            Vdel = 65.0;
            category = "Int-";
        }
        for (var tmp, _pj_c = 0, _pj_a = mighty_numeration(target_SV_deltas, 1), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            tmp = _pj_a[_pj_c];
            index = tmp[0];
            delta_sv = tmp[1];
            category_value = index;
            for (var delay, _pj_f = 0, _pj_d = time_options, _pj_e = _pj_d.length; (_pj_f < _pj_e); _pj_f += 1) {
                delay = _pj_d[_pj_f];
                if ((delay > d0)) {
                    continue;
                }
                Vimm = round_to_closest_half(((Vdel**alpha / (1 + (kappa * delay))) - delta_sv));
                if ((Vimm > Vdel)) {
                    continue;
                }
                max_sv_trials["cdd_delay_amt"].push(Vdel);
                max_sv_trials["cdd_delay_wait"].push(round(delay));
                max_sv_trials["cdd_immed_amt"].push(Vimm);
                max_sv_trials["category"].push((category + category_value.toString()));
            }
        }
        return max_sv_trials;
    }
    
    
    Int_neg = get_int_neg_SV_delta(target_SV_deltas_neg, amt_immed_options, time_options, V_max, d0 = d0, valence = "neg");
    Int_neg = add_SV(Int_neg, kappa);
    
    
    array_of_repetitions = function(value, repetitions) {
        var tmp = [];
        for (var i = 0; i < repetitions; i++) {
            tmp.push(value);
        }
        return tmp;
    }
    
    
    get_Max_SVdelta = function(time_options, Vmax = V_max, Vmin = V_min) {
        //Creates trials with max positive delta by assigning largest amount we can pay to delay and least amount to immediate
        var Max_SVdelta;
        Max_SVdelta = {"category": ["MaxSV"], "cdd_delay_wait": [2], "cdd_immed_amt": [2.0], "cdd_delay_amt": [65.0]};
        Max_SVdelta["category"].push(...array_of_repetitions("MaxSV", time_options.length));
        Max_SVdelta["cdd_delay_amt"].push(...array_of_repetitions(Vmax, time_options.length));
        Max_SVdelta["cdd_immed_amt"].push(...array_of_repetitions(Vmin, time_options.length));
        Max_SVdelta["cdd_delay_wait"].push(...time_options);
        return Max_SVdelta;
    }
    
    
    Max_trials = get_Max_SVdelta(time_options, V_max, V_min);
    Max_SV_trials = {};
    var max_trials_keys = ['category', 'cdd_delay_amt', 'cdd_delay_wait', 'cdd_immed_amt'];
    for (var key, _pj_c = 0, _pj_a = max_trials_keys, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        key = _pj_a[_pj_c];
        Max_SV_trials[key] = [];
        Max_SV_trials[key].push(...Max_trials[key]);
        Max_SV_trials[key].push(...Max_trials[key]);
    }
    Max_SV_trials = add_SV(Max_SV_trials, kappa);
    
    
    dict_merge = function(list_dict) {
        var merged_dict, value;
        merged_dict = [];
        var keys_order = ["category", "cdd_immed_amt", "cdd_immed_wait", "cdd_delay_amt", "cdd_delay_wait", "delay_SV", "deltaSV", "immed_SV"];
        for (var i = 0; i < list_dict.length; i++) {
            var dic = list_dict[i];
            for (var k = 0; k < keys_order.length; k++) {
                var key = keys_order[k];
                try {
                    var tmp;
                    if (dic.hasOwnProperty(key)) {
                        tmp = dic[key]
                    }
                    if (!merged_dict.hasOwnProperty(key)) {
                        merged_dict[key] = [];
                    }
                    if (tmp) {
                        merged_dict[key].push(...tmp);
                    }
                } catch(error) {
                    console.log(error);
                }
            }
        }
        return merged_dict;
    }
    
    
    trials = dict_merge([Max_SV_trials, Int_pos, SE_trials, Int_neg, min_SV_trials]);
    trials["cdd_immed_wait"] = (value_repeat(0, trials["category"].length));
    keys_order = ["category", "cdd_immed_amt", "cdd_immed_wait", "cdd_delay_amt", "cdd_delay_wait", "delay_SV", "deltaSV", "immed_SV"];
    
    
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    
    
    length_int_trials = function(trials, valence = "+") {
        var category, int_category, length_int_trials;
        category = [...trials["category"]];
        int_category = [];
        length_int_trials = 0;
        for (var c, _pj_c = 0, _pj_a = category, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            c = _pj_a[_pj_c];
            if (_pj.in_es6(valence, c)) {
                int_category.push(c);
                length_int_trials += 1;
            }
        }
        return length_int_trials;
    }
    
    
    needed_categories = function(trials, valence = "+") {
        var category, int_category;
        category = [...(new Set(trials["category"]))];
        int_category = [];
        for (var c, _pj_c = 0, _pj_a = category, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            c = _pj_a[_pj_c];
            if (_pj.in_es6(valence, c)) {
                int_category.push(c);
            }
        }
        return int_category;
    }
    
    
    grab_additional_trial = function(trials, c, r) {
        var additional_trial, trial_category, trial_idx;
        for (var tmp, _pj_c = 0, _pj_a = mighty_numeration(trials["category"]), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            tmp = _pj_a[_pj_c];
            trial_idx = tmp[0];
            trial_category = tmp[1];
            if ((trial_category === c)) {
                additional_trial = {"category": [(c.toString() + "_repeat")], 
                                    "cdd_immed_amt": [trials["cdd_immed_amt"][trial_idx]], 
                                    "cdd_immed_wait": [trials["cdd_immed_wait"][trial_idx]], 
                                    "cdd_delay_amt": [trials["cdd_delay_amt"][trial_idx]], 
                                    "cdd_delay_wait": [trials["cdd_delay_wait"][trial_idx]], 
                                    "delay_SV": [trials["delay_SV"][trial_idx]], 
                                    "deltaSV": [trials["deltaSV"][trial_idx]],
                                    "immed_SV": [trials["immed_SV"][trial_idx]]};
                r = (r - 1);
                if ((r > 0)) {
                    continue;
                }
                return additional_trial;
            }
        }
    }
    
    
    add_trials = function(trials, trials_needed, valence = "+") {
        var additional_trial, int_category, nb_repeats;
        int_category = needed_categories(trials, valence);
        nb_repeats = 1;
        if ((int_category.length < trials_needed)) {
            nb_repeats = Number.parseInt((trials_needed / int_category.length));
        }
        for (var r = 0, _pj_a = nb_repeats; (r < _pj_a); r += 1) {
            for (var c, _pj_d = 0, _pj_b = int_category, _pj_c = _pj_b.length; (_pj_d < _pj_c); _pj_d += 1) {
                c = _pj_b[_pj_d];
                if ((trials_needed === 0)) {
                    return trials;
                }
                additional_trial = grab_additional_trial(trials, c, r);
                if ((additional_trial === null)) {
                    additional_trial = grab_additional_trial(trials, c, 1);
                }
                trials = dict_merge([trials, additional_trial]);
                trials_needed = (trials_needed - 1);
            }
        }
        return trials;
    }
    
    
    standard_trial_number = function(trials, desired_trials) {
        var int_diff, length_neg, length_pos, trials_gap, trials_needed, trials_needed_neg, trials_needed_pos;
        trials_needed = (desired_trials - trials["category"].length);
        length_pos = length_int_trials(trials, valence = "+");
        length_neg = length_int_trials(trials, valence = "-");
        int_diff = (length_pos - length_neg);
        if ((Math.abs(int_diff) < trials_needed)) {
            trials_gap = (trials_needed - Math.abs(int_diff));
            if ((int_diff < 0)) {
                trials_needed_pos = (trials_gap + ((trials_needed - trials_gap)/2));
                trials = add_trials(trials, trials_needed_pos, valence = "+");
                trials_needed_neg = ((trials_needed - trials_gap)/2);
                trials = add_trials(trials, trials_needed_neg, valence = "-");
            } else {
                trials_needed_neg = (trials_gap + ((trials_needed - trials_gap)/2));
                trials = add_trials(trials, trials_needed_neg, valence = "-");
                trials_needed_pos = ((trials_needed - trials_gap)/2);
                trials = add_trials(trials, trials_needed_pos, valence = "+");
            }
        } else {
            if ((int_diff > 0)) {
                trials = add_trials(trials, trials_needed, valence = "-");
            } else {
                trials = add_trials(trials, trials_needed, valence = "+");
            }
        }
        return trials;
    }
    
    
    cdd_desired_trials = 100;
    trials = standard_trial_number(trials, cdd_desired_trials);
    repeated_trials = random.choice(range(trials["category"].length), cdd_desired_trials - trials["category"].length); //indices for adding repeated trials
    if (!Array.isArray(repeated_trials)) {
        repeated_trials = [repeated_trials];
    }
    tmp_trials = {};
    Object.keys(trials).forEach(function(key){
        tmp_trials[key] = [];
    });
    repeated_trials.forEach(function(rp_idx){
        Object.keys(trials).forEach(function(key){
        tmp_trials[key].push(trials[key][rp_idx]);
    });
    
        
        });
    cdd_trials_dict = dict_merge([trials, tmp_trials]);
    // keep track of which components have finished
    cdd_schedule_genComponents = [];
    
    for (const thisComponent of cdd_schedule_genComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_schedule_genRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_schedule_gen' ---
    // get current time
    t = cdd_schedule_genClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_schedule_genComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_schedule_genRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_schedule_gen' ---
    for (const thisComponent of cdd_schedule_genComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_schedule_gen.stopped', globalClock.getTime());
    // the Routine "cdd_schedule_gen" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_pract_instr_resp_2_allKeys;
var cdd_pract2_instrComponents;
function cdd_pract2_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_instr' ---
    t = 0;
    cdd_pract2_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_instr.started', globalClock.getTime());
    cdd_pract_instr_resp_2.keys = undefined;
    cdd_pract_instr_resp_2.rt = undefined;
    _cdd_pract_instr_resp_2_allKeys = [];
    // keep track of which components have finished
    cdd_pract2_instrComponents = [];
    cdd_pract2_instrComponents.push(cdd_pract2_intr_name_txt);
    cdd_pract2_instrComponents.push(cdd_pract2_instr_txt);
    cdd_pract2_instrComponents.push(cdd_pract_instr_space_txt_2);
    cdd_pract2_instrComponents.push(cdd_pract_instr_resp_2);
    
    for (const thisComponent of cdd_pract2_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract2_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_instr' ---
    // get current time
    t = cdd_pract2_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract2_intr_name_txt* updates
    if (t >= 0.0 && cdd_pract2_intr_name_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_intr_name_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_intr_name_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_intr_name_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract2_instr_txt* updates
    if (t >= 0.0 && cdd_pract2_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_instr_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_instr_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_instr_txt.setAutoDraw(true);
    }
    
    
    // *cdd_pract_instr_space_txt_2* updates
    if (t >= 0.0 && cdd_pract_instr_space_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract_instr_space_txt_2.tStart = t;  // (not accounting for frame time here)
      cdd_pract_instr_space_txt_2.frameNStart = frameN;  // exact frame index
      
      cdd_pract_instr_space_txt_2.setAutoDraw(true);
    }
    
    
    // *cdd_pract_instr_resp_2* updates
    if (t >= 0.0 && cdd_pract_instr_resp_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract_instr_resp_2.tStart = t;  // (not accounting for frame time here)
      cdd_pract_instr_resp_2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_pract_instr_resp_2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract_instr_resp_2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract_instr_resp_2.clearEvents(); });
    }
    
    if (cdd_pract_instr_resp_2.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_pract_instr_resp_2.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_pract_instr_resp_2_allKeys = _cdd_pract_instr_resp_2_allKeys.concat(theseKeys);
      if (_cdd_pract_instr_resp_2_allKeys.length > 0) {
        cdd_pract_instr_resp_2.keys = _cdd_pract_instr_resp_2_allKeys[_cdd_pract_instr_resp_2_allKeys.length - 1].name;  // just the last key pressed
        cdd_pract_instr_resp_2.rt = _cdd_pract_instr_resp_2_allKeys[_cdd_pract_instr_resp_2_allKeys.length - 1].rt;
        cdd_pract_instr_resp_2.duration = _cdd_pract_instr_resp_2_allKeys[_cdd_pract_instr_resp_2_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract2_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_instr' ---
    for (const thisComponent of cdd_pract2_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_instr.stopped', globalClock.getTime());
    cdd_pract_instr_resp_2.stop();
    // the Routine "cdd_pract2_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_idx2;
var _cdd_pract2_trial_resp_allKeys;
var cdd_pract2_trialComponents;
function cdd_pract2_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_trial' ---
    t = 0;
    cdd_pract2_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_trial.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract2_trial_code
    my_loop = eval(cdd_practice_loop2_name);
    cdd_idx2 = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    cdd_immed_pos2 = cdd_pos2[cdd_idx2];
    cdd_immed_resp2 = cdd_resp2[cdd_idx2];
    
    if ((cdd_idx2 === 0)) {
        cdd_delay_pos2 = cdd_pos2[1];
    } else {
        cdd_delay_pos2 = cdd_pos2[0];
    }
    cdd_pract2_trial_immed_txt.setPos(cdd_immed_pos2);
    cdd_pract2_trial_immed_txt.setText((((("$" + format(cdd_immed_amt2).toString()).toString() + "\n") + "\n") + " TODAY"));
    cdd_pract2_trial_delay_txt.setPos(cdd_delay_pos2);
    cdd_pract2_trial_delay_txt.setText(((((("$" + format(cdd_delay_amt2).toString()).toString() + "\n") + "\n") + cdd_delay_wait2.toString()) + " DAYS"));
    cdd_pract2_trial_resp.keys = undefined;
    cdd_pract2_trial_resp.rt = undefined;
    _cdd_pract2_trial_resp_allKeys = [];
    // keep track of which components have finished
    cdd_pract2_trialComponents = [];
    cdd_pract2_trialComponents.push(cdd_pract2_trial_left_poly);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_right_poly);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_prompt_txt);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_immed_txt);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_or_txt);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_delay_txt);
    cdd_pract2_trialComponents.push(GRFX_fix3_2);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_cue);
    cdd_pract2_trialComponents.push(cdd_pract2_trial_resp);
    
    for (const thisComponent of cdd_pract2_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract2_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_trial' ---
    // get current time
    t = cdd_pract2_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract2_trial_left_poly* updates
    if (t >= 0.0 && cdd_pract2_trial_left_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_left_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_left_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_left_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_left_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_left_poly.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_right_poly* updates
    if (t >= 0.0 && cdd_pract2_trial_right_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_right_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_right_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_right_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_right_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_right_poly.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_prompt_txt* updates
    if (t >= 0.0 && cdd_pract2_trial_prompt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_prompt_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_prompt_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_prompt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_prompt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_prompt_txt.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_immed_txt* updates
    if (t >= 0.0 && cdd_pract2_trial_immed_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_immed_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_immed_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_immed_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_immed_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_immed_txt.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_or_txt* updates
    if (t >= 0.0 && cdd_pract2_trial_or_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_or_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_or_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_or_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_or_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_or_txt.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_delay_txt* updates
    if (t >= 0.0 && cdd_pract2_trial_delay_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_delay_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_delay_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_delay_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_delay_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_delay_txt.setAutoDraw(false);
    }
    
    // *GRFX_fix3_2* updates
    if (t >= 3 && GRFX_fix3_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      GRFX_fix3_2.tStart = t;  // (not accounting for frame time here)
      GRFX_fix3_2.frameNStart = frameN;  // exact frame index
      
      GRFX_fix3_2.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (GRFX_fix3_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      GRFX_fix3_2.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_cue* updates
    if (t >= 3 && cdd_pract2_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_cue.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_cue.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_cue.setAutoDraw(false);
    }
    
    // *cdd_pract2_trial_resp* updates
    if (t >= 3 && cdd_pract2_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_trial_resp.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_pract2_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract2_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract2_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_pract2_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_pract2_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _cdd_pract2_trial_resp_allKeys = _cdd_pract2_trial_resp_allKeys.concat(theseKeys);
      if (_cdd_pract2_trial_resp_allKeys.length > 0) {
        cdd_pract2_trial_resp.keys = _cdd_pract2_trial_resp_allKeys[_cdd_pract2_trial_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_pract2_trial_resp.rt = _cdd_pract2_trial_resp_allKeys[_cdd_pract2_trial_resp_allKeys.length - 1].rt;
        cdd_pract2_trial_resp.duration = _cdd_pract2_trial_resp_allKeys[_cdd_pract2_trial_resp_allKeys.length - 1].duration;
        // was this correct?
        if (cdd_pract2_trial_resp.keys == cdd_immed_resp2) {
            cdd_pract2_trial_resp.corr = 1;
        } else {
            cdd_pract2_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var cdd_pract2_key;
var cdd_pract2_immed_key;
function cdd_pract2_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_trial' ---
    for (const thisComponent of cdd_pract2_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_trial.stopped', globalClock.getTime());
    // Run 'End Routine' code from cdd_pract2_trial_code
    cdd_pract2_key = cdd_pract2_trial_resp.keys;
    cdd_pract2_immed_key = cdd_pract2_trial_resp.corr;
    my_loop.addData("cdd_trial_type", "practice2");
    
    // was no response the correct answer?!
    if (cdd_pract2_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(cdd_immed_resp2)) {
         cdd_pract2_trial_resp.corr = 1;  // correct non-response
      } else {
         cdd_pract2_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_pract2_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_pract2_trial_resp.keys', cdd_pract2_trial_resp.keys);
    psychoJS.experiment.addData('cdd_pract2_trial_resp.corr', cdd_pract2_trial_resp.corr);
    if (typeof cdd_pract2_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_pract2_trial_resp.rt', cdd_pract2_trial_resp.rt);
        psychoJS.experiment.addData('cdd_pract2_trial_resp.duration', cdd_pract2_trial_resp.duration);
        routineTimer.reset();
        }
    
    cdd_pract2_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract2_feedbackComponents;
function cdd_pract2_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_feedback' ---
    t = 0;
    cdd_pract2_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract2_fb_py
    if ((cdd_pract2_key === undefined)) {
        cdd_msg2 = "NO RESPONSE";
    } else {
        if (cdd_pract2_immed_key) {
            cdd_msg2 = "$ NOW";
        } else {
            cdd_msg2 = "$ LATER";
        }
    }
    
    cdd_pract2_fb_txt.setText(cdd_msg2);
    // keep track of which components have finished
    cdd_pract2_feedbackComponents = [];
    cdd_pract2_feedbackComponents.push(cdd_pract2_fb_txt);
    
    for (const thisComponent of cdd_pract2_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract2_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_feedback' ---
    // get current time
    t = cdd_pract2_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract2_fb_txt* updates
    if (t >= 0.0 && cdd_pract2_fb_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_fb_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_fb_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_fb_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_fb_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_fb_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract2_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_feedback' ---
    for (const thisComponent of cdd_pract2_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_pract2_conf_resp_allKeys;
var cdd_pract2_confComponents;
function cdd_pract2_confRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_conf' ---
    t = 0;
    cdd_pract2_confClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_conf.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract2_conf_py
    if ((cdd_pract2_key === undefined)) {
        continueRoutine = false;
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    cdd_pract2_conf_resp.keys = undefined;
    cdd_pract2_conf_resp.rt = undefined;
    _cdd_pract2_conf_resp_allKeys = [];
    // keep track of which components have finished
    cdd_pract2_confComponents = [];
    cdd_pract2_confComponents.push(cdd_pract2_conf_txt);
    cdd_pract2_confComponents.push(cdd_pract2_conf1);
    cdd_pract2_confComponents.push(cdd_pract2_conf1_txt);
    cdd_pract2_confComponents.push(cdd_pract2_conf2);
    cdd_pract2_confComponents.push(cdd_pract2_conf2_txt);
    cdd_pract2_confComponents.push(cdd_pract2_conf3);
    cdd_pract2_confComponents.push(cdd_pract2_conf3_txt);
    cdd_pract2_confComponents.push(cdd_pract2_conf4);
    cdd_pract2_confComponents.push(cdd_pract2_conf4_txt);
    cdd_pract2_confComponents.push(cdd_pract2_conf_resp);
    
    for (const thisComponent of cdd_pract2_confComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract2_conf_key;
function cdd_pract2_confRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_conf' ---
    // get current time
    t = cdd_pract2_confClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from cdd_pract2_conf_py
    cdd_pract2_conf_key = cdd_pract2_conf_resp.keys;
    if (!(cdd_pract2_conf_key === undefined) && (cdd_pract2_conf_key.length === 1)) {
        if ((cdd_pract2_conf_key === "1")) {
            conf1_color = "darkgray";
            conf2_color = [0, 0, 0];
            conf3_color = [0, 0, 0];
            conf4_color = [0, 0, 0];
        } else {
            if ((cdd_pract2_conf_key === "2")) {
                conf1_color = [0, 0, 0];
                conf2_color = "darkgray";
                conf3_color = [0, 0, 0];
                conf4_color = [0, 0, 0];
            } else {
                if ((cdd_pract2_conf_key === "3")) {
                    conf1_color = [0, 0, 0];
                    conf2_color = [0, 0, 0];
                    conf3_color = "darkgray";
                    conf4_color = [0, 0, 0];
                } else {
                    if ((cdd_pract2_conf_key === "4")) {
                        conf1_color = [0, 0, 0];
                        conf2_color = [0, 0, 0];
                        conf3_color = [0, 0, 0];
                        conf4_color = "darkgray";
                    }
                }
            }
        }
    }
    
    
    // *cdd_pract2_conf_txt* updates
    if (t >= 0.0 && cdd_pract2_conf_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf_txt.setAutoDraw(false);
    }
    
    if (cdd_pract2_conf1.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_pract2_conf1.setFillColor(new util.Color(conf1_color), false);
    }
    
    // *cdd_pract2_conf1* updates
    if (t >= 0.0 && cdd_pract2_conf1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf1.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf1.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf1.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf1.setAutoDraw(false);
    }
    
    // *cdd_pract2_conf1_txt* updates
    if (t >= 0.0 && cdd_pract2_conf1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf1_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf1_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf1_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf1_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf1_txt.setAutoDraw(false);
    }
    
    if (cdd_pract2_conf2.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_pract2_conf2.setFillColor(new util.Color(conf2_color), false);
    }
    
    // *cdd_pract2_conf2* updates
    if (t >= 0.0 && cdd_pract2_conf2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf2.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf2.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf2.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf2.setAutoDraw(false);
    }
    
    // *cdd_pract2_conf2_txt* updates
    if (t >= 0.0 && cdd_pract2_conf2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf2_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf2_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf2_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf2_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf2_txt.setAutoDraw(false);
    }
    
    if (cdd_pract2_conf3.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_pract2_conf3.setFillColor(new util.Color(conf3_color), false);
    }
    
    // *cdd_pract2_conf3* updates
    if (t >= 0.0 && cdd_pract2_conf3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf3.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf3.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf3.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf3.setAutoDraw(false);
    }
    
    // *cdd_pract2_conf3_txt* updates
    if (t >= 0.0 && cdd_pract2_conf3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf3_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf3_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf3_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf3_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf3_txt.setAutoDraw(false);
    }
    
    if (cdd_pract2_conf4.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_pract2_conf4.setFillColor(new util.Color(conf4_color), false);
    }
    
    // *cdd_pract2_conf4* updates
    if (t >= 0.0 && cdd_pract2_conf4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf4.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf4.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf4.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf4.setAutoDraw(false);
    }
    
    // *cdd_pract2_conf4_txt* updates
    if (t >= 0.0 && cdd_pract2_conf4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf4_txt.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf4_txt.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_conf4_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf4_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf4_txt.setAutoDraw(false);
    }
    
    // *cdd_pract2_conf_resp* updates
    if (t >= 0.0 && cdd_pract2_conf_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_conf_resp.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_conf_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_pract2_conf_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract2_conf_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_pract2_conf_resp.clearEvents(); });
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_conf_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_conf_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_pract2_conf_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_pract2_conf_resp.getKeys({keyList: ['1', '2', '3', '4'], waitRelease: false});
      _cdd_pract2_conf_resp_allKeys = _cdd_pract2_conf_resp_allKeys.concat(theseKeys);
      if (_cdd_pract2_conf_resp_allKeys.length > 0) {
        cdd_pract2_conf_resp.keys = _cdd_pract2_conf_resp_allKeys[_cdd_pract2_conf_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_pract2_conf_resp.rt = _cdd_pract2_conf_resp_allKeys[_cdd_pract2_conf_resp_allKeys.length - 1].rt;
        cdd_pract2_conf_resp.duration = _cdd_pract2_conf_resp_allKeys[_cdd_pract2_conf_resp_allKeys.length - 1].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_confComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract2_confRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_conf' ---
    for (const thisComponent of cdd_pract2_confComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_conf.stopped', globalClock.getTime());
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    if (!(cdd_pract2_conf_key == undefined) && (cdd_pract2_conf_key.length === 1)) {
        if ((Array.isArray(cdd_pract2_conf_key))) {
            if (_pj.in_es6(cdd_pract2_conf_key.slice((- 1))[0], ["1", "2", "3", "4"])) {
                cdd_conf_resps.push(cdd_pract2_conf_key);
            }
        } else {
            if (_pj.in_es6(cdd_pract2_conf_key, ["1", "2", "3", "4"])) {
                cdd_conf_resps.push(cdd_pract2_conf_key);
            }
        }
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    cdd_conf1.setFillColor(new util.Color(conf1_color), false);
    cdd_conf2.setFillColor(new util.Color(conf2_color), false);
    cdd_conf3.setFillColor(new util.Color(conf3_color), false);
    cdd_conf4.setFillColor(new util.Color(conf4_color), false);
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_pract2_conf_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_pract2_conf_resp.keys', cdd_pract2_conf_resp.keys);
    if (typeof cdd_pract2_conf_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_pract2_conf_resp.rt', cdd_pract2_conf_resp.rt);
        psychoJS.experiment.addData('cdd_pract2_conf_resp.duration', cdd_pract2_conf_resp.duration);
        }
    
    cdd_pract2_conf_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract2_iti1Components;
function cdd_pract2_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_iti1' ---
    t = 0;
    cdd_pract2_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract2_iti1_code
    if (!(cdd_pract2_trials1.thisTrialN == undefined) && (cdd_pract2_trials1.thisTrialN === 2)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cdd_pract2_iti1Components = [];
    cdd_pract2_iti1Components.push(cdd_pract2_iti1_poly);
    
    for (const thisComponent of cdd_pract2_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract2_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_iti1' ---
    // get current time
    t = cdd_pract2_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract2_iti1_poly* updates
    if (t >= 0.0 && cdd_pract2_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_iti1_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_iti1_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract2_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_iti1' ---
    for (const thisComponent of cdd_pract2_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_iti1.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_task_resps;
var cdd_conf_resps;
var cdd_catch_trials;
var cdd_iti_list;
var cdd_s;
var _cdd_trial_instr_resp_allKeys;
var cdd_trial_instrComponents;
function cdd_trial_instrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_trial_instr' ---
    t = 0;
    cdd_trial_instrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_trial_instr.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_trial_instr_code
    cdd_task_resps = [];
    cdd_conf_resps = [];
    cdd_catch_trials = [];
    cdd_iti_list = function () {
        var _pj_a = [], _pj_b = util.range(100);
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(random.random());
        }
        return _pj_a;
    }
    .call(this);
    cdd_s = util.sum(cdd_iti_list);
    cdd_iti_list = function () {
        var _pj_a = [], _pj_b = cdd_iti_list;
        for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
            var i = _pj_b[_pj_c];
            _pj_a.push(((i * 100) / cdd_s));
        }
        return _pj_a;
    }
    .call(this);
    
    cdd_trial_instr_resp.keys = undefined;
    cdd_trial_instr_resp.rt = undefined;
    _cdd_trial_instr_resp_allKeys = [];
    // keep track of which components have finished
    cdd_trial_instrComponents = [];
    cdd_trial_instrComponents.push(cdd_trial_instr_title_txt);
    cdd_trial_instrComponents.push(cdd_trial_instr_txt);
    cdd_trial_instrComponents.push(cdd_trial_instr_space_txt);
    cdd_trial_instrComponents.push(cdd_trial_instr_resp);
    
    for (const thisComponent of cdd_trial_instrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_trial_instrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_trial_instr' ---
    // get current time
    t = cdd_trial_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_trial_instr_title_txt* updates
    if (t >= 0.0 && cdd_trial_instr_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_instr_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_instr_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_instr_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_trial_instr_txt* updates
    if (t >= 0.0 && cdd_trial_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_instr_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_instr_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_instr_txt.setAutoDraw(true);
    }
    
    
    // *cdd_trial_instr_space_txt* updates
    if (t >= 0.0 && cdd_trial_instr_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_instr_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_instr_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_instr_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_trial_instr_resp* updates
    if (t >= 0.0 && cdd_trial_instr_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_instr_resp.tStart = t;  // (not accounting for frame time here)
      cdd_trial_instr_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_trial_instr_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_trial_instr_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_trial_instr_resp.clearEvents(); });
    }
    
    if (cdd_trial_instr_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_trial_instr_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_trial_instr_resp_allKeys = _cdd_trial_instr_resp_allKeys.concat(theseKeys);
      if (_cdd_trial_instr_resp_allKeys.length > 0) {
        cdd_trial_instr_resp.keys = _cdd_trial_instr_resp_allKeys[_cdd_trial_instr_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_trial_instr_resp.rt = _cdd_trial_instr_resp_allKeys[_cdd_trial_instr_resp_allKeys.length - 1].rt;
        cdd_trial_instr_resp.duration = _cdd_trial_instr_resp_allKeys[_cdd_trial_instr_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_trial_instrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_trial_instrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_trial_instr' ---
    for (const thisComponent of cdd_trial_instrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_trial_instr.stopped', globalClock.getTime());
    cdd_trial_instr_resp.stop();
    // the Routine "cdd_trial_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_stop_timer;
var cdd_stopped_time;
var cdd_conf_key;
var cdd_idx;
var cdd_immed_amt;
var cdd_immed_wait;
var cdd_delay_amt;
var cdd_delay_wait;
var cdd_deltaSV;
var cdd_delaySV;
var cdd_immedSV;
var _cdd_trial_resp_allKeys;
var cdd_trialComponents;
function cdd_trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_trial' ---
    t = 0;
    cdd_trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(5.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_trial.started', globalClock.getTime());
    my_loop = eval(cdd_loop_name);
    cdd_stop_timer = null;
    cdd_stopped_time = 0;
    cdd_conf_key = [];
    cdd_idx = random.randint(0, 2); //Math.round(Math.random() * (1- 0) + 0);
    cdd_immed_pos = cdd_pos[cdd_idx];
    cdd_immed_resp = cdd_resp[cdd_idx];
    
    if ((cdd_idx === 0)) {
        cdd_delay_pos = cdd_pos[1];
    } else {
        cdd_delay_pos = cdd_pos[0];
    }
    
    cdd_immed_amt = cdd_trials_dict["cdd_immed_amt"][cdd_trial_idx];
    cdd_immed_wait = 0;
    cdd_delay_amt = cdd_trials_dict["cdd_delay_amt"][cdd_trial_idx];
    cdd_delay_wait = cdd_trials_dict["cdd_delay_wait"][cdd_trial_idx];
    cdd_deltaSV = cdd_trials_dict["deltaSV"][cdd_trial_idx];
    cdd_delaySV = cdd_trials_dict["delay_SV"][cdd_trial_idx];
    cdd_immedSV = cdd_trials_dict["immed_SV"][cdd_trial_idx];
    cdd_trial_immed_txt.setPos(cdd_immed_pos);
    cdd_trial_immed_txt.setText((((("$" + format(cdd_immed_amt).toString()).toString() + "\n") + "\n") + " TODAY"));
    cdd_trial_delay_txt.setPos(cdd_delay_pos);
    cdd_trial_delay_txt.setText(((((("$" + format(cdd_delay_amt).toString()).toString() + "\n") + "\n") + cdd_delay_wait.toString()) + " DAYS"));
    cdd_trial_resp.keys = undefined;
    cdd_trial_resp.rt = undefined;
    _cdd_trial_resp_allKeys = [];
    // keep track of which components have finished
    cdd_trialComponents = [];
    cdd_trialComponents.push(cdd_trial_left_poly);
    cdd_trialComponents.push(cdd_trial_right_poly);
    cdd_trialComponents.push(cdd_trial_prompt_txt);
    cdd_trialComponents.push(cdd_trial_immed_txt);
    cdd_trialComponents.push(cdd_trial_or_txt);
    cdd_trialComponents.push(cdd_trial_delay_txt);
    cdd_trialComponents.push(cdd_trial_cue);
    cdd_trialComponents.push(cdd_trial_resp);
    
    for (const thisComponent of cdd_trialComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_trial' ---
    // get current time
    t = cdd_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if (!(cdd_trial_resp.keys === undefined) && (cdd_trial_resp.keys.length === 1)) {
        if ((cdd_stop_timer === null)) {
            cdd_stop_timer = new util.Clock();
        } else {
            cdd_stopped_time = cdd_stop_timer.getTime();
            if ((cdd_stopped_time >= 0.5)) {
                continueRoutine = false;
            }
        }
    }
    
    // *cdd_trial_left_poly* updates
    if (t >= 0.0 && cdd_trial_left_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_left_poly.tStart = t;  // (not accounting for frame time here)
      cdd_trial_left_poly.frameNStart = frameN;  // exact frame index
      
      cdd_trial_left_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_left_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_left_poly.setAutoDraw(false);
    }
    
    // *cdd_trial_right_poly* updates
    if (t >= 0.0 && cdd_trial_right_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_right_poly.tStart = t;  // (not accounting for frame time here)
      cdd_trial_right_poly.frameNStart = frameN;  // exact frame index
      
      cdd_trial_right_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_right_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_right_poly.setAutoDraw(false);
    }
    
    // *cdd_trial_prompt_txt* updates
    if (t >= 0.0 && cdd_trial_prompt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_prompt_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_prompt_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_prompt_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_prompt_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_prompt_txt.setAutoDraw(false);
    }
    
    // *cdd_trial_immed_txt* updates
    if (t >= 0.0 && cdd_trial_immed_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_immed_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_immed_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_immed_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_immed_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_immed_txt.setAutoDraw(false);
    }
    
    // *cdd_trial_or_txt* updates
    if (t >= 0.0 && cdd_trial_or_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_or_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_or_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_or_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_or_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_or_txt.setAutoDraw(false);
    }
    
    // *cdd_trial_delay_txt* updates
    if (t >= 0.0 && cdd_trial_delay_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_delay_txt.tStart = t;  // (not accounting for frame time here)
      cdd_trial_delay_txt.frameNStart = frameN;  // exact frame index
      
      cdd_trial_delay_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_delay_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_delay_txt.setAutoDraw(false);
    }
    
    // *cdd_trial_cue* updates
    if (t >= 3 && cdd_trial_cue.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_cue.tStart = t;  // (not accounting for frame time here)
      cdd_trial_cue.frameNStart = frameN;  // exact frame index
      
      cdd_trial_cue.setAutoDraw(true);
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_cue.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_cue.setAutoDraw(false);
    }
    
    // *cdd_trial_resp* updates
    if (t >= 3 && cdd_trial_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_resp.tStart = t;  // (not accounting for frame time here)
      cdd_trial_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_trial_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_trial_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_trial_resp.clearEvents(); });
    }
    
    frameRemains = 3 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_trial_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_trial_resp.getKeys({keyList: ['1', '2'], waitRelease: false});
      _cdd_trial_resp_allKeys = _cdd_trial_resp_allKeys.concat(theseKeys);
      if (_cdd_trial_resp_allKeys.length > 0) {
        cdd_trial_resp.keys = _cdd_trial_resp_allKeys[_cdd_trial_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_trial_resp.rt = _cdd_trial_resp_allKeys[_cdd_trial_resp_allKeys.length - 1].rt;
        cdd_trial_resp.duration = _cdd_trial_resp_allKeys[_cdd_trial_resp_allKeys.length - 1].duration;
        // was this correct?
        if (cdd_trial_resp.keys == cdd_immed_resp) {
            cdd_trial_resp.corr = 1;
        } else {
            cdd_trial_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_trialComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var cdd_key;
var cdd_immed_key;
function cdd_trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_trial' ---
    for (const thisComponent of cdd_trialComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_trial.stopped', globalClock.getTime());
    cdd_q.update(cdd_contrast_idx, cdd_response);
    cdd_contrast_idx = cdd_q.next_contrast(); // # find the next contrast index
    
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    cdd_key = cdd_trial_resp.keys;
    cdd_immed_key = cdd_trial_resp.corr;
    if (_pj.in_es6(cdd_key, ["1", "2"])) {
        cdd_task_resps.push(cdd_key);
    }
    if ((((cdd_trial_resp.rt) === undefined) || (cdd_trial_resp.rt >= (2.2 - 0.5)))) {
        cdd_delta_time = 0;
    } else {
        cdd_delta_time = Math.max(0, (2 - (cdd_trial_resp.rt + cdd_stopped_time)));
    }
    if (!(cdd_key === undefined) && (cdd_key.length === 1)) {
        if ((cdd_immed_key === 1)) {
            //if ((cdd_catch_trial === 1)) {
                //cdd_catch_trials.push(1);
            //}
            my_loop.addData("cdd_choice", 0);
            my_loop.addData("cdd_choice2", "immed");
            cdd_bonus_trials.push(["CDD", "immed", cdd_immed_amt, cdd_immed_wait, cdd_delay_amt, cdd_delay_wait]);
        } else {
            //if ((cdd_catch_trial === 1)) {
                //cdd_catch_trials.push(0);
            //}
            my_loop.addData("cdd_choice", 1);
            my_loop.addData("cdd_choice2", "delay");
            cdd_bonus_trials.push(["CDD", "delay", cdd_immed_amt, cdd_immed_wait, cdd_delay_amt, cdd_delay_wait]);
        }
    }
    
    my_loop.addData("cdd_trial_type", "task");
    my_loop.addData("cdd_immed_amt", cdd_immed_amt);
    my_loop.addData("cdd_delay_amt", cdd_delay_amt);
    my_loop.addData("cdd_delay_wait", cdd_delay_wait);
    my_loop.addData("cdd_delta_SV", cdd_deltaSV); //delay - immed
    my_loop.addData("cdd_delay_SV", cdd_delaySV); //SV of delay option
    my_loop.addData("cdd_immed_SV", cdd_immedSV); //SV of immediate option (same as value if alpha = 1)
    // was no response the correct answer?!
    if (cdd_trial_resp.keys === undefined) {
      if (['None','none',undefined].includes(cdd_immed_resp)) {
         cdd_trial_resp.corr = 1;  // correct non-response
      } else {
         cdd_trial_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_trial_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_trial_resp.keys', cdd_trial_resp.keys);
    psychoJS.experiment.addData('cdd_trial_resp.corr', cdd_trial_resp.corr);
    if (typeof cdd_trial_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_trial_resp.rt', cdd_trial_resp.rt);
        psychoJS.experiment.addData('cdd_trial_resp.duration', cdd_trial_resp.duration);
        routineTimer.reset();
        }
    
    cdd_trial_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_feedbackComponents;
function cdd_feedbackRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_feedback' ---
    t = 0;
    cdd_feedbackClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_feedback.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_feedback_code
    if ((cdd_key === undefined)) {
        cdd_msg = "NO RESPONSE";
    } else {
        if (cdd_immed_key) {
            cdd_msg = "$ NOW";
        } else {
            cdd_msg = "$ LATER";
        }
    }
    cdd_feedback_txt.setText(cdd_msg);
    // keep track of which components have finished
    cdd_feedbackComponents = [];
    cdd_feedbackComponents.push(cdd_feedback_txt);
    
    for (const thisComponent of cdd_feedbackComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_feedbackRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_feedback' ---
    // get current time
    t = cdd_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_feedback_txt* updates
    if (t >= 0.0 && cdd_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_feedback_txt.tStart = t;  // (not accounting for frame time here)
      cdd_feedback_txt.frameNStart = frameN;  // exact frame index
      
      cdd_feedback_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_feedback_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_feedbackComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_feedbackRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_feedback' ---
    for (const thisComponent of cdd_feedbackComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_feedback.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cdd_conf_resp_allKeys;
var cdd_confComponents;
function cdd_confRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_conf' ---
    t = 0;
    cdd_confClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_conf.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_conf_code
    if ((cdd_key === undefined)) {
        continueRoutine = false;
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    cdd_conf_resp.keys = undefined;
    cdd_conf_resp.rt = undefined;
    _cdd_conf_resp_allKeys = [];
    // keep track of which components have finished
    cdd_confComponents = [];
    cdd_confComponents.push(cdd_conf_txt);
    cdd_confComponents.push(cdd_conf1);
    cdd_confComponents.push(cdd_conf1_txt);
    cdd_confComponents.push(cdd_conf2);
    cdd_confComponents.push(cdd_conf2_txt);
    cdd_confComponents.push(cdd_conf3);
    cdd_confComponents.push(cdd_conf3_txt);
    cdd_confComponents.push(cdd_conf4);
    cdd_confComponents.push(cdd_conf4_txt);
    cdd_confComponents.push(cdd_conf_resp);
    
    for (const thisComponent of cdd_confComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_confRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_conf' ---
    // get current time
    t = cdd_confClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // Run 'Each Frame' code from cdd_conf_code
    cdd_conf_key = cdd_conf_resp.keys;
    if (!(cdd_conf_key === undefined) && (cdd_conf_key.length === 1)) {
        if ((cdd_conf_key === "1")) {
            conf1_color = "darkgray";
            conf2_color = [0, 0, 0];
            conf3_color = [0, 0, 0];
            conf4_color = [0, 0, 0];
        } else {
            if ((cdd_conf_key === "2")) {
                conf1_color = [0, 0, 0];
                conf2_color = "darkgray";
                conf3_color = [0, 0, 0];
                conf4_color = [0, 0, 0];
            } else {
                if ((cdd_conf_key === "3")) {
                    conf1_color = [0, 0, 0];
                    conf2_color = [0, 0, 0];
                    conf3_color = "darkgray";
                    conf4_color = [0, 0, 0];
                } else {
                    if ((cdd_conf_key === "4")) {
                        conf1_color = [0, 0, 0];
                        conf2_color = [0, 0, 0];
                        conf3_color = [0, 0, 0];
                        conf4_color = "darkgray";
                    }
                }
            }
        }
    }
    
    
    // *cdd_conf_txt* updates
    if (t >= 0.0 && cdd_conf_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf_txt.tStart = t;  // (not accounting for frame time here)
      cdd_conf_txt.frameNStart = frameN;  // exact frame index
      
      cdd_conf_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf_txt.setAutoDraw(false);
    }
    
    if (cdd_conf1.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_conf1.setFillColor(new util.Color(conf1_color), false);
    }
    
    // *cdd_conf1* updates
    if (t >= 0.0 && cdd_conf1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf1.tStart = t;  // (not accounting for frame time here)
      cdd_conf1.frameNStart = frameN;  // exact frame index
      
      cdd_conf1.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf1.setAutoDraw(false);
    }
    
    // *cdd_conf1_txt* updates
    if (t >= 0.0 && cdd_conf1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf1_txt.tStart = t;  // (not accounting for frame time here)
      cdd_conf1_txt.frameNStart = frameN;  // exact frame index
      
      cdd_conf1_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf1_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf1_txt.setAutoDraw(false);
    }
    
    if (cdd_conf2.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_conf2.setFillColor(new util.Color(conf2_color), false);
    }
    
    // *cdd_conf2* updates
    if (t >= 0.0 && cdd_conf2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf2.tStart = t;  // (not accounting for frame time here)
      cdd_conf2.frameNStart = frameN;  // exact frame index
      
      cdd_conf2.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf2.setAutoDraw(false);
    }
    
    // *cdd_conf2_txt* updates
    if (t >= 0.0 && cdd_conf2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf2_txt.tStart = t;  // (not accounting for frame time here)
      cdd_conf2_txt.frameNStart = frameN;  // exact frame index
      
      cdd_conf2_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf2_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf2_txt.setAutoDraw(false);
    }
    
    if (cdd_conf3.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_conf3.setFillColor(new util.Color(conf3_color), false);
    }
    
    // *cdd_conf3* updates
    if (t >= 0.0 && cdd_conf3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf3.tStart = t;  // (not accounting for frame time here)
      cdd_conf3.frameNStart = frameN;  // exact frame index
      
      cdd_conf3.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf3.setAutoDraw(false);
    }
    
    // *cdd_conf3_txt* updates
    if (t >= 0.0 && cdd_conf3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf3_txt.tStart = t;  // (not accounting for frame time here)
      cdd_conf3_txt.frameNStart = frameN;  // exact frame index
      
      cdd_conf3_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf3_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf3_txt.setAutoDraw(false);
    }
    
    if (cdd_conf4.status === PsychoJS.Status.STARTED){ // only update if being drawn
      cdd_conf4.setFillColor(new util.Color(conf4_color), false);
    }
    
    // *cdd_conf4* updates
    if (t >= 0.0 && cdd_conf4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf4.tStart = t;  // (not accounting for frame time here)
      cdd_conf4.frameNStart = frameN;  // exact frame index
      
      cdd_conf4.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf4.setAutoDraw(false);
    }
    
    // *cdd_conf4_txt* updates
    if (t >= 0.0 && cdd_conf4_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf4_txt.tStart = t;  // (not accounting for frame time here)
      cdd_conf4_txt.frameNStart = frameN;  // exact frame index
      
      cdd_conf4_txt.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf4_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf4_txt.setAutoDraw(false);
    }
    
    // *cdd_conf_resp* updates
    if (t >= 0.0 && cdd_conf_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_conf_resp.tStart = t;  // (not accounting for frame time here)
      cdd_conf_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_conf_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_conf_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_conf_resp.clearEvents(); });
    }
    
    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_conf_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_conf_resp.status = PsychoJS.Status.FINISHED;
        }
      
    if (cdd_conf_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_conf_resp.getKeys({keyList: ['1', '2', '3', '4'], waitRelease: false});
      _cdd_conf_resp_allKeys = _cdd_conf_resp_allKeys.concat(theseKeys);
      if (_cdd_conf_resp_allKeys.length > 0) {
        cdd_conf_resp.keys = _cdd_conf_resp_allKeys[_cdd_conf_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_conf_resp.rt = _cdd_conf_resp_allKeys[_cdd_conf_resp_allKeys.length - 1].rt;
        cdd_conf_resp.duration = _cdd_conf_resp_allKeys[_cdd_conf_resp_allKeys.length - 1].duration;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_confComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_confRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_conf' ---
    for (const thisComponent of cdd_confComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_conf.stopped', globalClock.getTime());
    // Run 'End Routine' code from cdd_conf_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    my_loop.addData("cdd_conf", cdd_conf_key);
    if (!(cdd_conf_key == undefined) && (cdd_conf_key.length === 1)) {
        if ((Array.isArray(cdd_conf_key))) {
            if (_pj.in_es6(cdd_conf_key.slice((- 1))[0], ["1", "2", "3", "4"])) {
                cdd_conf_resps.push(cdd_conf_key);
            }
        } else {
            if (_pj.in_es6(cdd_conf_key, ["1", "2", "3", "4"])) {
                cdd_conf_resps.push(cdd_conf_key);
            }
        }
    }
    conf1_color = [0, 0, 0];
    conf2_color = [0, 0, 0];
    conf3_color = [0, 0, 0];
    conf4_color = [0, 0, 0];
    
    cdd_conf1.setFillColor(new util.Color(conf1_color), false);
    cdd_conf2.setFillColor(new util.Color(conf2_color), false);
    cdd_conf3.setFillColor(new util.Color(conf3_color), false);
    cdd_conf4.setFillColor(new util.Color(conf4_color), false);
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(cdd_conf_resp.corr, level);
    }
    psychoJS.experiment.addData('cdd_conf_resp.keys', cdd_conf_resp.keys);
    if (typeof cdd_conf_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('cdd_conf_resp.rt', cdd_conf_resp.rt);
        psychoJS.experiment.addData('cdd_conf_resp.duration', cdd_conf_resp.duration);
        }
    
    cdd_conf_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_iti_time;
var cdd_trial_iti1Components;
function cdd_trial_iti1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_trial_iti1' ---
    t = 0;
    cdd_trial_iti1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_trial_iti1.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_trial_iti1_code
    cdd_iti_time = (cdd_iti_list[my_loop.thisIndex] + cdd_delta_time);
    if (!(cdd_trials1.thisTrialN == undefined) && (cdd_trials1.thisTrialN === 99)) {
        continueRoutine = false;
    }
    
    // keep track of which components have finished
    cdd_trial_iti1Components = [];
    cdd_trial_iti1Components.push(cdd_trial_iti1_poly);
    
    for (const thisComponent of cdd_trial_iti1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_trial_iti1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_trial_iti1' ---
    // get current time
    t = cdd_trial_iti1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_trial_iti1_poly* updates
    if (t >= 0.0 && cdd_trial_iti1_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_iti1_poly.tStart = t;  // (not accounting for frame time here)
      cdd_trial_iti1_poly.frameNStart = frameN;  // exact frame index
      
      cdd_trial_iti1_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + cdd_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_iti1_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_iti1_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_trial_iti1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_trial_iti1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_trial_iti1' ---
    for (const thisComponent of cdd_trial_iti1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_trial_iti1.stopped', globalClock.getTime());
    // Run 'End Routine' code from cdd_trial_iti1_code
    my_loop.addData("cdd_delta_time", cdd_delta_time);
    my_loop.addData("cdd_iti_time", cdd_iti_time);
    
    // the Routine "cdd_trial_iti1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_unique_resps;
var cdd_unique_count;
var _cdd_end_resp_allKeys;
var cdd_endComponents;
function cdd_endRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_end' ---
    t = 0;
    cdd_endClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_end.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_end_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    cdd_unique_resps = [];
    cdd_unique_count = 0;
    for (var i, _pj_c = 0, _pj_a = cdd_task_resps, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        if ((! _pj.in_es6(i, cdd_unique_resps))) {
            cdd_unique_count += 1;
            cdd_unique_resps.push(i);
        }
    }
    cdd_task_end_text = "";
    cdd_space_text = "";
    if (((cdd_task_resps.length < 95) || (cdd_conf_resps.length < 95))) {
        if ((cdd_task_resps.length < 95)) {
            cdd_task_end_text = (("You failed to respond to " + (100 - cdd_task_resps.length).toString()) + " task trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
        }
        if ((cdd_conf_resps.length < 95)) {
            cdd_task_end_text = (("You failed to respond to both parts of " + (100 - cdd_conf_resps.length).toString()) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
        }
        cdd_space_text = "Press SPACE to end.";
        my_loop.addData("cdd_subReject1", "< 95% resp rate");
        my_loop.addData("cdd_subReject1_nonresps-task", (100 - cdd_task_resps.length));
        my_loop.addData("cdd_subReject1_nonresps-conf", (100 - cdd_conf_resps.length));
        exp_proceed = false;
    } else {
        if ((cdd_unique_count < 2)) {
            cdd_task_end_text = (("You provided the same response to all " + cdd_task_resps.length.toString()) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
            cdd_space_text = "Press SPACE to end.";
            exp_proceed = false;
            my_loop.addData("cdd_subReject2", "1key response");
            my_loop.addData("cdd_subReject2_key", cdd_task_resps[0]);
        } else {
            cdd_task_end_text = "You have completed the Delay Discounting Task!";
            cdd_space_text = "Press SPACE to continue.";
        }
    }
    
    cdd_end_txt_ON.setText(cdd_task_end_text);
    cdd_end_space_ON.setText(cdd_space_text);
    cdd_end_resp.keys = undefined;
    cdd_end_resp.rt = undefined;
    _cdd_end_resp_allKeys = [];
    // keep track of which components have finished
    cdd_endComponents = [];
    cdd_endComponents.push(cdd_end_title_txt);
    cdd_endComponents.push(cdd_end_txt_ON);
    cdd_endComponents.push(cdd_end_space_ON);
    cdd_endComponents.push(cdd_end_resp);
    
    for (const thisComponent of cdd_endComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_endRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_end' ---
    // get current time
    t = cdd_endClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_end_title_txt* updates
    if (t >= 0.0 && cdd_end_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_end_title_txt.tStart = t;  // (not accounting for frame time here)
      cdd_end_title_txt.frameNStart = frameN;  // exact frame index
      
      cdd_end_title_txt.setAutoDraw(true);
    }
    
    
    // *cdd_end_txt_ON* updates
    if (t >= 0.0 && cdd_end_txt_ON.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_end_txt_ON.tStart = t;  // (not accounting for frame time here)
      cdd_end_txt_ON.frameNStart = frameN;  // exact frame index
      
      cdd_end_txt_ON.setAutoDraw(true);
    }
    
    
    // *cdd_end_space_ON* updates
    if (t >= 0.0 && cdd_end_space_ON.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_end_space_ON.tStart = t;  // (not accounting for frame time here)
      cdd_end_space_ON.frameNStart = frameN;  // exact frame index
      
      cdd_end_space_ON.setAutoDraw(true);
    }
    
    
    // *cdd_end_resp* updates
    if (t >= 0.0 && cdd_end_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_end_resp.tStart = t;  // (not accounting for frame time here)
      cdd_end_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_end_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_end_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_end_resp.clearEvents(); });
    }
    
    if (cdd_end_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_end_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_end_resp_allKeys = _cdd_end_resp_allKeys.concat(theseKeys);
      if (_cdd_end_resp_allKeys.length > 0) {
        cdd_end_resp.keys = _cdd_end_resp_allKeys[_cdd_end_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_end_resp.rt = _cdd_end_resp_allKeys[_cdd_end_resp_allKeys.length - 1].rt;
        cdd_end_resp.duration = _cdd_end_resp_allKeys[_cdd_end_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_endComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_endRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_end' ---
    for (const thisComponent of cdd_endComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_end.stopped', globalClock.getTime());
    cdd_end_resp.stop();
    // the Routine "cdd_end" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_namer2Components;
function cpdm_namer2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_namer2' ---
    t = 0;
    cpdm_namer2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_namer2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_namer2_code
    cpdm_practice_loop_name = "cpdm_pract_trials2";
    cpdm_loop_name = "cpdm_trials2";
    // keep track of which components have finished
    cpdm_namer2Components = [];
    
    for (const thisComponent of cpdm_namer2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_namer2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_namer2' ---
    // get current time
    t = cpdm_namer2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_namer2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_namer2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_namer2' ---
    for (const thisComponent of cpdm_namer2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_namer2.stopped', globalClock.getTime());
    // the Routine "cpdm_namer2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_iti2Components;
function cpdm_pract_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_pract_iti2' ---
    t = 0;
    cpdm_pract_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_pract_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_pract_iti2_code
    if (!(cpdm_pract_trials2.thisTrialN == undefined) && (cpdm_pract_trials2.thisTrialN === 4)) {
        continueRoutine = false;
    }
    
    // keep track of which components have finished
    cpdm_pract_iti2Components = [];
    cpdm_pract_iti2Components.push(cpdm_pract_iti_poly_2);
    
    for (const thisComponent of cpdm_pract_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_pract_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_pract_iti2' ---
    // get current time
    t = cpdm_pract_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_pract_iti_poly_2* updates
    if (t >= 0.0 && cpdm_pract_iti_poly_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_iti_poly_2.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_iti_poly_2.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_iti_poly_2.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_iti_poly_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_iti_poly_2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_pract_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_pract_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_pract_iti2' ---
    for (const thisComponent of cpdm_pract_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_pract_iti2.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_trials_iti2Components;
function cpdm_trials_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_trials_iti2' ---
    t = 0;
    cpdm_trials_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_trials_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_trials_iti2_code
    cpdm_iti_time = (cpdm_iti_list[my_loop.thisIndex] + cpdm_delta_time);
    if (!(cpdm_trials2.thisTrialN == undefined) && (cpdm_trials2.thisTrialN === 199)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cpdm_trials_iti2Components = [];
    cpdm_trials_iti2Components.push(cpdm_trials_iti2_poly);
    
    for (const thisComponent of cpdm_trials_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_trials_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_trials_iti2' ---
    // get current time
    t = cpdm_trials_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_trials_iti2_poly* updates
    if (t >= 0.0 && cpdm_trials_iti2_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trials_iti2_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trials_iti2_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trials_iti2_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + cpdm_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trials_iti2_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trials_iti2_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_trials_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_trials_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_trials_iti2' ---
    for (const thisComponent of cpdm_trials_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_trials_iti2.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_trials_iti2_code
    my_loop.addData("cpdm_delta_time", cpdm_delta_time);
    my_loop.addData("cpdm_iti_time", cpdm_iti_time);
    
    // the Routine "cpdm_trials_iti2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_run_break2_resp_allKeys;
var cpdm_run_break2Components;
function cpdm_run_break2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_run_break2' ---
    t = 0;
    cpdm_run_break2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_run_break2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_run_break2_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    cpdm_unique_resps = [];
    cpdm_unique_count = 0;
    for (var i, _pj_c = 0, _pj_a = run_resps, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        if ((! _pj.in_es6(i, cpdm_unique_resps))) {
            cpdm_unique_count += 1;
            cpdm_unique_resps.push(i);
        }
    }
    cpdm_run_break_text = "";
    cpdm_space_text = "";
    if ((run_resps.length < 190)) {
        cpdm_run_break_text = (("You failed to respond to " + (200 - run_resps.length).toString()) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
        cpdm_space_text = "Press SPACE to end.";
        exp_proceed = false;
        my_loop.addData("cpdm_subReject1", "< 95% resp rate");
        my_loop.addData("cpdm_subReject1_nonresps", (200 - run_resps.length));
    } else {
        if ((cpdm_unique_count < 2)) {
            cpdm_run_break_text = (("You provided the same response to all " + run_resps.length.toString()) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
            cpdm_space_text = "Press SPACE to end.";
            exp_proceed = false;
            my_loop.addData("cpdm_subReject2", "1key response");
            my_loop.addData("cpdm_subReject2_key", run_resps[0]);
        } else {
            if ((_pj.in_es6("low_vol", cpdm_run_dimension) && (util.sum(cpdm_catch_trials) < 14))) {
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.";
                cpdm_space_text = "Press SPACE to end.";
                exp_proceed = false;
                my_loop.addData("cpdm_subReject3LV", "LV catch fail");
                my_loop.addData("cpdm_subReject3LV_fails", (20 - util.sum(cpdm_catch_trials)));
            } else {
                if ((condition_runs2.thisN === 1)) {
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!";
                    cpdm_space_text = "Press SPACE to continue.";
                } else {
                    cpdm_run_break_text = (("Please feel free to take a short break. \n \n As you begin Block " + run_counter.toString()) + ", read the possible monetary values of each option carefully as they may have changed.");
                    cpdm_space_text = "Press SPACE to continue.";
                }
            }
        }
    }
    
    cpdm_run_break2_txt.setText(cpdm_run_break_text);
    cpdm_run_break2_txt.setHeight(0.05);
    cpdm_run_break2_space_txt.setText(cpdm_space_text);
    cpdm_run_break2_resp.keys = undefined;
    cpdm_run_break2_resp.rt = undefined;
    _cpdm_run_break2_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_run_break2Components = [];
    cpdm_run_break2Components.push(cpdm_run_break2_title_txt);
    cpdm_run_break2Components.push(cpdm_run_break2_txt);
    cpdm_run_break2Components.push(cpdm_run_break2_space_txt);
    cpdm_run_break2Components.push(cpdm_run_break2_resp);
    
    for (const thisComponent of cpdm_run_break2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_run_break2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_run_break2' ---
    // get current time
    t = cpdm_run_break2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_run_break2_title_txt* updates
    if (t >= 0.0 && cpdm_run_break2_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break2_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break2_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break2_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break2_txt* updates
    if (t >= 0.0 && cpdm_run_break2_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break2_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break2_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break2_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break2_space_txt* updates
    if (t >= 0.0 && cpdm_run_break2_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break2_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break2_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break2_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break2_resp* updates
    if (t >= 0.0 && cpdm_run_break2_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break2_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break2_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_run_break2_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break2_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break2_resp.clearEvents(); });
    }
    
    if (cpdm_run_break2_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_run_break2_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_run_break2_resp_allKeys = _cpdm_run_break2_resp_allKeys.concat(theseKeys);
      if (_cpdm_run_break2_resp_allKeys.length > 0) {
        cpdm_run_break2_resp.keys = _cpdm_run_break2_resp_allKeys[_cpdm_run_break2_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_run_break2_resp.rt = _cpdm_run_break2_resp_allKeys[_cpdm_run_break2_resp_allKeys.length - 1].rt;
        cpdm_run_break2_resp.duration = _cpdm_run_break2_resp_allKeys[_cpdm_run_break2_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_run_break2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_run_break2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_run_break2' ---
    for (const thisComponent of cpdm_run_break2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_run_break2.stopped', globalClock.getTime());
    cpdm_run_break2_resp.stop();
    // the Routine "cpdm_run_break2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_namer2Components;
function crdm_namer2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_namer2' ---
    t = 0;
    crdm_namer2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_namer2.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_namer_code2
    crdm_practice_loop1_name = "crdm_pract1_trials2";
    crdm_questplus_loop_name = "crdm_qp_trials2";
    crdm_practice_loop2_name = "crdm_pract2_trials2";
    crdm_loop_name = "crdm_trials2";
    // keep track of which components have finished
    crdm_namer2Components = [];
    
    for (const thisComponent of crdm_namer2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_namer2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_namer2' ---
    // get current time
    t = crdm_namer2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_namer2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_namer2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_namer2' ---
    for (const thisComponent of crdm_namer2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_namer2.stopped', globalClock.getTime());
    // the Routine "crdm_namer2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_pract2_iti2Components;
function crdm_pract2_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_pract2_iti2' ---
    t = 0;
    crdm_pract2_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_pract2_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_pract2_iti2_code
    if (!(crdm_pract2_trials2.thisTrialN == undefined) && (crdm_pract2_trials2.thisTrialN === 2)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    crdm_pract2_iti2Components = [];
    crdm_pract2_iti2Components.push(crdm_pract2_iti2_poly);
    
    for (const thisComponent of crdm_pract2_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_pract2_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_pract2_iti2' ---
    // get current time
    t = crdm_pract2_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_pract2_iti2_poly* updates
    if (t >= 0.0 && crdm_pract2_iti2_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_pract2_iti2_poly.tStart = t;  // (not accounting for frame time here)
      crdm_pract2_iti2_poly.frameNStart = frameN;  // exact frame index
      
      crdm_pract2_iti2_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_pract2_iti2_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_pract2_iti2_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_pract2_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_pract2_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_pract2_iti2' ---
    for (const thisComponent of crdm_pract2_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_pract2_iti2.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var crdm_trials_iti2Components;
function crdm_trials_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_trials_iti2' ---
    t = 0;
    crdm_trials_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_trials_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_trials_iti2_code
    crdm_iti_time = (crdm_iti_list[my_loop.thisIndex] + crdm_delta_time);
    if (!(crdm_trials2.thisTrialN == undefined) && (crdm_trials2.thisTrialN === 71)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    crdm_trials_iti2Components = [];
    crdm_trials_iti2Components.push(crdm_trials_iti2_poly);
    
    for (const thisComponent of crdm_trials_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_trials_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_trials_iti2' ---
    // get current time
    t = crdm_trials_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_trials_iti2_poly* updates
    if (t >= 0.0 && crdm_trials_iti2_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_trials_iti2_poly.tStart = t;  // (not accounting for frame time here)
      crdm_trials_iti2_poly.frameNStart = frameN;  // exact frame index
      
      crdm_trials_iti2_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + crdm_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (crdm_trials_iti2_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      crdm_trials_iti2_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_trials_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_trials_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_trials_iti2' ---
    for (const thisComponent of crdm_trials_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_trials_iti2.stopped', globalClock.getTime());
    // Run 'End Routine' code from crdm_trials_iti2_code
    my_loop.addData("crdm_delta_time", crdm_delta_time);
    my_loop.addData("crdm_iti_time", crdm_iti_time);
    
    // the Routine "crdm_trials_iti2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_namer2Components;
function cdd_namer2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_namer2' ---
    t = 0;
    cdd_namer2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_namer2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_namer2_code
    cdd_practice_loop1_name = "cdd_pract1_trials2";
    cdd_questplus_loop_name = "cdd_qp_trials2";
    cdd_practice_loop2_name = "cdd_pract2_trials2";
    cdd_loop_name = "cdd_trials2";
    // keep track of which components have finished
    cdd_namer2Components = [];
    
    for (const thisComponent of cdd_namer2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_namer2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_namer2' ---
    // get current time
    t = cdd_namer2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_namer2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_namer2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_namer2' ---
    for (const thisComponent of cdd_namer2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_namer2.stopped', globalClock.getTime());
    // the Routine "cdd_namer2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_pract2_iti2Components;
function cdd_pract2_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_pract2_iti2' ---
    t = 0;
    cdd_pract2_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_pract2_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_pract2_iti2_code
    if (!(cdd_pract2_trials2.thisTrialN == undefined) && (cdd_pract2_trials2.thisTrialN === 2)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cdd_pract2_iti2Components = [];
    cdd_pract2_iti2Components.push(cdd_pract2_iti2_poly);
    
    for (const thisComponent of cdd_pract2_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_pract2_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_pract2_iti2' ---
    // get current time
    t = cdd_pract2_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_pract2_iti2_poly* updates
    if (t >= 0.0 && cdd_pract2_iti2_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_pract2_iti2_poly.tStart = t;  // (not accounting for frame time here)
      cdd_pract2_iti2_poly.frameNStart = frameN;  // exact frame index
      
      cdd_pract2_iti2_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_pract2_iti2_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_pract2_iti2_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_pract2_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_pract2_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_pract2_iti2' ---
    for (const thisComponent of cdd_pract2_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_pract2_iti2.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cdd_trial_iti2Components;
function cdd_trial_iti2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_trial_iti2' ---
    t = 0;
    cdd_trial_iti2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_trial_iti2.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_trial_iti2_code
    cdd_iti_time = (cdd_iti_list[my_loop.thisIndex] + cdd_delta_time);
    if (!(cdd_trials2.thisTrialN == undefined) && (cdd_trials2.thisTrialN === 99)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cdd_trial_iti2Components = [];
    cdd_trial_iti2Components.push(cdd_trial_iti2_poly);
    
    for (const thisComponent of cdd_trial_iti2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_trial_iti2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_trial_iti2' ---
    // get current time
    t = cdd_trial_iti2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_trial_iti2_poly* updates
    if (t >= 0.0 && cdd_trial_iti2_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_trial_iti2_poly.tStart = t;  // (not accounting for frame time here)
      cdd_trial_iti2_poly.frameNStart = frameN;  // exact frame index
      
      cdd_trial_iti2_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + cdd_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cdd_trial_iti2_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cdd_trial_iti2_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_trial_iti2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_trial_iti2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_trial_iti2' ---
    for (const thisComponent of cdd_trial_iti2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_trial_iti2.stopped', globalClock.getTime());
    // Run 'End Routine' code from cdd_trial_iti2_code
    my_loop.addData("cdd_delta_time", cdd_delta_time);
    my_loop.addData("cdd_iti_time", cdd_iti_time);
    
    // the Routine "cdd_trial_iti2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_namer3Components;
function cpdm_namer3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_namer3' ---
    t = 0;
    cpdm_namer3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_namer3.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_namer3_code
    cpdm_practice_loop_name = "cpdm_pract_trials3";
    cpdm_loop_name = "cpdm_trials3";
    // keep track of which components have finished
    cpdm_namer3Components = [];
    
    for (const thisComponent of cpdm_namer3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_namer3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_namer3' ---
    // get current time
    t = cpdm_namer3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_namer3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_namer3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_namer3' ---
    for (const thisComponent of cpdm_namer3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_namer3.stopped', globalClock.getTime());
    // the Routine "cpdm_namer3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var cpdm_pract_iti3Components;
function cpdm_pract_iti3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_pract_iti3' ---
    t = 0;
    cpdm_pract_iti3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_pract_iti3.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_pract_iti3_code
    if (!(cpdm_pract_trials3.thisTrialN == undefined) && (cpdm_pract_trials3.thisTrialN === 4)) {
        continueRoutine = false;
    }
    
    // keep track of which components have finished
    cpdm_pract_iti3Components = [];
    cpdm_pract_iti3Components.push(cpdm_pract_iti3_poly);
    
    for (const thisComponent of cpdm_pract_iti3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_pract_iti3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_pract_iti3' ---
    // get current time
    t = cpdm_pract_iti3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_pract_iti3_poly* updates
    if (t >= 0.0 && cpdm_pract_iti3_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_pract_iti3_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_pract_iti3_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_pract_iti3_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_pract_iti3_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_pract_iti3_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_pract_iti3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_pract_iti3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_pract_iti3' ---
    for (const thisComponent of cpdm_pract_iti3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_pract_iti3.stopped', globalClock.getTime());
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var iti_time;
var cpdm_trials_iti3Components;
function cpdm_trials_iti3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_trials_iti3' ---
    t = 0;
    cpdm_trials_iti3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_trials_iti3.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_trials_iti3_code
    iti_time = (iti_list[my_loop.thisIndex] + delta_time);
    if (!(cpdm_trials3.thisTrialN == undefined) && (cpdm_trials3.thisTrialN === 199)) {
        continueRoutine = false;
    }
    // keep track of which components have finished
    cpdm_trials_iti3Components = [];
    cpdm_trials_iti3Components.push(cpdm_trials_iti3_poly);
    
    for (const thisComponent of cpdm_trials_iti3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_trials_iti3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_trials_iti3' ---
    // get current time
    t = cpdm_trials_iti3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_trials_iti3_poly* updates
    if (t >= 0.0 && cpdm_trials_iti3_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_trials_iti3_poly.tStart = t;  // (not accounting for frame time here)
      cpdm_trials_iti3_poly.frameNStart = frameN;  // exact frame index
      
      cpdm_trials_iti3_poly.setAutoDraw(true);
    }
    
    frameRemains = 0.0 + cpdm_iti_time - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (cpdm_trials_iti3_poly.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      cpdm_trials_iti3_poly.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_trials_iti3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_trials_iti3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_trials_iti3' ---
    for (const thisComponent of cpdm_trials_iti3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_trials_iti3.stopped', globalClock.getTime());
    // Run 'End Routine' code from cpdm_trials_iti3_code
    my_loop.addData("cpdm_delta_time", delta_time);
    my_loop.addData("cpdm_iti_time", iti_time);
    
    // the Routine "cpdm_trials_iti3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _cpdm_run_break3_resp_allKeys;
var cpdm_run_break3Components;
function cpdm_run_break3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_run_break3' ---
    t = 0;
    cpdm_run_break3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_run_break3.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_run_break3_code
    var _pj;
    function _pj_snippets(container) {
        function in_es6(left, right) {
            if (((right instanceof Array) || ((typeof right) === "string"))) {
                return (right.indexOf(left) > (- 1));
            } else {
                if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {
                    return right.has(left);
                } else {
                    return (left in right);
                }
            }
        }
        container["in_es6"] = in_es6;
        return container;
    }
    _pj = {};
    _pj_snippets(_pj);
    cpdm_unique_resps = [];
    cpdm_unique_count = 0;
    for (var i, _pj_c = 0, _pj_a = run_resps, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        if ((! _pj.in_es6(i, cpdm_unique_resps))) {
            cpdm_unique_count += 1;
            cpdm_unique_resps.push(i);
        }
    }
    cpdm_run_break_text = "";
    cpdm_space_text = "";
    if ((run_resps.length < 190)) {
        cpdm_run_break_text = (("You failed to respond to " + (200 - run_resps.length).toString()) + " trials and did not meet the 95% response rate requirement. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
        cpdm_space_text = "Press SPACE to end.";
        exp_proceed = false;
        my_loop.addData("cpdm_subReject1", "< 95% resp rate");
        my_loop.addData("cpdm_subReject1_nonresps", (200 - run_resps.length));
    } else {
        if ((cpdm_unique_count < 2)) {
            cpdm_run_break_text = (("You provided the same response to all " + run_resps.length.toString()) + " trials. \n \n You did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.");
            cpdm_space_text = "Press SPACE to end.";
            exp_proceed = false;
            my_loop.addData("cpdm_subReject2", "1key response");
            my_loop.addData("cpdm_subReject2_key", run_resps[0]);
        } else {
            if ((_pj.in_es6("low_vol", cpdm_run_dimension) && (util.sum(cpdm_catch_trials) < 14))) {
                cpdm_run_break_text = "Your performance on the previous trial block demonstrates you did not follow task instructions. \n \n The IDM Study will now close and you will not be eligible to receive payment or a bonus.";
                cpdm_space_text = "Press SPACE to end.";
                exp_proceed = false;
                my_loop.addData("cpdm_subReject3LV", "LV catch fail");
                my_loop.addData("cpdm_subReject3LV_fails", (20 - util.sum(cpdm_catch_trials)));
            } else {
                if ((condition_runs3.thisN === 1)) {
                    cpdm_run_break_text = "You have completed the Visual Decision Making Task!";
                    cpdm_space_text = "Press SPACE to continue.";
                } else {
                    cpdm_run_break_text = (("Please feel free to take a short break. \n \n As you begin Block " + run_counter.toString()) + ", read the possible monetary values of each option carefully as they may have changed.");
                    cpdm_space_text = "Press SPACE to continue.";
                }
            }
        }
    }
    
    cpdm_run_break3_txt.setText(cpdm_run_break_text);
    cpdm_run_break3_space_txt.setText(cpdm_space_text);
    cpdm_run_break3_resp.keys = undefined;
    cpdm_run_break3_resp.rt = undefined;
    _cpdm_run_break3_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_run_break3Components = [];
    cpdm_run_break3Components.push(cpdm_run_break3_title_txt);
    cpdm_run_break3Components.push(cpdm_run_break3_txt);
    cpdm_run_break3Components.push(cpdm_run_break3_space_txt);
    cpdm_run_break3Components.push(cpdm_run_break3_resp);
    
    for (const thisComponent of cpdm_run_break3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_run_break3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_run_break3' ---
    // get current time
    t = cpdm_run_break3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_run_break3_title_txt* updates
    if (t >= 0.0 && cpdm_run_break3_title_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break3_title_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break3_title_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break3_title_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break3_txt* updates
    if (t >= 0.0 && cpdm_run_break3_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break3_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break3_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break3_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break3_space_txt* updates
    if (t >= 0.0 && cpdm_run_break3_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break3_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break3_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_run_break3_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_run_break3_resp* updates
    if (t >= 0.0 && cpdm_run_break3_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_run_break3_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_run_break3_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_run_break3_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break3_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_run_break3_resp.clearEvents(); });
    }
    
    if (cpdm_run_break3_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_run_break3_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_run_break3_resp_allKeys = _cpdm_run_break3_resp_allKeys.concat(theseKeys);
      if (_cpdm_run_break3_resp_allKeys.length > 0) {
        cpdm_run_break3_resp.keys = _cpdm_run_break3_resp_allKeys[_cpdm_run_break3_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_run_break3_resp.rt = _cpdm_run_break3_resp_allKeys[_cpdm_run_break3_resp_allKeys.length - 1].rt;
        cpdm_run_break3_resp.duration = _cpdm_run_break3_resp_allKeys[_cpdm_run_break3_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_run_break3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_run_break3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_run_break3' ---
    for (const thisComponent of cpdm_run_break3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_run_break3.stopped', globalClock.getTime());
    cpdm_run_break3_resp.stop();
    // the Routine "cpdm_run_break3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var exps;
var rand_idx;
var random_exp;
var idm_rand_selectComponents;
function idm_rand_selectRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_rand_select' ---
    t = 0;
    idm_rand_selectClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_rand_select.started', globalClock.getTime());
    // Run 'Begin Routine' code from idm_rand_select_code
    exps = ["cpdm", "crdm", "cdd"];
    rand_idx = random.randint(0, 3);
    random_exp = exps[rand_idx];
    my_loop.addData("idm_bonus_exp", random_exp);
    
    // keep track of which components have finished
    idm_rand_selectComponents = [];
    
    for (const thisComponent of idm_rand_selectComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_rand_selectRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_rand_select' ---
    // get current time
    t = idm_rand_selectClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_rand_selectComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_rand_selectRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_rand_select' ---
    for (const thisComponent of idm_rand_selectComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_rand_select.stopped', globalClock.getTime());
    // the Routine "idm_rand_select" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var exp;
var money;
var acc;
var conf;
var acc_color;
var idx;
var _cpdm_bonus_resp_allKeys;
var cpdm_bonusComponents;
function cpdm_bonusRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cpdm_bonus' ---
    t = 0;
    cpdm_bonusClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cpdm_bonus.started', globalClock.getTime());
    // Run 'Begin Routine' code from cpdm_bonus_code
    if ((random_exp === "cpdm")) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    exp = [];
    money = [];
    acc = [];
    conf = [];
    acc_color = [0, 0, 0];
    idx = Number.parseInt((random.random() * cpdm_bonus_trials.length));
    [exp, money, acc, conf] = cpdm_bonus_trials[idx];
    if ((random_exp === "cpdm")) {
        my_loop.addData("cpdm_bonus_amt", money);
        my_loop.addData("cpdm_bonus_acc", acc);
        my_loop.addData("cpdm_bonus_conf", conf);
    }
    if ((acc === "CORRECT")) {
        acc_color = [0.1216, 0.4745, 0.1216];
    } else {
        acc_color = [0.9608, 0.0039, (- 0.1059)];
    }
    cpdm_bonus_earnings_txt.setText('In this trial, you earned:');
    cpdm_bonus_amt_txt.setText(("$" + format(money).toString()).toString());
    cpdm_bonus_acc_txt.setColor(new util.Color(acc_color));
    cpdm_bonus_acc_txt.setText(acc);
    cpdm_bonus_conf_txt.setText((conf + " CONFIDENCE"));
    cpdm_bonus_resp.keys = undefined;
    cpdm_bonus_resp.rt = undefined;
    _cpdm_bonus_resp_allKeys = [];
    // keep track of which components have finished
    cpdm_bonusComponents = [];
    cpdm_bonusComponents.push(cpdm_bonus_thanks_txt);
    cpdm_bonusComponents.push(cpdm_bonus_earnings_txt);
    cpdm_bonusComponents.push(cpdm_bonus_amt_txt);
    cpdm_bonusComponents.push(cpdm_bonus_answer_txt);
    cpdm_bonusComponents.push(cpdm_bonus_acc_txt);
    cpdm_bonusComponents.push(cpdm_bonus_and_txt);
    cpdm_bonusComponents.push(cpdm_bonus_conf_txt);
    cpdm_bonusComponents.push(cpdm_bonus_space_txt);
    cpdm_bonusComponents.push(cpdm_bonus_resp);
    
    for (const thisComponent of cpdm_bonusComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cpdm_bonusRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cpdm_bonus' ---
    // get current time
    t = cpdm_bonusClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cpdm_bonus_thanks_txt* updates
    if (t >= 0.0 && cpdm_bonus_thanks_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_thanks_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_thanks_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_thanks_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_earnings_txt* updates
    if (t >= 0.0 && cpdm_bonus_earnings_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_earnings_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_earnings_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_earnings_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_amt_txt* updates
    if (t >= 0.0 && cpdm_bonus_amt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_amt_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_amt_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_amt_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_answer_txt* updates
    if (t >= 0.0 && cpdm_bonus_answer_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_answer_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_answer_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_answer_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_acc_txt* updates
    if (t >= 0.0 && cpdm_bonus_acc_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_acc_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_acc_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_acc_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_and_txt* updates
    if (t >= 0.0 && cpdm_bonus_and_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_and_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_and_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_and_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_conf_txt* updates
    if (t >= 0.0 && cpdm_bonus_conf_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_conf_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_conf_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_conf_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_space_txt* updates
    if (t >= 0.0 && cpdm_bonus_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_space_txt.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_space_txt.frameNStart = frameN;  // exact frame index
      
      cpdm_bonus_space_txt.setAutoDraw(true);
    }
    
    
    // *cpdm_bonus_resp* updates
    if (t >= 0.0 && cpdm_bonus_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cpdm_bonus_resp.tStart = t;  // (not accounting for frame time here)
      cpdm_bonus_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cpdm_bonus_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cpdm_bonus_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cpdm_bonus_resp.clearEvents(); });
    }
    
    if (cpdm_bonus_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cpdm_bonus_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cpdm_bonus_resp_allKeys = _cpdm_bonus_resp_allKeys.concat(theseKeys);
      if (_cpdm_bonus_resp_allKeys.length > 0) {
        cpdm_bonus_resp.keys = _cpdm_bonus_resp_allKeys[_cpdm_bonus_resp_allKeys.length - 1].name;  // just the last key pressed
        cpdm_bonus_resp.rt = _cpdm_bonus_resp_allKeys[_cpdm_bonus_resp_allKeys.length - 1].rt;
        cpdm_bonus_resp.duration = _cpdm_bonus_resp_allKeys[_cpdm_bonus_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cpdm_bonusComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cpdm_bonusRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cpdm_bonus' ---
    for (const thisComponent of cpdm_bonusComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cpdm_bonus.stopped', globalClock.getTime());
    cpdm_bonus_resp.stop();
    // the Routine "cpdm_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var choice;
var trial_img;
var top;
var bottom;
var outcome;
var nonzero_side;
var domain;
var sure_amt;
var choice_text;
var outcome_color;
var chip_color;
var chip_text;
var choice_outcome;
var money_outcome;
var red_nonzero;
var _crdm_bonus_resp_allKeys;
var crdm_bonusComponents;
function crdm_bonusRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'crdm_bonus' ---
    t = 0;
    crdm_bonusClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('crdm_bonus.started', globalClock.getTime());
    // Run 'Begin Routine' code from crdm_bonus_code
    if (random_exp === "crdm") {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    exp = [];
    choice = [];
    money = [];
    trial_img = [];
    top = [];
    bottom = [];
    outcome = [];
    nonzero_side = [];
    domain = [];
    sure_amt = "";
    choice_text = "";
    outcome_color = [0, 0, 0];
    chip_color = [0, 0, 0];
    chip_text = "";
    choice_outcome = "";
    money_outcome = "";
    idx = Number.parseInt((random.random() * crdm_bonus_trials.length));
    [exp, choice, money, sure_amt, trial_img, top, bottom, outcome, nonzero_side, domain] = crdm_bonus_trials[idx];
    if ((random_exp === "crdm")) {
        my_loop.addData("crdm_bonus_choice", choice);
        my_loop.addData("crdm_bonus_amt", money);
    }
    money = format(money);
    //#top is always red, bottom is always blue
    red_nonzero = false;
    if ((nonzero_side === "top")) {
        red_nonzero = true;
    }
    
    // Text for bonus payment screen
    if ((choice === "sure")) { //Ss chose sure amt
        choice_text = "*CERTAIN*";
        outcome_color = [0.7098, 0.2941, (- 0.749)];
        chip_color = [0, 0, 0];
        chip_text = "";
        choice_outcome = ("$" + money.toString());
        money_outcome = "";
    } else { //Ss chose lottery
        choice_text = "*PLAY THE LOTTERY*";
        if ((red_nonzero === true)) { //red (top) is nonzero side
            if (((outcome === 1) && (domain === 1))) { //Ss won the lotto on gain trial
                outcome_color = [0.9608, 0.0039, (- 0.1059)];
                chip_color = [0.9608, 0.0039, (- 0.1059)];
                choice_outcome = "A red chip"; //blue chip is drawn and is winning side (+$ == win some money)
                chip_text = "was drawn and the outcome was";
                money_outcome = ("$" + money.toString());
            } else {
                if (((outcome === 1) && (domain === -1))) { //Ss won the lotto on loss trial
                    outcome_color = [(- 0.2157), 0.1686, 0.8588];
                    chip_color = [(- 0.2157), 0.1686, 0.8588];
                    choice_outcome = "A blue chip"; //blue chip is drawn and is winning side ($0 == lose no money)
                    chip_text = "was drawn and the outcome was";
                    money_outcome = ("$" + money.toString());
                } else {
                    if (((outcome === 0) && (domain === 1))) { //Ss lost lotto on gain trial
                        outcome_color = [(- 0.2157), 0.1686, 0.8588];
                        chip_color = [(- 0.2157), 0.1686, 0.8588];
                        choice_outcome = "A blue chip"; //blue chip is drawn and is losing side ($0 == win no money)
                        chip_text = "was drawn and the outcome was";
                        money_outcome = ("$" + money.toString());
                    } else {
                        if (((outcome === 0) && (domain === -1))) { //Ss lost lotto on gloss trial
                            outcome_color = [0.9608, 0.0039, (- 0.1059)];
                            chip_color = [0.9608, 0.0039, (- 0.1059)];
                            choice_outcome = "A red chip"; //red chip is drawn and is losing side (-$ == lose some money)
                            chip_text = "was drawn and the outcome was";
                            money_outcome = ("$" + money.toString());
                        }
                    }
                }
            }
        } else { //blue (bottom) is nonzero side
            if (((outcome === 1) && (domain === 1))) { //Ss won the lotto on gain trial
                outcome_color = [(- 0.2157), 0.1686, 0.8588];
                chip_color = [(- 0.2157), 0.1686, 0.8588];
                choice_outcome = "A blue chip"; //blue chip is drawn and is winning side (+$ == win some money)
                chip_text = "was drawn and the outcome was";
                money_outcome = ("$" + money.toString());
            } else {
                if (((outcome === 1) && (domain === -1))) { //Ss won the lotto on loss trial
                    outcome_color = [0.9608, 0.0039, (- 0.1059)];
                    chip_color = [0.9608, 0.0039, (- 0.1059)];
                    choice_outcome = "A red chip"; //red chip is drawn and is winning side ($0 == lose no money)
                    chip_text = "was drawn and the outcome was";
                    money_outcome = ("$" + money.toString());
                } else {
                    if (((outcome === 0) && (domain === 1))) { //Ss lost lotto on gain trial
                        outcome_color = [0.9608, 0.0039, (- 0.1059)];
                        chip_color = [0.9608, 0.0039, (- 0.1059)];
                        choice_outcome = "A red chip"; //red chip is drawn and is losing side ($0 == win no money)
                        chip_text = "was drawn and the outcome was";
                        money_outcome = ("$" + money.toString());
                    } else {
                        if (((outcome === 0) && (domain === -1))) { //Ss lost lotto on gloss trial
                            outcome_color = [(- 0.2157), 0.1686, 0.8588];
                            chip_color = [(- 0.2157), 0.1686, 0.8588];
                            choice_outcome = "A blue chip";
                            chip_text = "was drawn and the outcome was"; //blue chip is drawn and is losing side (-$ == lose some money)
                            money_outcome = ("$" + money.toString());
                        }
                    }
                }
            }
        }
    }
    crdm_bonus_lott_top.setText(("$" + format(top).toString()).toString());
    crdm_bonus_img.setImage(("crdm/" + trial_img));
    crdm_bonus_lott_bot.setText(("$" + format(bottom).toString()).toString());
    crdm_bonus_sure_amt_txt.setText(("$" + format(sure_amt).toString()).toString());
    crdm_bonus_choice_text_txt.setText(choice_text);
    crdm_bonus_choice_outcome_txt.setColor(new util.Color(outcome_color));
    crdm_bonus_choice_outcome_txt.setText(choice_outcome);
    crdm_bonus_drawn_txt.setText(chip_text);
    crdm_bonus_chip_poly.setFillColor(new util.Color(chip_color));
    crdm_bonus_chip_poly.setLineColor(new util.Color(chip_color));
    crdm_bonus_winnings_txt.setText(money_outcome);
    crdm_bonus_resp.keys = undefined;
    crdm_bonus_resp.rt = undefined;
    _crdm_bonus_resp_allKeys = [];
    // keep track of which components have finished
    crdm_bonusComponents = [];
    crdm_bonusComponents.push(crdm_bonus_thanks_txt);
    crdm_bonusComponents.push(crdm_bonus_lott_top);
    crdm_bonusComponents.push(crdm_bonus_img);
    crdm_bonusComponents.push(crdm_bonus_lott_bot);
    crdm_bonusComponents.push(crdm_bonus_sure_amt_txt);
    crdm_bonusComponents.push(crdm_bonus_prompt_txt);
    crdm_bonusComponents.push(crdm_bonus_choice_text_txt);
    crdm_bonusComponents.push(crdm_bonus_choice_outcome_txt);
    crdm_bonusComponents.push(crdm_bonus_drawn_txt);
    crdm_bonusComponents.push(crdm_bonus_chip_poly);
    crdm_bonusComponents.push(crdm_bonus_winnings_txt);
    crdm_bonusComponents.push(crdm_bonus_space_txt);
    crdm_bonusComponents.push(crdm_bonus_resp);
    
    for (const thisComponent of crdm_bonusComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function crdm_bonusRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'crdm_bonus' ---
    // get current time
    t = crdm_bonusClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *crdm_bonus_thanks_txt* updates
    if (t >= 0.0 && crdm_bonus_thanks_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_thanks_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_thanks_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_thanks_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_lott_top* updates
    if (t >= 0.0 && crdm_bonus_lott_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_lott_top.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_lott_top.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_lott_top.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_img* updates
    if (t >= 0.0 && crdm_bonus_img.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_img.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_img.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_img.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_lott_bot* updates
    if (t >= 0.0 && crdm_bonus_lott_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_lott_bot.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_lott_bot.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_lott_bot.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_sure_amt_txt* updates
    if (t >= 0.0 && crdm_bonus_sure_amt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_sure_amt_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_sure_amt_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_sure_amt_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_prompt_txt* updates
    if (t >= 0.0 && crdm_bonus_prompt_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_prompt_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_prompt_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_prompt_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_choice_text_txt* updates
    if (t >= 0.0 && crdm_bonus_choice_text_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_choice_text_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_choice_text_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_choice_text_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_choice_outcome_txt* updates
    if (t >= 0.0 && crdm_bonus_choice_outcome_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_choice_outcome_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_choice_outcome_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_choice_outcome_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_drawn_txt* updates
    if (t >= 0.0 && crdm_bonus_drawn_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_drawn_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_drawn_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_drawn_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_chip_poly* updates
    if (t >= 0.0 && crdm_bonus_chip_poly.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_chip_poly.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_chip_poly.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_chip_poly.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_winnings_txt* updates
    if (t >= 0.0 && crdm_bonus_winnings_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_winnings_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_winnings_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_winnings_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_space_txt* updates
    if (t >= 0.0 && crdm_bonus_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_space_txt.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_space_txt.frameNStart = frameN;  // exact frame index
      
      crdm_bonus_space_txt.setAutoDraw(true);
    }
    
    
    // *crdm_bonus_resp* updates
    if (t >= 0.0 && crdm_bonus_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      crdm_bonus_resp.tStart = t;  // (not accounting for frame time here)
      crdm_bonus_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { crdm_bonus_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { crdm_bonus_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { crdm_bonus_resp.clearEvents(); });
    }
    
    if (crdm_bonus_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = crdm_bonus_resp.getKeys({keyList: ['space'], waitRelease: false});
      _crdm_bonus_resp_allKeys = _crdm_bonus_resp_allKeys.concat(theseKeys);
      if (_crdm_bonus_resp_allKeys.length > 0) {
        crdm_bonus_resp.keys = _crdm_bonus_resp_allKeys[_crdm_bonus_resp_allKeys.length - 1].name;  // just the last key pressed
        crdm_bonus_resp.rt = _crdm_bonus_resp_allKeys[_crdm_bonus_resp_allKeys.length - 1].rt;
        crdm_bonus_resp.duration = _crdm_bonus_resp_allKeys[_crdm_bonus_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of crdm_bonusComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function crdm_bonusRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'crdm_bonus' ---
    for (const thisComponent of crdm_bonusComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('crdm_bonus.stopped', globalClock.getTime());
    crdm_bonus_resp.stop();
    // the Routine "crdm_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var choice_amt;
var choice_wait;
var other_amt;
var other_wait;
var other_text;
var _cdd_bonus_resp_allKeys;
var cdd_bonusComponents;
function cdd_bonusRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'cdd_bonus' ---
    t = 0;
    cdd_bonusClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('cdd_bonus.started', globalClock.getTime());
    // Run 'Begin Routine' code from cdd_bonus_code
    if ((random_exp === "cdd")) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    exp = [];
    choice = [];
    choice_amt = [];
    choice_wait = [];
    other_amt = [];
    other_wait = [];
    choice_text = "";
    other_text = "";
    idx = Number.parseInt((random.random() * cdd_bonus_trials.length));
    if ((cdd_bonus_trials[idx][1] === "immed")) {
        [exp, choice, choice_amt, choice_wait, other_amt, other_wait] = cdd_bonus_trials[idx];
        if ((random_exp === "cdd")) {
            my_loop.addData("cdd_bonus_choice", choice);
            my_loop.addData("cdd_bonus_amt", choice_amt);
            my_loop.addData("cdd_bonus_delay", choice_wait);
        }
        choice_amt = format(choice_amt);
        other_amt = format(other_amt);
        choice_text = (("$" + choice_amt.toString()) + " TODAY");
        other_text = (((("$" + other_amt.toString()) + " in ") + other_wait.toString()) + " DAYS");
    
    } else {
        [exp, choice, other_amt, other_wait, choice_amt, choice_wait] = cdd_bonus_trials[idx];
        if ((random_exp === "cdd")) {
            my_loop.addData("cdd_bonus_choice", choice);
            my_loop.addData("cdd_bonus_amt", choice_amt);
            my_loop.addData("cdd_bonus_delay", choice_wait);
        }
        choice_amt = format(choice_amt);
        other_amt = format(other_amt);
        choice_text = (((("$" + choice_amt.toString()) + " in ") + choice_wait.toString()) + " DAYS");
        other_text = (("$" + other_amt.toString()) + " TODAY");
    }
    cdd_bonus_box.setText('In this trial, you chose to receive:');
    cdd_bonus_choice_txt.setText(choice_text);
    cdd_bonus_other_txt.setText(other_text);
    cdd_bonus_resp.keys = undefined;
    cdd_bonus_resp.rt = undefined;
    _cdd_bonus_resp_allKeys = [];
    // keep track of which components have finished
    cdd_bonusComponents = [];
    cdd_bonusComponents.push(cdd_bonus_thanks_txt);
    cdd_bonusComponents.push(cdd_bonus_box);
    cdd_bonusComponents.push(cdd_bonus_choice_txt);
    cdd_bonusComponents.push(cdd_bonus_rather_txt);
    cdd_bonusComponents.push(cdd_bonus_other_txt);
    cdd_bonusComponents.push(cdd_bonus_space_txt);
    cdd_bonusComponents.push(cdd_bonus_resp);
    
    for (const thisComponent of cdd_bonusComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function cdd_bonusRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'cdd_bonus' ---
    // get current time
    t = cdd_bonusClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *cdd_bonus_thanks_txt* updates
    if (t >= 0.0 && cdd_bonus_thanks_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_thanks_txt.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_thanks_txt.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_thanks_txt.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_box* updates
    if (t >= 0.0 && cdd_bonus_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_box.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_box.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_box.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_choice_txt* updates
    if (t >= 0.0 && cdd_bonus_choice_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_choice_txt.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_choice_txt.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_choice_txt.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_rather_txt* updates
    if (t >= 0.0 && cdd_bonus_rather_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_rather_txt.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_rather_txt.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_rather_txt.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_other_txt* updates
    if (t >= 0.0 && cdd_bonus_other_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_other_txt.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_other_txt.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_other_txt.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_space_txt* updates
    if (t >= 0.0 && cdd_bonus_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_space_txt.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_space_txt.frameNStart = frameN;  // exact frame index
      
      cdd_bonus_space_txt.setAutoDraw(true);
    }
    
    
    // *cdd_bonus_resp* updates
    if (t >= 0.0 && cdd_bonus_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      cdd_bonus_resp.tStart = t;  // (not accounting for frame time here)
      cdd_bonus_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { cdd_bonus_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { cdd_bonus_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { cdd_bonus_resp.clearEvents(); });
    }
    
    if (cdd_bonus_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = cdd_bonus_resp.getKeys({keyList: ['space'], waitRelease: false});
      _cdd_bonus_resp_allKeys = _cdd_bonus_resp_allKeys.concat(theseKeys);
      if (_cdd_bonus_resp_allKeys.length > 0) {
        cdd_bonus_resp.keys = _cdd_bonus_resp_allKeys[_cdd_bonus_resp_allKeys.length - 1].name;  // just the last key pressed
        cdd_bonus_resp.rt = _cdd_bonus_resp_allKeys[_cdd_bonus_resp_allKeys.length - 1].rt;
        cdd_bonus_resp.duration = _cdd_bonus_resp_allKeys[_cdd_bonus_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of cdd_bonusComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function cdd_bonusRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'cdd_bonus' ---
    for (const thisComponent of cdd_bonusComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('cdd_bonus.stopped', globalClock.getTime());
    cdd_bonus_resp.stop();
    // the Routine "cdd_bonus" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _idm_comp_code_key_resp_allKeys;
var idm_comp_codeComponents;
function idm_comp_codeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'idm_comp_code' ---
    t = 0;
    idm_comp_codeClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    psychoJS.experiment.addData('idm_comp_code.started', globalClock.getTime());
    // Run 'Begin Routine' code from idm_code_code
    comp_code = random.randint(100000, 999999);
    my_loop.addData("completion_code", comp_code);
    
    idm_comp_code_num_txt.setText(comp_code);
    idm_comp_code_key_resp.keys = undefined;
    idm_comp_code_key_resp.rt = undefined;
    _idm_comp_code_key_resp_allKeys = [];
    // keep track of which components have finished
    idm_comp_codeComponents = [];
    idm_comp_codeComponents.push(idm_comp_code_header_txt);
    idm_comp_codeComponents.push(idm_comp_code_num_txt);
    idm_comp_codeComponents.push(idm_comp_code_instr_txt);
    idm_comp_codeComponents.push(idm_comp_code_space_txt);
    idm_comp_codeComponents.push(idm_comp_code_key_resp);
    
    for (const thisComponent of idm_comp_codeComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}


function idm_comp_codeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'idm_comp_code' ---
    // get current time
    t = idm_comp_codeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *idm_comp_code_header_txt* updates
    if (t >= 0.0 && idm_comp_code_header_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_comp_code_header_txt.tStart = t;  // (not accounting for frame time here)
      idm_comp_code_header_txt.frameNStart = frameN;  // exact frame index
      
      idm_comp_code_header_txt.setAutoDraw(true);
    }
    
    
    // *idm_comp_code_num_txt* updates
    if (t >= 0.0 && idm_comp_code_num_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_comp_code_num_txt.tStart = t;  // (not accounting for frame time here)
      idm_comp_code_num_txt.frameNStart = frameN;  // exact frame index
      
      idm_comp_code_num_txt.setAutoDraw(true);
    }
    
    
    // *idm_comp_code_instr_txt* updates
    if (t >= 0.0 && idm_comp_code_instr_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_comp_code_instr_txt.tStart = t;  // (not accounting for frame time here)
      idm_comp_code_instr_txt.frameNStart = frameN;  // exact frame index
      
      idm_comp_code_instr_txt.setAutoDraw(true);
    }
    
    
    // *idm_comp_code_space_txt* updates
    if (t >= 0.0 && idm_comp_code_space_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_comp_code_space_txt.tStart = t;  // (not accounting for frame time here)
      idm_comp_code_space_txt.frameNStart = frameN;  // exact frame index
      
      idm_comp_code_space_txt.setAutoDraw(true);
    }
    
    
    // *idm_comp_code_key_resp* updates
    if (t >= 0.0 && idm_comp_code_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      idm_comp_code_key_resp.tStart = t;  // (not accounting for frame time here)
      idm_comp_code_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { idm_comp_code_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { idm_comp_code_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { idm_comp_code_key_resp.clearEvents(); });
    }
    
    if (idm_comp_code_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = idm_comp_code_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _idm_comp_code_key_resp_allKeys = _idm_comp_code_key_resp_allKeys.concat(theseKeys);
      if (_idm_comp_code_key_resp_allKeys.length > 0) {
        idm_comp_code_key_resp.keys = _idm_comp_code_key_resp_allKeys[_idm_comp_code_key_resp_allKeys.length - 1].name;  // just the last key pressed
        idm_comp_code_key_resp.rt = _idm_comp_code_key_resp_allKeys[_idm_comp_code_key_resp_allKeys.length - 1].rt;
        idm_comp_code_key_resp.duration = _idm_comp_code_key_resp_allKeys[_idm_comp_code_key_resp_allKeys.length - 1].duration;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of idm_comp_codeComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function idm_comp_codeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'idm_comp_code' ---
    for (const thisComponent of idm_comp_codeComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('idm_comp_code.stopped', globalClock.getTime());
    idm_comp_code_key_resp.stop();
    // the Routine "idm_comp_code" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


function importConditions(currentLoop) {
  return async function () {
    psychoJS.importAttributes(currentLoop.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}


async function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
